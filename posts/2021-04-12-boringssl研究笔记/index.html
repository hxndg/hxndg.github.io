<!DOCTYPE html>
<html lang="cn" dir="ltr" class="scroll-smooth" data-default-appearance="light"
  data-auto-appearance="true"><head>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="zh-cn" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>boringSSL研究笔记 &middot; 菜狗的blog</title>
  <meta name="title" content="boringSSL研究笔记 &middot; 菜狗的blog" />
  
  <meta name="description" content="菜狗&#39;s website" />
  <meta name="keywords" content="八股, " />
  
  
  <link rel="canonical" href="https://hxndg.github.io/posts/2021-04-12-boringssl%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.36c3cd7950e4533fa7da3150d972e3edf34d07f83c0264ff04cad0969dfdb3b8a7065b0ed6c730c6d34a7bad516cfc6f6a5917ab1fdb10b25f481f8a17b54c16.css"
    integrity="" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.b6411b5d4cd56c0068d34c4acbce043846adad56b824e3d486a06d3459aed2eb7f7413874b7871cc2c822c8c8834cbed944022918bcc8cca710a962167c36d32.js"
    integrity="sha512-tkEbXUzVbABo00xKy84EOEatrVa4JOPUhqBtNFmu0ut/dBOHS3hxzCyCLIyINMvtlEAikYvMjMpxCpYhZ8NtMg==" data-copy="复制" data-copied="已复制"></script>
  
  
  
  <script src="/lib/zoom/zoom.min.f592a181a15d2a5b042daa7f746c3721acf9063f8b6acd175d989129865a37d400ae0e85b640f9ad42cd98d1f8ad30931718cf8811abdcc5fcb264400d1a2b0c.js" integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj&#43;Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="https://hxndg.github.io/posts/2021-04-12-boringssl%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/">
  <meta property="og:site_name" content="菜狗的blog">
  <meta property="og:title" content="boringSSL研究笔记">
  <meta property="og:description" content="菜狗&#39;s website">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-04-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2021-04-12T00:00:00+00:00">
    <meta property="article:tag" content="八股">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="boringSSL研究笔记">
  <meta name="twitter:description" content="菜狗&#39;s website">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "boringSSL研究笔记",
    "headline": "boringSSL研究笔记",
    
    
    "inLanguage": "zh-cn",
    "url" : "https:\/\/hxndg.github.io\/posts\/2021-04-12-boringssl%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0\/",
    "author" : {
      "@type": "Person",
      "name": "菜狗"
    },
    "copyrightYear": "2021",
    "dateCreated": "2021-04-12T00:00:00\u002b00:00",
    "datePublished": "2021-04-12T00:00:00\u002b00:00",
    
    "dateModified": "2021-04-12T00:00:00\u002b00:00",
    
    "keywords": ["八股"],
    
    "mainEntityOfPage": "true",
    "wordCount": "16324"
  }]
  </script>


  
  
  <meta name="author" content="菜狗" />
  
  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>






















  
  

<script async src="https://www.googletagmanager.com/gtag/js?id=G-6X9LWNJ427"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6X9LWNJ427');
</script>



  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">菜狗的blog</a>
            

        </nav>
        <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">

            
            
            
  <a href="/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="菜狗的blog">
        Home
    </p>
</a>



            
            
  <a href="/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Posts">
        Posts
    </p>
</a>



            
            
  <a href="/tags/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Tags">
        Tags
    </p>
</a>



            
            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class=" flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 md:hidden">

        <label id="menu-button" class="block">
            
            <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
                

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>

  </span>


            </div>
            <div id="menu-wrapper" style="padding-top:5px;"
                class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50">
                <ul
                    class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl">

                    <li id="menu-close-button">
                        <span
                            class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>

</span>
                    </li>

                    

                    
  <li class="mt-1">
    <a href="/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="菜狗的blog">
            Home
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Posts">
            Posts
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/tags/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Tags">
            Tags
        </p>
    </a>
</li>




                    

                </ul>
                
                

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  
  
  
  
  
  
 



  
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      boringSSL研究笔记
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  













<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2021-04-12T00:00:00&#43;00:00">2021 年 4 月 12 日</time><span class="px-2 text-primary-500">&middot;</span><span>16324 字</span><span class="px-2 text-primary-500">&middot;</span><span title="预计阅读">33 分钟</span>
  

  
  
</div>








    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
  <div class="place-self-center">
    
    <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
      作者
    </div>
    <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
      菜狗
    </div>
    
    
    <div class="text-sm text-neutral-700 dark:text-neutral-400">Focus</div>
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
     <div
      class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8">
      <div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10">

         <details open id="TOCView"
  class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    目录
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#0-技术调研和总览">0 技术调研和总览</a>
      <ul>
        <li><a href="#01-如何做技术调研">0.1 如何做技术调研</a></li>
        <li><a href="#02-调研计划">0.2 调研计划</a>
          <ul>
            <li><a href="#021-调研对象和方法">0.2.1 调研对象和方法</a></li>
            <li><a href="#022-调研结果">0.2.2 调研结果</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#1-连接相关的数据结构">1 连接相关的数据结构</a>
      <ul>
        <li><a href="#11-cipher数据结构">1.1 cipher数据结构</a></li>
        <li><a href="#12-握手的基本数据结构">1.2 握手的基本数据结构</a>
          <ul>
            <li><a href="#121-tls连接结构">1.2.1 TLS连接结构</a></li>
            <li><a href="#122-ssl握手模板结构">1.2.2 SSL握手模板结构</a></li>
          </ul>
        </li>
        <li><a href="#13-握手加解密过程当中涉及到的数据结构">1.3 握手/加解密过程当中涉及到的数据结构</a>
          <ul>
            <li><a href="#131-transcript-hash数据结构">1.3.1 transcript hash数据结构</a></li>
            <li><a href="#132-aead-context">1.3.2 AEAD context</a></li>
            <li><a href="#133-key-share结构">1.3.3 Key Share结构</a></li>
            <li><a href="#134-ech-拓展">1.3.4 ECH 拓展</a></li>
            <li><a href="#135-ssl_config结构">1.3.5 SSL_CONFIG结构</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2-握手函数">2 握手函数</a>
      <ul>
        <li><a href="#21-握手相关函数">2.1 握手相关函数</a></li>
      </ul>
    </li>
    <li><a href="#3-基本的属性和值">3 基本的属性和值</a>
      <ul>
        <li><a href="#31-protocol-version和函数">3.1 protocol version和函数</a></li>
        <li><a href="#32-ctx的属性和函数">3.2 CTX的属性和函数</a></li>
        <li><a href="#33-证书和私钥相关函数">3.3 证书和私钥相关函数</a></li>
      </ul>
    </li>
    <li><a href="#4-复用相关数据结构">4 复用相关数据结构</a>
      <ul>
        <li><a href="#41-session">4.1 SESSION</a></li>
        <li><a href="#42-session-cache">4.2 SESSION CACHE</a></li>
        <li><a href="#43-session-ticket">4.3 SESSION TICKET</a></li>
      </ul>
    </li>
    <li><a href="#5-拓展相关数据结构">5 拓展相关数据结构</a>
      <ul>
        <li><a href="#51-alpn">5.1 ALPN</a></li>
        <li><a href="#52-npn">5.2 NPN</a></li>
      </ul>
    </li>
    <li><a href="#结尾">结尾</a></li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    目录
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#0-技术调研和总览">0 技术调研和总览</a>
      <ul>
        <li><a href="#01-如何做技术调研">0.1 如何做技术调研</a></li>
        <li><a href="#02-调研计划">0.2 调研计划</a>
          <ul>
            <li><a href="#021-调研对象和方法">0.2.1 调研对象和方法</a></li>
            <li><a href="#022-调研结果">0.2.2 调研结果</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#1-连接相关的数据结构">1 连接相关的数据结构</a>
      <ul>
        <li><a href="#11-cipher数据结构">1.1 cipher数据结构</a></li>
        <li><a href="#12-握手的基本数据结构">1.2 握手的基本数据结构</a>
          <ul>
            <li><a href="#121-tls连接结构">1.2.1 TLS连接结构</a></li>
            <li><a href="#122-ssl握手模板结构">1.2.2 SSL握手模板结构</a></li>
          </ul>
        </li>
        <li><a href="#13-握手加解密过程当中涉及到的数据结构">1.3 握手/加解密过程当中涉及到的数据结构</a>
          <ul>
            <li><a href="#131-transcript-hash数据结构">1.3.1 transcript hash数据结构</a></li>
            <li><a href="#132-aead-context">1.3.2 AEAD context</a></li>
            <li><a href="#133-key-share结构">1.3.3 Key Share结构</a></li>
            <li><a href="#134-ech-拓展">1.3.4 ECH 拓展</a></li>
            <li><a href="#135-ssl_config结构">1.3.5 SSL_CONFIG结构</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2-握手函数">2 握手函数</a>
      <ul>
        <li><a href="#21-握手相关函数">2.1 握手相关函数</a></li>
      </ul>
    </li>
    <li><a href="#3-基本的属性和值">3 基本的属性和值</a>
      <ul>
        <li><a href="#31-protocol-version和函数">3.1 protocol version和函数</a></li>
        <li><a href="#32-ctx的属性和函数">3.2 CTX的属性和函数</a></li>
        <li><a href="#33-证书和私钥相关函数">3.3 证书和私钥相关函数</a></li>
      </ul>
    </li>
    <li><a href="#4-复用相关数据结构">4 复用相关数据结构</a>
      <ul>
        <li><a href="#41-session">4.1 SESSION</a></li>
        <li><a href="#42-session-cache">4.2 SESSION CACHE</a></li>
        <li><a href="#43-session-ticket">4.3 SESSION TICKET</a></li>
      </ul>
    </li>
    <li><a href="#5-拓展相关数据结构">5 拓展相关数据结构</a>
      <ul>
        <li><a href="#51-alpn">5.1 ALPN</a></li>
        <li><a href="#52-npn">5.2 NPN</a></li>
      </ul>
    </li>
    <li><a href="#结尾">结尾</a></li>
  </ul>
</nav>
  </div>
</details>

<script>

  var margin = 200;
  var marginError = 50;

  (function () {
    var $window = $(window);
    var $toc = $('#TOCView');
    var tocHeight = $toc.height();

    function onResize() {
      var windowAndMarginHeight = $window.height() - margin;
      if(tocHeight >= windowAndMarginHeight) {
        $toc.css("overflow-y", "scroll")
        $toc.css("max-height", (windowAndMarginHeight + marginError) + "px")
      } else {
        $toc.css("overflow-y", "hidden")
        $toc.css("max-height", "9999999px")
      }
    }

    $window.on('resize', onResize);
    $(document).ready(onResize);
  })();



</script>
   </div>
      </div>
      

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          

<h1 class="relative group">2021-04-12-boringSSL研究笔记 
    <div id="2021-04-12-boringssl%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2021-04-12-boringssl%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0" aria-label="锚点">#</a>
    </span>        
    
</h1>
<p>boringSSL是google处于方便目的自己实现的SSL库，和openssl的通配性相比，boringSSL主要是定制型比较好，这几天我就打算研究下boringSSL和openSSL的差别。先从基本的数据结构出发，一部分的数据结构不言自明，就不多赘述了。有一点需要注意，想学习源码必须熟悉RFC！很多基础知识不会过多赘述，就是RFC的内容。</p>
<p>BORING SSL和OPENSSL相比较使用的参数，命令行的选项之类的东西都非常类似。</p>
<p>我这片博客的第一部分是技术调研，用来确定企业内部TLS方面的部分信息，如果对你有帮助可以给我邮箱发个邮件说说是哪几点，这样子也算是起到了一些帮助。</p>


<h2 class="relative group">0 技术调研和总览 
    <div id="0-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E5%92%8C%E6%80%BB%E8%A7%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#0-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E5%92%8C%E6%80%BB%E8%A7%88" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">0.1 如何做技术调研 
    <div id="01-%E5%A6%82%E4%BD%95%E5%81%9A%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#01-%E5%A6%82%E4%BD%95%E5%81%9A%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>下面是记录的阅读的一部分技术调研的笔记。</p>
<ul>
<li>技术调研的目的是什么，需求是什么？泛需求？核心需求是什么</li>
<li>合理安排时间</li>
<li>调整心态</li>
</ul>
<p>最终呈现的结果，可以分为以下几个方面：</p>
<ul>
<li>核心需求是什么？想做什么事情？（这一部分可以和具体TLS相关写代码的人聊聊）</li>
<li>从哪些渠道收集了哪些信息？</li>
<li>做了哪些常识？</li>
<li>如果找到了解决方案，那么此方案的前提条件，适用场景，会不会有潜在的问题。优缺点分析，</li>
<li>如何落地？如果使用具体的功能，需要注意哪些方面</li>
</ul>
<p>具体到本次的调研，要考察</p>
<ul>
<li>具体技术的新不新，稳不稳定，容不容易维护</li>
<li>结果量化，从各个角度进行技术的量化</li>
<li>多搜集信息，类似的项目做了什么？它们的利弊有哪些？比较这些技术的相似和不同，他们的优缺点有哪些？</li>
<li>具体的技术如何落地？</li>
</ul>
<p>具体到本次的调研，要关注：</p>
<ul>
<li>性能方面的优化手段，包括但不限于计算加速，复用优化</li>
<li>安全性方面的改进，</li>
<li>兼容性剪裁，我们需要做哪些操作才能提供兼容，并且提供灵活的使用方法</li>
</ul>
<p>一些具体的手段：</p>
<ul>
<li>throughtworks技术雷达</li>
</ul>


<h3 class="relative group">0.2 调研计划 
    <div id="02-%E8%B0%83%E7%A0%94%E8%AE%A1%E5%88%92" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#02-%E8%B0%83%E7%A0%94%E8%AE%A1%E5%88%92" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">0.2.1 调研对象和方法 
    <div id="021-%E8%B0%83%E7%A0%94%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#021-%E8%B0%83%E7%A0%94%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>调研对象：BoringSSL和OpenSSL，及部分使用BoringSSL的开源软件（gRPC，chromium)</p>
<p>调研目的：调研BorringSSL基础库内做了哪些TLS的的功能性/安全性/性能方面的改造。</p>
<p>期望的调研结果：给出适用场景/优缺点比较/实现难易程度比较/性能比较</p>
<p>调研方法：1 调研BORGINSS L从2020年提交的PATCH，关注其中功能性方面的代码；2 BoringSSL文档中提供，而OpenSSL未提供的旧功能，尤其关注针对大规模环境下提交的功能；3 源代码剪裁，尤其是以gRPC为代表的软件所执行的代码剪裁。</p>


<h4 class="relative group">0.2.2 调研结果 
    <div id="022-%E8%B0%83%E7%A0%94%E7%BB%93%E6%9E%9C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#022-%E8%B0%83%E7%A0%94%E7%BB%93%E6%9E%9C" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>调研结果从以下几个方面展示：</p>
<ul>
<li>安全方面：重点关注BorringSSL实现了哪些新的安全功能，改进了哪些曾经的部件（流程），对TLS的利用到哪种程度</li>
<li>标准化方面：即BorringSSL提取出哪些组件为标准模块参与到基本功能里</li>
<li>性能方面：性能方面主要为TLS握手性能的优化。需区分TLS1.3和TLS1.3之前的协议</li>
<li>兼容性方面：主要表现为功能剪裁，即BoringSSL相比较OpenSSL筛检了哪些基本功能。</li>
</ul>


<h5 class="relative group">0.2.2.1 安全方面 
    <div id="0221-%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#0221-%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>安全方面BoringSSL全力推进HPKE的使用</p>
<ol>
<li>
<p>HPKE，混合公钥加密方案，目前主要用于非对称环境下的一次一密通信方案。目前已有的使用方案为ECH，用于加密SNI信息，保证所有握手信息的安全性，绕过第三方监控等等。<strong>OpenSSL不支持该功能，而BoringSSL已经作为基本组件进入代码库。</strong></p>
<p>HPKE的解释和优缺点：混合公钥加密方案，目前主要用于非对称环境下的一次一密通信方案。目前已有的使用方案为ECH，用于加密SNI信息，保证所有握手信息的安全性，绕过第三方监控等等。HPKE的优点是，其安全性经过机构证明，和实施时编写的代码细节没有直接关系，且性能良好。其缺点在于客户端必须预先共享真正服务器（backend server)的证书/公钥等信息，增加了客户端负担。HPKE适用于大规模启用TLS握手环境。实现难度较大。</p>
</li>
<li>
<p>AEAD取代过去的EncryptThenMac，使用AEAD替代过去加密和认证分离的储存机制。优点为安全和性能的兼顾，避免了程序员自己实现不安全的EThenC方案。缺点为目前已有的AEAD方案没有拆分开EThenC灵活，不能随意组合。<strong>OpenSSL提供了的AEAD接口，但是没有将AEAD作为一个通用模块参与到对敏感信息（如SESSION，Identity）的保护。</strong></p>
<p>AEAD的解释和优缺点：严格来说AEAD仍然是一种encrypt-then-authenticate的算法，但是AEAD的的认证过程和加密过程同时进行，而且无需特殊处理CBC加密块。因此AEAD需要较少的运算遍数，1遍（OCB，不常用），1.5遍（GCM，Poly1305），或2遍。这意味着AEAD比AES-CBC+HMAC的方案要快。单AEAD目前模式基本是固定的，没有拆分开的灵活。AEAD适用于任何敏感信息储存场景。实现难度较小。</p>
</li>
<li>
<p>TrustToken/PMBToken，GOOGLE用于替代第三方COOKIE而提出的方案，除了提供者和提供者授权的对象能够鉴别Token携带者是否为用户（也可用于区分用户和robot），第三方均无法鉴别。<strong>该方案不属于标准方案，因此OpenSSL并不支持</strong></p>
<p>TrustToken的优缺点：GOOGLE用于替代第三方COOKIE而提出的方案，除了提供者和提供者授权的对象能够鉴别Token携带者是否为用户（也可用于区分用户和robot），第三方无法鉴别。优点为trusttoken提供了完全保密性，即使是redeemer认为token是可信的，也不能从token当中得出用户的具体身份。缺点是：trusttoken并不抗重放，不能确认用户是其声称的角色。（Trust Tokens are a way to <strong>convey</strong> trust in a user, not <strong>establish</strong> trust in a user.）且其具体的使用方法需要结合环境变化，实现难度较大。</p>
</li>
<li>
<p>SSL_CTX_set_custom_verify证书校验异步操作，<strong>相比OpenSSL，BoringSSL单独将认证证书的流程拿出来从而提供更详细的认证控制</strong>。</p>
<p>BoringSSL对于计算流程，身份验证流程，证书签名流程均留了开放接口方便用户进行自定义操作，方便用户将签名/验签等流程交付给自定义/异步的真实后端操作。由于是可选的操作，因此不存在明显的优缺点。</p>
</li>
</ol>


<h5 class="relative group">0.2.2.2 标准化方面 
    <div id="0222-%E6%A0%87%E5%87%86%E5%8C%96%E6%96%B9%E9%9D%A2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#0222-%E6%A0%87%E5%87%86%E5%8C%96%E6%96%B9%E9%9D%A2" aria-label="锚点">#</a>
    </span>        
    
</h5>
<ol>
<li>
<p>AEAD的标准化，目前已知覆盖了敏感信息存储（SESSION TICKET）。AEAD的优缺点已经阐述过，不再赘述。</p>
</li>
<li>
<p>HKDF-EXPAND+HKDF-EXTRACT，逐渐替代过去的PRF。相比较而言BoringSSL内部已经开始大规模的使用HKDF替代过去的PRF流程，<strong>相比较而言，目前OPENSSL并没有使用HKDF替代过去的PRF</strong>。</p>
<p>HKDF优缺点：HKDF是TLS1.3中特别提出的PRF，作为安全基本件参与到整个运算当中。优点为更安全：即先经过HKDF-EXTRACT从原始密钥材料中提取出来的部分信息，再HKDF-Expand为最终密钥材料，增加了利用原始密钥材料进行分析的难度。TLS1.2当中只使用了HKDF-Expand部分。缺点同样是不够灵活，其内部依赖HMAC。HKDF适用于任何密钥延生/产生场景，实现难度较小。</p>
</li>
<li>
<p>SIPHASH，主要用于hash表的一种高速安全的伪随机码产生函数。<strong>BoringSSL，OpenSSL支持但是没有大规模使用</strong></p>
<p>SIPHASH的优缺点：SIPHASH于2012年设计，相比较传统的MAC算法，更高效且具备更高的理论安全（计算结果更为随机）。但SIPHASH本身并不是为MAC认证设计，因此用途相对单一，更适用于hashtable等使用场景。但由于hashtable一般内嵌于各种基础环境当中，因此使用SIPHASH改造底层代码会比较困难，实现难度较大。</p>
</li>
<li>
<p>GREASE，是&quot;Generate Random Extensions And Sustain Extensibility&quot;的简称，目前依然处于DRAFT阶段。<strong>BoringSSL已经支持，但OpenSSL并未支持</strong></p>
<p>GREASE优缺点：GREASE用于测试服务器/客户端的TLS实现是否正确，并用于简单的测试。它之所以有效依赖一个简单的前提：TLS期望服务端/客户端会忽视它们不是别的选项（协议/CIPHER/拓展等等）。从本质来说，GREASE只是一种测试，不存在所谓优缺点的问题。</p>
</li>
</ol>


<h5 class="relative group">0.2.2.3 性能方面 
    <div id="0223-%E6%80%A7%E8%83%BD%E6%96%B9%E9%9D%A2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#0223-%E6%80%A7%E8%83%BD%E6%96%B9%E9%9D%A2" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>性能部分分为两个方面，一个是gRPC/GOOGLE开始大规模采用的性能优化方案，另一个是bssl和OpenSSL本身的性能对比，作为附录附加在最后。</p>
<ol>
<li>
<p>证书压缩，使用证书压缩功能降低长证书链下传输的数据长度。证书压缩主要针对长证书链，目前证书压缩的应用场景主要集中在QUIC协议，普通TLS并未大规模使用，因此未进行性能测试。</p>
<p>证书压缩的优缺点：从理论来讲证书压缩只有优点没有缺点，但由于该标准刚刚成为正式RFC，尚未流行，支持的设备过少可能是该标准的缺点。实现难度较大。</p>
</li>
<li>
<p>TLS1.3的大规模使用，使用TLS1.3降低时延消耗(一个RTT）。需要注意两点：1 tls的clienthello报文往往是跟随三次握手的末尾一同到达对端。2 cloudfire的服务器在国外，一个RTT的影响较大。</p>
<table>
  <thead>
      <tr>
          <th>协议版本号</th>
          <th>被访问网站</th>
          <th>共耗时（1000次）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TLS1.2</td>
          <td><a href="https://www.cloudfire.com" target="_blank">www.cloudfire.com</a></td>
          <td>435.7983s</td>
      </tr>
      <tr>
          <td>TLS1.3</td>
          <td><a href="https://www.cloudfire.com" target="_blank">www.cloudfire.com</a></td>
          <td>231.5094s</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>使用复用模式降低握手性能消耗和时延，TLS1.3复用方案的选择，BorringSSL在TLS1.3才引入SESSION TICKET方案。通过[3]可知使用DH交换算法时，TLS1.3复用比TLS1.2复用快大约25%，使用ECDH-P-256, TLS 1.3复用快15%。</p>
<p>理论上来说，复用减少至少一次签名，因此复用应当比完整握手的新建性能高30%以上。此外由于TLS1.3的SESSION TICKET免除了SESSION CACHE本地缓存争用的问题，服务端的新建性能会提高一部分，但这一部分耗时相比完整握手的两次非对称运算耗时，优化的力度难以衡量，需要测量确定。由于缺乏性能工具，所以使用估算手段计算性能。以下测量值均评估自我的主机，纯软算。</p>
<table>
  <thead>
      <tr>
          <th>复用方案</th>
          <th>测试方法</th>
          <th>新建性能（理论值）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TLS1.3完整握手</td>
          <td>Bssl speed测试结果估算(384)</td>
          <td>173</td>
      </tr>
      <tr>
          <td>TLS1.3复用握手</td>
          <td>Bssl speed测试结果估算(384)</td>
          <td>438</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>AEAD存储敏感信息时具备更好的性能。</p>
<table>
  <thead>
      <tr>
          <th>具体算法</th>
          <th>操作对象</th>
          <th>平均速度</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>AES256(CBC)+HMAC(SHA1)</td>
          <td>16386字节数据</td>
          <td>Did 32000 AES-256-CBC-SHA1 (16384 bytes) open operations in 1010359us (31671.9 ops/sec): 518.9 MB/s</td>
      </tr>
      <tr>
          <td>AEAD（AES256-GCM）</td>
          <td>相同的16384字节数据</td>
          <td>Did 253000 AES-256-GCM (16384 bytes) seal operations in 1000260us (252934.2 ops/sec): 4144.1 MB/s</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>前向安全，每次握手使用静态的公钥密钥对进行握手，降低计算非对称密钥的成本。有一点需要注意TLS1.3是必然提供前向安全的，该优化针对TLS1.3之前的协议。Google在ALTS中通过轮换密钥来保证过去的流量不会被破解。每次采用静态公私密钥对减少了椭圆曲线计算的性能消耗，理论上应该至少能有20%新建性能的提升。</p>
<table>
  <thead>
      <tr>
          <th>方案</th>
          <th>操作对象</th>
          <th>新建性能（理论值）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>不提供前向安全</td>
          <td>ECDH P384</td>
          <td>286</td>
      </tr>
      <tr>
          <td>前向安全</td>
          <td>ECDH P384</td>
          <td>173</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>ALPN，通信时延是性能消耗的主要来源，因此采用ALPN拓展协议能够在TLS协议协商过程当中直接确定上次协议的通信细节，避免再引入上层协议的通信延时。</p>
<p>APLN的优缺点：APLN从理论来讲不存在缺点，但是需要TLS和上层协议结合可能是其唯一缺点。</p>
</li>
</ol>


<h5 class="relative group">0.2.2.4 兼容性方面 
    <div id="0224-%E5%85%BC%E5%AE%B9%E6%80%A7%E6%96%B9%E9%9D%A2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#0224-%E5%85%BC%E5%AE%B9%E6%80%A7%E6%96%B9%E9%9D%A2" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>下表为具体的兼容性剪裁对比。</p>
<table>
  <thead>
      <tr>
          <th>功能剪裁</th>
          <th>OPENSSL</th>
          <th>BORINGSSL（GRPC, CHROMIUM）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TLS PROTOCOL</td>
          <td>TLS1.0-TLS1.3</td>
          <td>TLS1_2, TLS1_3(GRPC和chromium都不支持TLS1.0/1.1，CHROME81即不再支持)</td>
      </tr>
      <tr>
          <td>默认CIPHER</td>
          <td>TLS协议对应的所有协议</td>
          <td>&ldquo;TLS_AES_128_GCM_SHA256:&rdquo; <br/>   &ldquo;TLS_AES_256_GCM_SHA384:&quot;<br/>   &ldquo;TLS_CHACHA20_POLY1305_SHA256:&quot;<br/>    &ldquo;ECDHE-ECDSA-AES128-GCM-SHA256:&quot;<br/>    &ldquo;ECDHE-ECDSA-AES256-GCM-SHA384:&quot;<br/>    &ldquo;ECDHE-RSA-AES128-GCM-SHA256:&quot;<br/>    &ldquo;ECDHE-RSA-AES256-GCM-SHA384&rdquo;,</td>
      </tr>
      <tr>
          <td>签名算法</td>
          <td>ecdsa_secp256r1_sha256 (0x0403)<br/>ecdsa_secp384r1_sha384 (0x0503)<br/>ecdsa_secp521r1_sha512 (0x0603)<br/>ed25519 (0x0807)<br/>ed448 (0x0808)<br/>rsa_pss_pss_sha256 (0x0809)<br/>rsa_pss_pss_sha384 (0x080a)<br/>rsa_pss_pss_sha512 (0x080b)<br/>rsa_pss_rsae_sha256 (0x0804)<br/>rsa_pss_rsae_sha384 (0x0805)<br/>rsa_pss_rsae_sha512 (0x0806)<br/>rsa_pkcs1_sha256 (0x0401)<br/>rsa_pkcs1_sha384 (0x0501)<br/>rsa_pkcs1_sha512 (0x0601)<br/>SHA224 ECDSA (0x0303)<br/>ecdsa_sha1 (0x0203)<br/>SHA224 RSA (0x0301)<br/>rsa_pkcs1_sha1 (0x0201)<br/>SHA224 DSA (0x0302)<br/>SHA1 DSA (0x0202)<br/>SHA256 DSA (0x0402)<br/>SHA384 DSA (0x0502)<br/>SHA512 DSA (0x0602)</td>
          <td>SSL_SIGN_ECDSA_SECP256R1_SHA256,<br/>    SSL_SIGN_RSA_PSS_RSAE_SHA256,<br/>    SSL_SIGN_RSA_PKCS1_SHA256,<br/><br/>    // Larger hashes are acceptable.<br/>    SSL_SIGN_ECDSA_SECP384R1_SHA384,<br/>    SSL_SIGN_RSA_PSS_RSAE_SHA384,<br/>    SSL_SIGN_RSA_PKCS1_SHA384,<br/><br/>    SSL_SIGN_RSA_PSS_RSAE_SHA512,<br/>    SSL_SIGN_RSA_PKCS1_SHA512,<br/><br/>    // For now, SHA-1 is still accepted but least preferable.<br/>    SSL_SIGN_RSA_PKCS1_SHA1,<br/></td>
      </tr>
      <tr>
          <td>校验客户端证书支持的verify算法</td>
          <td>和上面一致，都支持</td>
          <td>SSL_SIGN_ED25519,<br/>    SSL_SIGN_ECDSA_SECP256R1_SHA256,<br/>    SSL_SIGN_RSA_PSS_RSAE_SHA256,<br/>    SSL_SIGN_RSA_PKCS1_SHA256,<br/><br/>    // If needed, sign larger hashes.<br/>    //<br/>    // TODO(davidben): Determine which of these may be pruned.<br/>    SSL_SIGN_ECDSA_SECP384R1_SHA384,<br/>    SSL_SIGN_RSA_PSS_RSAE_SHA384,<br/>    SSL_SIGN_RSA_PKCS1_SHA384,<br/><br/>    SSL_SIGN_ECDSA_SECP521R1_SHA512,<br/>    SSL_SIGN_RSA_PSS_RSAE_SHA512,<br/>    SSL_SIGN_RSA_PKCS1_SHA512,<br/><br/>    // If the peer supports nothing else, sign with SHA-1.<br/>    SSL_SIGN_ECDSA_SHA1,<br/>    SSL_SIGN_RSA_PKCS1_SHA1,<br/></td>
      </tr>
      <tr>
          <td>支持的曲线（groups）</td>
          <td>x25519 (0x001d)<br/>secp256r1 (0x0017)<br/>x448 (0x001e)<br/>secp521r1 (0x0019)<br/>secp384r1 (0x0018)</td>
          <td>{NID_secp224r1,  &ldquo;P-224&rdquo;, &ldquo;secp224r1&rdquo;},<br/>{NID_X9_62_prime256v1, , &ldquo;P-256&rdquo;, &ldquo;prime256v1&rdquo;},<br/>{NID_secp384r1, &ldquo;P-384&rdquo;, &ldquo;secp384r1&rdquo;},<br/>{NID_secp521r1, &ldquo;P-521&rdquo;, &ldquo;secp521r1&rdquo;},<br/>{NID_X25519, &ldquo;X25519&rdquo;, &ldquo;x25519&rdquo;},<br/>{NID_CECPQ2, &ldquo;CECPQ2&rdquo;, &ldquo;CECPQ2&rdquo;},</td>
      </tr>
      <tr>
          <td>SESSION TICKET复用</td>
          <td>TLS1-TLS1.3都支持</td>
          <td>仅TLS1.3支持</td>
      </tr>
      <tr>
          <td>默认的证书校验方式</td>
          <td>也是只校验服务端证书，不校验SNI</td>
          <td>GRPC_TLS_SERVER_VERIFICATION 校验证书和SNI必须匹配</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>


<h2 class="relative group">1 连接相关的数据结构 
    <div id="1-%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1-%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">1.1 cipher数据结构 
    <div id="11-cipher%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#11-cipher%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>boringSSL取了cipher的通用name和具体的cipher id（和clienthello中保持一致），但是和openssl不一致的地方是boringSSL拆出来了通用属性，作为结构体里面的成员。可以看到，拆出来了秘钥交换算法，认证算法，对称加密算法，MAC算法，秘钥衍生算法。有一个很有趣的东西是<code>SSLCipherPreferenceList</code>，这个东西提供了prefertcert功能。头文件定义于internal.h文件，具体代码见下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ssl_cipher_st</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// name is the OpenSSL name for the cipher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// standard_name is the IETF name for the cipher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">standard_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// id is the cipher suite value bitwise OR-d with 0x03000000.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// algorithm_* determine the cipher suite. See constants below for the values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">algorithm_mkey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">algorithm_auth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">algorithm_enc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">algorithm_mac</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">algorithm_prf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BSSL_NAMESPACE_BEGIN</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Bits for |algorithm_mkey| (key exchange algorithm).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_kRSA 0x00000001u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_kECDHE 0x00000002u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// SSL_kPSK is only set for plain PSK, not ECDHE_PSK.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_kPSK 0x00000004u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_kGENERIC 0x00000008u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Bits for |algorithm_auth| (server authentication).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_aRSA 0x00000001u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_aECDSA 0x00000002u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// SSL_aPSK is set for both PSK and ECDHE_PSK.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_aPSK 0x00000004u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_aGENERIC 0x00000008u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SSL_aCERT (SSL_aRSA | SSL_aECDSA)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Bits for |algorithm_enc| (symmetric encryption).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_3DES 0x00000001u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_AES128 0x00000002u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_AES256 0x00000004u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_AES128GCM 0x00000008u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_AES256GCM 0x00000010u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_eNULL 0x00000020u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_CHACHA20POLY1305 0x00000040u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SSL_AES (SSL_AES128 | SSL_AES256 | SSL_AES128GCM | SSL_AES256GCM)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Bits for |algorithm_mac| (symmetric authentication).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_SHA1 0x00000001u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// SSL_AEAD is set for all AEADs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_AEAD 0x00000002u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Bits for |algorithm_prf| (handshake digest).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_HANDSHAKE_MAC_DEFAULT 0x1
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_HANDSHAKE_MAC_SHA256 0x2
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL_HANDSHAKE_MAC_SHA384 0x4
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// SSL_MAX_MD_SIZE is size of the largest hash function used in TLS, SHA-384.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SSL_MAX_MD_SIZE 48
</span></span></span></code></pre></div>

<h3 class="relative group">1.2 握手的基本数据结构 
    <div id="12-%E6%8F%A1%E6%89%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#12-%E6%8F%A1%E6%89%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">1.2.1 TLS连接结构 
    <div id="121-tls%E8%BF%9E%E6%8E%A5%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#121-tls%E8%BF%9E%E6%8E%A5%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>可以看出来SSL_HANDSHAKE结构和具体的握手状态是相关的，具体的握手状态在自动机里面才会用到，先不过于关注这几个东西。BoringSSL添加了一个SSL_CONFIG结构用于完成握手之后给后面连接保存必要的信息。 <code>SSL</code>并不是线程安全的，任何时刻只能有一个线程使用该数据结构。具体的配置可以直接对<code>SSL_CTX</code>结构或者世界对<code>SSL</code>结构配置。实际上这个东西就是我们关注的对象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">ssl_hs_wait_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_error</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_ok</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_read_server_hello</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_read_message</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_flush</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_certificate_selection_pending</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_handoff</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_handback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_x509_lookup</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_channel_id_lookup</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_private_key_operation</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_pending_session</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_pending_ticket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_early_return</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_early_data_rejected</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_read_end_of_early_data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_read_change_cipher_spec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_hs_certificate_verify</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">ssl_grease_index_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_cipher</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_group</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_extension1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_extension2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_ticket_extension</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_grease_last_index</span> <span class="o">=</span> <span class="n">ssl_grease_ticket_extension</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">tls12_server_hs_state_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_start_accept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_client_hello</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_client_hello_after_ech</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_select_certificate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_tls13</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_select_parameters</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_send_server_hello</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_send_server_certificate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_send_server_key_exchange</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_send_server_hello_done</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_client_certificate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_verify_client_certificate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_client_key_exchange</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_client_certificate_verify</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_change_cipher_spec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_process_change_cipher_spec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_next_proto</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_channel_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_read_client_finished</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_send_server_finished</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_finish_server_handshake</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state12_done</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">tls13_server_hs_state_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_select_parameters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_select_session</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_send_hello_retry_request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_second_client_hello</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_send_server_hello</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_send_server_certificate_verify</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_send_server_finished</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_send_half_rtt_ticket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_second_client_flight</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_process_end_of_early_data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_client_encrypted_extensions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_client_certificate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_client_certificate_verify</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_channel_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_read_client_finished</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_send_new_session_ticket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">state13_done</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// handback_t lists the points in the state machine where a handback can occur.
</span></span></span><span class="line"><span class="cl"><span class="c1">// These are the different points at which key material is no longer needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="nc">handback_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">handback_after_session_resumption</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">handback_after_ecdhe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">handback_after_handshake</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">handback_tls13</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">handback_max_value</span> <span class="o">=</span> <span class="n">handback_tls13</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SSL_HANDSHAKE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">SSL_HANDSHAKE</span><span class="p">(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">SSL_HANDSHAKE</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">kAllowUniquePtr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ssl is a non-owning pointer to the parent |SSL| object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// config is a non-owning pointer to the handshake configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SSL_CONFIG</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// wait contains the operation the handshake is currently blocking on or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |ssl_hs_ok| if none.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">enum</span> <span class="nc">ssl_hs_wait_t</span> <span class="n">wait</span> <span class="o">=</span> <span class="n">ssl_hs_ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// state is the internal state for the TLS 1.2 and below handshake. Its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// values depend on |do_handshake| but the starting state is always zero.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// tls13_state is the internal state for the TLS 1.3 handshake. Its values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// depend on |do_handshake| but the starting state is always zero.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">tls13_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// min_version is the minimum accepted protocol version, taking account both
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_OP_NO_*| and |SSL_CTX_set_min_proto_version| APIs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">min_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// max_version is the maximum accepted protocol version, taking account both
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_OP_NO_*| and |SSL_CTX_set_max_proto_version| APIs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">max_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">hash_len_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">secret_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">early_traffic_secret_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">client_handshake_secret_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">server_handshake_secret_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">client_traffic_secret_0_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">server_traffic_secret_0_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">expected_client_finished_</span><span class="p">[</span><span class="n">SSL_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">ResizeSecrets</span><span class="p">(</span><span class="n">size_t</span> <span class="n">hash_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// GetClientHello, on the server, returns either the normal ClientHello
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// message or the ClientHelloInner if it has been serialized to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |ech_client_hello_buf|. This function should only be called when the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// current message is a ClientHello. It returns true on success and false on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Note that fields of the returned |out_msg| and |out_client_hello| point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// into a handshake-owned buffer, so their lifetimes should not exceed this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSL_HANDSHAKE.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">GetClientHello</span><span class="p">(</span><span class="n">SSLMessage</span> <span class="o">*</span><span class="n">out_msg</span><span class="p">,</span> <span class="n">SSL_CLIENT_HELLO</span> <span class="o">*</span><span class="n">out_client_hello</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">secret</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">secret_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">early_traffic_secret</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">early_traffic_secret_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">client_handshake_secret</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">client_handshake_secret_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">server_handshake_secret</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">server_handshake_secret_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">client_traffic_secret_0</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">client_traffic_secret_0_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">server_traffic_secret_0</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">server_traffic_secret_0_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">expected_client_finished</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeSpan</span><span class="p">(</span><span class="n">expected_client_finished_</span><span class="p">,</span> <span class="n">hash_len_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sent is a bitset where the bits correspond to elements of kExtensions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// in t1_lib.c. Each bit is set if that extension was sent in a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ClientHello. It&#39;s not used by servers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// received is a bitset, like |sent|, but is used by servers to record
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which extensions were received from a client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">received</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">extensions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// retry_group is the group ID selected by the server in HelloRetryRequest in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TLS 1.3.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">retry_group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// error, if |wait| is |ssl_hs_error|, is the error the handshake failed on.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">ERR_SAVE_STATE</span><span class="o">&gt;</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// key_shares are the current key exchange instances. The second is only used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// as a client if we believe that we should offer two key shares in a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ClientHello.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLKeyShare</span><span class="o">&gt;</span> <span class="n">key_shares</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// transcript is the current handshake transcript.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SSLTranscript</span> <span class="n">transcript</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cookie is the value of the cookie received from the server, if any.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">cookie</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_grease contains the bytes of the GREASE ECH extension that was sent in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the first ClientHello.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ech_grease</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_client_hello_buf, on the server, contains the bytes of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reconstructed ClientHelloInner message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ech_client_hello_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// key_share_bytes is the value of the previously sent KeyShare extension by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the client in TLS 1.3.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">key_share_bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ecdh_public_key, for servers, is the key share to be sent to the client in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TLS 1.3.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ecdh_public_key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_sigalgs are the signature algorithms that the peer supports. These are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// taken from the contents of the signature algorithms extension for a server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// or from the CertificateRequest for a client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">peer_sigalgs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_supported_group_list contains the supported group IDs advertised by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the peer. This is only set on the server&#39;s end. The server does not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// advertise this extension to the client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">peer_supported_group_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_delegated_credential_sigalgs are the signature algorithms the peer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// supports with delegated credentials.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">peer_delegated_credential_sigalgs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_key is the peer&#39;s ECDH key for a TLS 1.2 client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">peer_key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// negotiated_token_binding_version is used by a server to store the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on-the-wire encoding of the Token Binding protocol version to advertise in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the ServerHello/EncryptedExtensions if the Token Binding extension is to be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// sent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">negotiated_token_binding_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cert_compression_alg_id, for a server, contains the negotiated certificate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// compression algorithm for this client. It is only valid if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |cert_compression_negotiated| is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">cert_compression_alg_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_hpke_ctx, on the server, is the HPKE context used to decrypt the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// client&#39;s ECH payloads.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ScopedEVP_HPKE_CTX</span> <span class="n">ech_hpke_ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// server_params, in a TLS 1.2 server, stores the ServerKeyExchange
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// parameters. It has client and server randoms prepended for signing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// convenience.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">server_params</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_psk_identity_hint, on the client, is the psk_identity_hint sent by the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// server when using a TLS 1.2 PSK key exchange.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">peer_psk_identity_hint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ca_names, on the client, contains the list of CAs received in a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// CertificateRequest message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">STACK_OF</span><span class="p">(</span><span class="n">CRYPTO_BUFFER</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ca_names</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cached_x509_ca_names contains a cache of parsed versions of the elements of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |ca_names|. This pointer is left non-owning so only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |ssl_crypto_x509_method| needs to link against crypto/x509.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509_NAME</span><span class="p">)</span> <span class="o">*</span><span class="n">cached_x509_ca_names</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// certificate_types, on the client, contains the set of certificate types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// received in a CertificateRequest message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">certificate_types</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// local_pubkey is the public key we are authenticating as.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">EVP_PKEY</span><span class="o">&gt;</span> <span class="n">local_pubkey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_pubkey is the public key parsed from the peer&#39;s leaf certificate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">EVP_PKEY</span><span class="o">&gt;</span> <span class="n">peer_pubkey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// new_session is the new mutable session being established by the current
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// handshake. It should not be cached.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_SESSION</span><span class="o">&gt;</span> <span class="n">new_session</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// early_session is the session corresponding to the current 0-RTT state on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the client if |in_early_data| is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_SESSION</span><span class="o">&gt;</span> <span class="n">early_session</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_server_config_list, for servers, is the list of ECHConfig values that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// were valid when the server received the first ClientHello. Its value will
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// not change when the config list on |SSL_CTX| is updated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_ECH_SERVER_CONFIG_LIST</span><span class="o">&gt;</span> <span class="n">ech_server_config_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// new_cipher is the cipher being negotiated in this handshake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">new_cipher</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// key_block is the record-layer key block for TLS 1.2 and earlier.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">key_block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_accept, on the server, indicates whether the server should overwrite
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// part of ServerHello.random with the ECH accept_confirmation value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ech_accept</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_present, on the server, indicates whether the ClientHello contained an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// encrypted_client_hello extension.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ech_present</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_is_inner_present, on the server, indicates whether the ClientHello
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// contained an ech_is_inner extension.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ech_is_inner_present</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// scts_requested is true if the SCT extension is in the ClientHello.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">scts_requested</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// needs_psk_binder is true if the ClientHello has a placeholder PSK binder to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// be filled in.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">needs_psk_binder</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// handshake_finalized is true once the handshake has completed, at which
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// point accessors should use the established state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">handshake_finalized</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// accept_psk_mode stores whether the client&#39;s PSK mode is compatible with our
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// preferences.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">accept_psk_mode</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cert_request is true if a client certificate was requested.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">cert_request</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// certificate_status_expected is true if OCSP stapling was negotiated and the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// server is expected to send a CertificateStatus message. (This is used on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// both the client and server sides.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">certificate_status_expected</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ocsp_stapling_requested is true if a client requested OCSP stapling.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ocsp_stapling_requested</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// delegated_credential_requested is true if the peer indicated support for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the delegated credential extension.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">delegated_credential_requested</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// should_ack_sni is used by a server and indicates that the SNI extension
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// should be echoed in the ServerHello.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">should_ack_sni</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// in_false_start is true if there is a pending client handshake in False
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Start. The client may write data at this point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">in_false_start</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// in_early_data is true if there is a pending handshake that has progressed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// enough to send and receive early data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">in_early_data</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// early_data_offered is true if the client sent the early_data extension.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">early_data_offered</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// can_early_read is true if application data may be read at this point in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// handshake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">can_early_read</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// can_early_write is true if application data may be written at this point in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the handshake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">can_early_write</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// next_proto_neg_seen is one of NPN was negotiated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">next_proto_neg_seen</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ticket_expected is true if a TLS 1.2 NewSessionTicket message is to be sent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// or received.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ticket_expected</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// extended_master_secret is true if the extended master secret extension is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// negotiated in this handshake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">extended_master_secret</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// pending_private_key_op is true if there is a pending private key operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// in progress.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">pending_private_key_op</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// grease_seeded is true if |grease_seed| has been initialized.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">grease_seeded</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// handback indicates that a server should pause the handshake after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// finishing operations that require private key material, in such a way that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_get_error| returns |SSL_ERROR_HANDBACK|.  It is set by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_apply_handoff|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">handback</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cert_compression_negotiated is true iff |cert_compression_alg_id| is valid.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">cert_compression_negotiated</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// apply_jdk11_workaround is true if the peer is probably a JDK 11 client
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// which implemented TLS 1.3 incorrectly.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">apply_jdk11_workaround</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// client_version is the value sent or received in the ClientHello version.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">client_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// early_data_read is the amount of early data that has been read by the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// record layer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">early_data_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// early_data_written is the amount of early data that has been written by the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// record layer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">early_data_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// session_id is the session ID in the ClientHello.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">session_id</span><span class="p">[</span><span class="n">SSL_MAX_SSL_SESSION_ID_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">session_id_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// grease_seed is the entropy for GREASE values. It is valid if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |grease_seeded| is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">grease_seed</span><span class="p">[</span><span class="n">ssl_grease_last_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h4 class="relative group">1.2.2 SSL握手模板结构 
    <div id="122-ssl%E6%8F%A1%E6%89%8B%E6%A8%A1%E6%9D%BF%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#122-ssl%E6%8F%A1%E6%89%8B%E6%A8%A1%E6%9D%BF%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>握手模板结构是原始握手的模板，通过跟这个协商产生具体的握手协议。 <code>SSL_CTX</code> 结构是线程安全的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ssl_ctx_st</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">ssl_ctx_st</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_METHOD</span> <span class="o">*</span><span class="n">ssl_method</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_ctx_st</span><span class="p">(</span><span class="k">const</span> <span class="n">ssl_ctx_st</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_ctx_st</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ssl_ctx_st</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">bssl</span><span class="o">::</span><span class="n">SSL_PROTOCOL_METHOD</span> <span class="o">*</span><span class="n">method</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">bssl</span><span class="o">::</span><span class="n">SSL_X509_METHOD</span> <span class="o">*</span><span class="n">x509_method</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// lock is used to protect various operations on this object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">CRYPTO_MUTEX</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// conf_max_version is the maximum acceptable protocol version configured by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_CTX_set_max_proto_version|. Note this version is normalized in DTLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and is further constrainted by |SSL_OP_NO_*|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">conf_max_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// conf_min_version is the minimum acceptable protocol version configured by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_CTX_set_min_proto_version|. Note this version is normalized in DTLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and is further constrainted by |SSL_OP_NO_*|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">conf_min_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// quic_method is the method table corresponding to the QUIC hooks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">SSL_QUIC_METHOD</span> <span class="o">*</span><span class="n">quic_method</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">bssl</span><span class="o">::</span><span class="n">SSLCipherPreferenceList</span><span class="o">&gt;</span> <span class="n">cipher_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">X509_STORE</span> <span class="o">*</span><span class="n">cert_store</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">LHASH_OF</span><span class="p">(</span><span class="n">SSL_SESSION</span><span class="p">)</span> <span class="o">*</span><span class="n">sessions</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Most session-ids that will be cached, default is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">session_cache_size</span> <span class="o">=</span> <span class="n">SSL_SESSION_CACHE_MAX_SIZE_DEFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session_cache_head</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session_cache_tail</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// handshakes_since_cache_flush is the number of successful handshakes since
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the last cache flush.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">handshakes_since_cache_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// This can have one of 2 values, ored together,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSL_SESS_CACHE_CLIENT,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSL_SESS_CACHE_SERVER,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Default is SSL_SESSION_CACHE_SERVER, which means only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSL_accept which cache SSL_SESSIONS.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">session_cache_mode</span> <span class="o">=</span> <span class="n">SSL_SESS_CACHE_SERVER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// session_timeout is the default lifetime for new sessions in TLS 1.2 and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// earlier, in seconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">session_timeout</span> <span class="o">=</span> <span class="n">SSL_DEFAULT_SESSION_TIMEOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// session_psk_dhe_timeout is the default lifetime for new sessions in TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 1.3, in seconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">session_psk_dhe_timeout</span> <span class="o">=</span> <span class="n">SSL_DEFAULT_SESSION_PSK_DHE_TIMEOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If this callback is not null, it will be called each time a session id is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// added to the cache.  If this function returns 1, it means that the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// callback will do a SSL_SESSION_free() when it has finished using it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Otherwise, on 0, it means the callback has finished with it. If
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// remove_session_cb is not null, it will be called when a session-id is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// removed from the cache.  After the call, OpenSSL will SSL_SESSION_free()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">new_session_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">sess</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove_session_cb</span><span class="p">)(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">sess</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_session_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="kt">int</span> <span class="o">*</span><span class="n">copy</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CRYPTO_refcount_t</span> <span class="n">references</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// if defined, these override the X509_verify_cert() calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">app_verify_callback</span><span class="p">)(</span><span class="n">X509_STORE_CTX</span> <span class="o">*</span><span class="n">store_ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">app_verify_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ssl_verify_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">custom_verify_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_alert</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Default password callback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pem_password_cb</span> <span class="o">*</span><span class="n">default_passwd_callback</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Default password callback user data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">default_passwd_callback_userdata</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// get client cert callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">client_cert_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="n">X509</span> <span class="o">**</span><span class="n">out_x509</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">EVP_PKEY</span> <span class="o">**</span><span class="n">out_pkey</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// get channel id callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">channel_id_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="n">EVP_PKEY</span> <span class="o">**</span><span class="n">out_pkey</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CRYPTO_EX_DATA</span> <span class="n">ex_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Default values used when no per-SSL value is defined follow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">info_callback</span><span class="p">)(</span><span class="k">const</span> <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// what we put in client cert requests
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">STACK_OF</span><span class="p">(</span><span class="n">CRYPTO_BUFFER</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">client_CA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cached_x509_client_CA is a cache of parsed versions of the elements of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |client_CA|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509_NAME</span><span class="p">)</span> <span class="o">*</span><span class="n">cached_x509_client_CA</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Default values to use in SSL structures follow (these are copied by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSL_new)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Disable the auto-chaining feature by default. wpa_supplicant relies on this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// feature, but require callers opt into it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">SSL_MODE_NO_AUTO_CHAIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">max_cert_list</span> <span class="o">=</span> <span class="n">SSL_MAX_CERT_LIST_DEFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">bssl</span><span class="o">::</span><span class="n">CERT</span><span class="o">&gt;</span> <span class="n">cert</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// callback that allows applications to peek at protocol messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_callback</span><span class="p">)(</span><span class="kt">int</span> <span class="n">write_p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="kt">int</span> <span class="n">content_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">msg_callback_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">verify_mode</span> <span class="o">=</span> <span class="n">SSL_VERIFY_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">default_verify_callback</span><span class="p">)(</span><span class="kt">int</span> <span class="n">ok</span><span class="p">,</span> <span class="n">X509_STORE_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// called &#39;verify_callback&#39; in the SSL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">X509_VERIFY_PARAM</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// select_certificate_cb is called before most ClientHello processing and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// before the decision whether to resume a session is made. See
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |ssl_select_cert_result_t| for details of the return values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ssl_select_cert_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">select_certificate_cb</span><span class="p">)(</span><span class="k">const</span> <span class="n">SSL_CLIENT_HELLO</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// dos_protection_cb is called once the resumption decision for a ClientHello
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// has been made. It returns one to continue the handshake or zero to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// abort.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dos_protection_cb</span><span class="p">)(</span><span class="k">const</span> <span class="n">SSL_CLIENT_HELLO</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Controls whether to verify certificates when resuming connections. They
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// were already verified when the connection was first made, so the default is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// false. For now, this is only respected on clients, not servers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">reverify_on_resume</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Maximum amount of data to send in one fragment. actual record size can be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// more than this due to padding and MAC overheads.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">max_send_fragment</span> <span class="o">=</span> <span class="n">SSL3_RT_MAX_PLAIN_LENGTH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TLS extensions servername callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">servername_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">servername_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// RFC 4507 session ticket keys. |ticket_key_current| may be NULL before the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// first handshake and |ticket_key_prev| may be NULL at any time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Automatically generated ticket keys are rotated as needed at handshake
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// time. Hence, all access must be synchronized through |lock|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">bssl</span><span class="o">::</span><span class="n">TicketKey</span><span class="o">&gt;</span> <span class="n">ticket_key_current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">bssl</span><span class="o">::</span><span class="n">TicketKey</span><span class="o">&gt;</span> <span class="n">ticket_key_prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Callback to support customisation of ticket key setting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ticket_key_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">EVP_CIPHER_CTX</span> <span class="o">*</span><span class="n">ectx</span><span class="p">,</span> <span class="n">HMAC_CTX</span> <span class="o">*</span><span class="n">hctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enc</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Server-only: psk_identity_hint is the default identity hint to send in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// PSK-based key exchanges.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">psk_identity_hint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="p">(</span><span class="o">*</span><span class="n">psk_client_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hint</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">unsigned</span> <span class="n">max_identity_len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">psk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">unsigned</span> <span class="n">max_psk_len</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="p">(</span><span class="o">*</span><span class="n">psk_server_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">psk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">unsigned</span> <span class="n">max_psk_len</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Next protocol negotiation information
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// (for experimental NPN extension).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// For a server, this contains a callback function by which the set of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// advertised protocols can be provided.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">next_protos_advertised_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="kt">unsigned</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">next_protos_advertised_cb_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// For a client, this contains a callback function that selects the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// next protocol from the list provided by the server.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">next_proto_select_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">in_len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">next_proto_select_cb_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ALPN information
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// (we are in the process of transitioning from NPN to ALPN.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// For a server, this contains a callback function that allows the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// server to select the protocol for the connection.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   out: on successful return, this must point to the raw protocol
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//        name (without the length prefix).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   outlen: on successful return, this contains the length of |*out|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   in: points to the client&#39;s list of supported protocols in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//       wire-format.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   inlen: the length of |in|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">alpn_select_cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">in_len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">alpn_select_cb_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// For a client, this contains the list of supported protocols in wire
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// format.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">alpn_client_proto_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// SRTP profiles we are willing to do from RFC 5764
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">STACK_OF</span><span class="p">(</span><span class="n">SRTP_PROTECTION_PROFILE</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">srtp_profiles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Defined compression algorithms for certificates.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">GrowableArray</span><span class="o">&lt;</span><span class="n">bssl</span><span class="o">::</span><span class="n">CertCompressionAlg</span><span class="o">&gt;</span> <span class="n">cert_compression_algs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Supported group values inherited by SSL structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">supported_group_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// The client&#39;s Channel ID private key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">EVP_PKEY</span><span class="o">&gt;</span> <span class="n">channel_id_private</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_server_config_list contains the server&#39;s list of ECHConfig values and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// associated private keys. This list may be swapped out at any time, so all
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// access must be synchronized through |lock|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_ECH_SERVER_CONFIG_LIST</span><span class="o">&gt;</span> <span class="n">ech_server_config_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// keylog_callback, if not NULL, is the key logging callback. See
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_CTX_set_keylog_callback|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keylog_callback</span><span class="p">)(</span><span class="k">const</span> <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// current_time_cb, if not NULL, is the function to use to get the current
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// time. It sets |*out_clock| to the current time. The |ssl| argument is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// always NULL. See |SSL_CTX_set_current_time_cb|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">current_time_cb</span><span class="p">)(</span><span class="k">const</span> <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">timeval</span> <span class="o">*</span><span class="n">out_clock</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// pool is used for all |CRYPTO_BUFFER|s in case we wish to share certificate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">CRYPTO_BUFFER_POOL</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ticket_aead_method contains function pointers for opening and sealing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// session tickets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">SSL_TICKET_AEAD_METHOD</span> <span class="o">*</span><span class="n">ticket_aead_method</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// legacy_ocsp_callback implements an OCSP-related callback for OpenSSL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// compatibility.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">legacy_ocsp_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">legacy_ocsp_callback_arg</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// verify_sigalgs, if not empty, is the set of signature algorithms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// accepted from the peer in decreasing order of preference.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">verify_sigalgs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// retain_only_sha256_of_client_certs is true if we should compute the SHA256
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// hash of the peer&#39;s certificate and then discard it to save memory and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// session space. Only effective on the server side.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">retain_only_sha256_of_client_certs</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// quiet_shutdown is true if the connection should not send a close_notify on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// shutdown.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">quiet_shutdown</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ocsp_stapling_enabled is only used by client connections and indicates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// whether OCSP stapling will be requested.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ocsp_stapling_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If true, a client will request certificate timestamps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">signed_cert_timestamps_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// channel_id_enabled is whether Channel ID is enabled. For a server, means
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that we&#39;ll accept Channel IDs from clients.  For a client, means that we&#39;ll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// advertise support.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">channel_id_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// grease_enabled is whether draft-davidben-tls-grease-01 is enabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">grease_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// allow_unknown_alpn_protos is whether the client allows unsolicited ALPN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// protocols from the peer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">allow_unknown_alpn_protos</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// false_start_allowed_without_alpn is whether False Start (if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_MODE_ENABLE_FALSE_START| is enabled) is allowed without ALPN.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">false_start_allowed_without_alpn</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// handoff indicates that a server should stop after receiving the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ClientHello and pause the handshake in such a way that |SSL_get_error|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// returns |SSL_ERROR_HANDOFF|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">handoff</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If enable_early_data is true, early data can be sent and accepted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">enable_early_data</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ssl_ctx_st</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="kt">void</span> <span class="nf">SSL_CTX_free</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h3 class="relative group">1.3 握手/加解密过程当中涉及到的数据结构 
    <div id="13-%E6%8F%A1%E6%89%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B%E5%BD%93%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#13-%E6%8F%A1%E6%89%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B%E5%BD%93%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">1.3.1 transcript hash数据结构 
    <div id="131-transcript-hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#131-transcript-hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>transcript实际上就是握手报文的完整结构，直接翻译为抄本，除了TLS1.3的HELLO RETRY REQUEST会加上一些特殊的地方，其他都是由报文拼接。可以看到，GOOGLE把所有的跟HASH相关的动作都包裹到<code>SSLTranscript</code>结构中。但是从功能的角度来看，我觉得这个就属于C++的强行面向对象了，我个人很厌烦这一点，不像C那么灵活和彻底。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// SSLTranscript maintains the handshake transcript as a combination of a
</span></span></span><span class="line"><span class="cl"><span class="c1">// buffer and running hash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SSLTranscript</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSLTranscript</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">SSLTranscript</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Init initializes the handshake transcript. If called on an existing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// transcript, it resets the transcript and hash. It returns true on success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and false on failure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">Init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// InitHash initializes the handshake hash based on the PRF and contents of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the handshake transcript. Subsequent calls to |Update| will update the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// rolling hash. It returns one on success and zero on failure. It is an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to call this function after the handshake buffer is released.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">InitHash</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">version</span><span class="p">,</span> <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">cipher</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// UpdateForHelloRetryRequest resets the rolling hash with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// HelloRetryRequest construction. It returns true on success and false on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// failure. It is an error to call this function before the handshake buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// is released.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">UpdateForHelloRetryRequest</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// CopyToHashContext initializes |ctx| with |digest| and the data thus far in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the transcript. It returns true on success and false on failure. If the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// handshake buffer is still present, |digest| may be any supported digest.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Otherwise, |digest| must match the transcript hash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">CopyToHashContext</span><span class="p">(</span><span class="n">EVP_MD_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">EVP_MD</span> <span class="o">*</span><span class="n">digest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeConstSpan</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                         <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// FreeBuffer releases the handshake buffer. Subsequent calls to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |Update| will not update the handshake buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">FreeBuffer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// DigestLen returns the length of the PRF hash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span> <span class="nf">DigestLen</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Digest returns the PRF hash. For TLS 1.1 and below, this is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |EVP_md5_sha1|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">EVP_MD</span> <span class="o">*</span><span class="nf">Digest</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Update adds |in| to the handshake buffer and handshake hash, whichever is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// enabled. It returns true on success and false on failure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">Update</span><span class="p">(</span><span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// GetHash writes the handshake hash to |out| which must have room for at
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// least |DigestLen| bytes. On success, it returns true and sets |*out_len| to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the number of bytes written. Otherwise, it returns false.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">GetHash</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// GetFinishedMAC computes the MAC for the Finished message into the bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// pointed by |out| and writes the number of bytes to |*out_len|. |out| must
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// have room for |EVP_MAX_MD_SIZE| bytes. It returns true on success and false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on failure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">GetFinishedMAC</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span> <span class="k">const</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="kt">bool</span> <span class="n">from_server</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// buffer_, if non-null, contains the handshake transcript.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">BUF_MEM</span><span class="o">&gt;</span> <span class="n">buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// hash, if initialized with an |EVP_MD|, maintains the handshake hash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ScopedEVP_MD_CTX</span> <span class="n">hash_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h4 class="relative group">1.3.2 AEAD context 
    <div id="132-aead-context" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#132-aead-context" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>严格来说TLS1.2就有AEAD，不过在TLS1.3中正式大规模使用，具体的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SSLAEADContext</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSLAEADContext</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">version</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_dtls</span><span class="p">,</span> <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">cipher</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">SSLAEADContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">kAllowUniquePtr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SSLAEADContext</span><span class="p">(</span><span class="k">const</span> <span class="n">SSLAEADContext</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSLAEADContext</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SSLAEADContext</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// CreateNullCipher creates an |SSLAEADContext| for the null cipher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLAEADContext</span><span class="o">&gt;</span> <span class="n">CreateNullCipher</span><span class="p">(</span><span class="kt">bool</span> <span class="n">is_dtls</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Create creates an |SSLAEADContext| using the supplied key material. It
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// returns nullptr on error. Only one of |Open| or |Seal| may be used with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// resulting object, depending on |direction|. |version| is the normalized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// protocol version, so DTLS 1.0 is represented as 0x0301, not 0xffef.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLAEADContext</span><span class="o">&gt;</span> <span class="n">Create</span><span class="p">(</span><span class="k">enum</span> <span class="nc">evp_aead_direction_t</span> <span class="n">direction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="kt">uint16_t</span> <span class="n">version</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_dtls</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">cipher</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">enc_key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">mac_key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">fixed_iv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// CreatePlaceholderForQUIC creates a placeholder |SSLAEADContext| for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// given cipher and version. The resulting object can be queried for various
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// properties but cannot encrypt or decrypt data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLAEADContext</span><span class="o">&gt;</span> <span class="n">CreatePlaceholderForQUIC</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">version</span><span class="p">,</span> <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">cipher</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// SetVersionIfNullCipher sets the version the SSLAEADContext for the null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// cipher, to make version-specific determinations in the record layer prior
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to a cipher being selected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetVersionIfNullCipher</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">version</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ProtocolVersion returns the protocol version associated with this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSLAEADContext. It can only be called once |version_| has been set to a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// valid value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="nf">ProtocolVersion</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// RecordVersion returns the record version that should be used with this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SSLAEADContext for record construction and crypto.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="nf">RecordVersion</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="nf">cipher</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cipher_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// is_null_cipher returns true if this is the null cipher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">is_null_cipher</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">cipher_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ExplicitNonceLen returns the length of the explicit nonce.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span> <span class="nf">ExplicitNonceLen</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// MaxOverhead returns the maximum overhead of calling |Seal|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span> <span class="nf">MaxOverhead</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// SuffixLen calculates the suffix length written by |SealScatter| and writes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// it to |*out_suffix_len|. It returns true on success and false on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |in_len| and |extra_in_len| should equal the argument of the same names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// passed to |SealScatter|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">SuffixLen</span><span class="p">(</span><span class="n">size_t</span> <span class="o">*</span><span class="n">out_suffix_len</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">in_len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">size_t</span> <span class="n">extra_in_len</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// CiphertextLen calculates the total ciphertext length written by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SealScatter| and writes it to |*out_len|. It returns true on success and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// false on error. |in_len| and |extra_in_len| should equal the argument of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the same names passed to |SealScatter|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">CiphertextLen</span><span class="p">(</span><span class="n">size_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">in_len</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">extra_in_len</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Open authenticates and decrypts |in| in-place. On success, it sets |*out|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to the plaintext in |in| and returns true.  Otherwise, it returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// false. The output will always be |ExplicitNonceLen| bytes ahead of |in|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">Open</span><span class="p">(</span><span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">record_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">seqnum</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">header</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">Span</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Seal encrypts and authenticates |in_len| bytes from |in| and writes the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// result to |out|. It returns true on success and false on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If |in| and |out| alias then |out| + |ExplicitNonceLen| must be == |in|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">Seal</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">max_out</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">uint16_t</span> <span class="n">record_version</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">seqnum</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">header</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">in_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// SealScatter encrypts and authenticates |in_len| bytes from |in| and splits
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the result between |out_prefix|, |out| and |out_suffix|. It returns one on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// success and zero on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On successful return, exactly |ExplicitNonceLen| bytes are written to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |out_prefix|, |in_len| bytes to |out|, and |SuffixLen| bytes to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |out_suffix|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |extra_in| may point to an additional plaintext buffer. If present,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |extra_in_len| additional bytes are encrypted and authenticated, and the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ciphertext is written to the beginning of |out_suffix|. |SuffixLen| should
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// be used to size |out_suffix| accordingly.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If |in| and |out| alias then |out| must be == |in|. Other arguments may not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// alias anything.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">SealScatter</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_prefix</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_suffix</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">record_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">seqnum</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">header</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">in_len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">extra_in</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">size_t</span> <span class="n">extra_in_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">GetIV</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out_iv</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">out_iv_len</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// GetAdditionalData returns the additional data, writing into |storage| if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">GetAdditionalData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">storage</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="kt">uint16_t</span> <span class="n">record_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">seqnum</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">size_t</span> <span class="n">plaintext_len</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">cipher_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ScopedEVP_AEAD_CTX</span> <span class="n">ctx_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// fixed_nonce_ contains any bytes of the nonce that are fixed for all
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// records.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">fixed_nonce_</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">fixed_nonce_len_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">variable_nonce_len_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// version_ is the wire version that should be used with this AEAD.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">version_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// is_dtls_ is whether DTLS is being used with this AEAD.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">is_dtls_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// variable_nonce_included_in_record_ is true if the variable nonce
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for a record is included as a prefix before the ciphertext.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">variable_nonce_included_in_record_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// random_variable_nonce_ is true if the variable nonce is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// randomly generated, rather than derived from the sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">random_variable_nonce_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// xor_fixed_nonce_ is true if the fixed nonce should be XOR&#39;d into the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// variable nonce rather than prepended.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">xor_fixed_nonce_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// omit_length_in_ad_ is true if the length should be omitted in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// AEAD&#39;s ad parameter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">omit_length_in_ad_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ad_is_header_ is true if the AEAD&#39;s ad parameter is the record header.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ad_is_header_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h4 class="relative group">1.3.3 Key Share结构 
    <div id="133-key-share%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#133-key-share%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SSLKeyShare</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="o">~</span><span class="n">SSLKeyShare</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">kAllowUniquePtr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">HAS_VIRTUAL_DESTRUCTOR</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Create returns a SSLKeyShare instance for use with group |group_id| or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// nullptr on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLKeyShare</span><span class="o">&gt;</span> <span class="n">Create</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">group_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Create deserializes an SSLKeyShare instance previously serialized by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |Serialize|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLKeyShare</span><span class="o">&gt;</span> <span class="n">Create</span><span class="p">(</span><span class="n">CBS</span> <span class="o">*</span><span class="n">in</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Serializes writes the group ID and private key, in a format that can be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// read by |Create|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">Serialize</span><span class="p">(</span><span class="n">CBB</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// GroupID returns the group ID.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">uint16_t</span> <span class="nf">GroupID</span><span class="p">()</span> <span class="k">const</span> <span class="n">PURE_VIRTUAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Offer generates a keypair and writes the public value to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |out_public_key|. It returns true on success and false on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Offer</span><span class="p">(</span><span class="n">CBB</span> <span class="o">*</span><span class="n">out_public_key</span><span class="p">)</span> <span class="n">PURE_VIRTUAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Accept performs a key exchange against the |peer_key| generated by |Offer|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On success, it returns true, writes the public value to |out_public_key|,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and sets |*out_secret| to the shared secret. On failure, it returns false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and sets |*out_alert| to an alert to send to the peer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// The default implementation calls |Offer| and then |Finish|, assuming a key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// exchange protocol where the peers are symmetric.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">CBB</span> <span class="o">*</span><span class="n">out_public_key</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">out_secret</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_alert</span><span class="p">,</span> <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">peer_key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Finish performs a key exchange against the |peer_key| generated by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |Accept|. On success, it returns true and sets |*out_secret| to the shared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// secret. On failure, it returns false and sets |*out_alert| to an alert to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// send to the peer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Finish</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">out_secret</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_alert</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">peer_key</span><span class="p">)</span> <span class="n">PURE_VIRTUAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// SerializePrivateKey writes the private key to |out|, returning true if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// successful and false otherwise. It should be called after |Offer|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">SerializePrivateKey</span><span class="p">(</span><span class="n">CBB</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// DeserializePrivateKey initializes the state of the key exchange from |in|,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// returning true if successful and false otherwise.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">DeserializePrivateKey</span><span class="p">(</span><span class="n">CBS</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h4 class="relative group">1.3.4 ECH 拓展 
    <div id="134-ech-%E6%8B%93%E5%B1%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#134-ech-%E6%8B%93%E5%B1%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>没想到BoringSSL已经支持ECH了，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ECHServerConfig</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ECHServerConfig</span><span class="p">()</span> <span class="o">:</span> <span class="n">is_retry_config_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">initialized_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="n">ECHServerConfig</span><span class="p">(</span><span class="n">ECHServerConfig</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ECHServerConfig</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ECHServerConfig</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ECHServerConfig</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Init parses |ech_config| as an ECHConfig and saves a copy of |private_key|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// It returns true on success and false on error. It will also error if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |private_key| is not a valid X25519 private key or it does not correspond
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to the parsed public key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">Init</span><span class="p">(</span><span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ech_config</span><span class="p">,</span> <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">private_key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">bool</span> <span class="n">is_retry_config</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// SupportsCipherSuite returns true when this ECHConfig supports the HPKE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ciphersuite composed of |kdf_id| and |aead_id|. This function must only be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// called on an initialized object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">SupportsCipherSuite</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">kdf_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">aead_id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">raw</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">initialized_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">raw_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">public_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">initialized_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">public_key_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">private_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">initialized_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeConstSpan</span><span class="p">(</span><span class="n">private_key_</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">private_key_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">config_id_sha256</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">initialized_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">MakeConstSpan</span><span class="p">(</span><span class="n">config_id_sha256_</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config_id_sha256_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">is_retry_config</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">initialized_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">is_retry_config_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">raw_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">public_key_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">cipher_suites_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// private_key_ is the key corresponding to |public_key|. For clients, it must
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// be empty (|private_key_present_ == false|). For servers, it must be a valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// X25519 private key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">private_key_</span><span class="p">[</span><span class="n">X25519_PRIVATE_KEY_LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// config_id_ stores the precomputed result of |ConfigID| for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |EVP_HPKE_HKDF_SHA256|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">config_id_sha256_</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nl">is_retry_config_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nl">initialized_</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h4 class="relative group">1.3.5 SSL_CONFIG结构 
    <div id="135-ssl_config%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#135-ssl_config%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>SSL_CONFIG用于存储一些握手完成之后需要的数据结构，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SSL_CONFIG</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">kAllowUniquePtr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">SSL_CONFIG</span><span class="p">(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl_arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">SSL_CONFIG</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ssl is a non-owning pointer to the parent |SSL| object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SSL</span> <span class="o">*</span><span class="k">const</span> <span class="n">ssl</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// conf_max_version is the maximum acceptable version configured by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_set_max_proto_version|. Note this version is not normalized in DTLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and is further constrained by |SSL_OP_NO_*|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">conf_max_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// conf_min_version is the minimum acceptable version configured by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |SSL_set_min_proto_version|. Note this version is not normalized in DTLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and is further constrained by |SSL_OP_NO_*|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">conf_min_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">X509_VERIFY_PARAM</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// crypto
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSLCipherPreferenceList</span><span class="o">&gt;</span> <span class="n">cipher_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// This is used to hold the local certificate used (i.e. the server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// certificate for a server or the client certificate for a client).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">CERT</span><span class="o">&gt;</span> <span class="n">cert</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">verify_callback</span><span class="p">)(</span><span class="kt">int</span> <span class="n">ok</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="n">X509_STORE_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// fail if callback returns 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="nf">ssl_verify_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">custom_verify_callback</span><span class="p">)(</span>
</span></span><span class="line"><span class="cl">      <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_alert</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Server-only: psk_identity_hint is the identity hint to send in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// PSK-based key exchanges.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">psk_identity_hint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="p">(</span><span class="o">*</span><span class="n">psk_client_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hint</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">unsigned</span> <span class="n">max_identity_len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">psk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">unsigned</span> <span class="n">max_psk_len</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="p">(</span><span class="o">*</span><span class="n">psk_server_callback</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">psk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="kt">unsigned</span> <span class="n">max_psk_len</span><span class="p">)</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// for server side, keep the list of CA_dn we can use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">STACK_OF</span><span class="p">(</span><span class="n">CRYPTO_BUFFER</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">client_CA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cached_x509_client_CA is a cache of parsed versions of the elements of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |client_CA|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509_NAME</span><span class="p">)</span> <span class="o">*</span><span class="n">cached_x509_client_CA</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">supported_group_list</span><span class="p">;</span>  <span class="c1">// our list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// The client&#39;s Channel ID private key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">EVP_PKEY</span><span class="o">&gt;</span> <span class="n">channel_id_private</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// For a client, this contains the list of supported protocols in wire
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// format.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">alpn_client_proto_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// alps_configs contains the list of supported protocols to use with ALPS,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// along with their corresponding ALPS values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">GrowableArray</span><span class="o">&lt;</span><span class="n">ALPSConfig</span><span class="o">&gt;</span> <span class="n">alps_configs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Contains a list of supported Token Binding key parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">token_binding_params</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Contains the QUIC transport params that this endpoint will send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">quic_transport_params</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Contains the context used to decide whether to accept early data in QUIC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">quic_early_data_context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// verify_sigalgs, if not empty, is the set of signature algorithms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// accepted from the peer in decreasing order of preference.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">verify_sigalgs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// srtp_profiles is the list of configured SRTP protection profiles for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// DTLS-SRTP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">STACK_OF</span><span class="p">(</span><span class="n">SRTP_PROTECTION_PROFILE</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">srtp_profiles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// verify_mode is a bitmask of |SSL_VERIFY_*| values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">verify_mode</span> <span class="o">=</span> <span class="n">SSL_VERIFY_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ech_grease_enabled controls whether ECH GREASE may be sent in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ClientHello.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ech_grease_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Enable signed certificate time stamps. Currently client only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">signed_cert_timestamps_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ocsp_stapling_enabled is only used by client connections and indicates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// whether OCSP stapling will be requested.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ocsp_stapling_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// channel_id_enabled is copied from the |SSL_CTX|. For a server, means that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// we&#39;ll accept Channel IDs from clients. For a client, means that we&#39;ll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// advertise support.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">channel_id_enabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If enforce_rsa_key_usage is true, the handshake will fail if the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// keyUsage extension is present and incompatible with the TLS usage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This field is not read until after certificate verification.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">enforce_rsa_key_usage</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// retain_only_sha256_of_client_certs is true if we should compute the SHA256
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// hash of the peer&#39;s certificate and then discard it to save memory and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// session space. Only effective on the server side.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">retain_only_sha256_of_client_certs</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// handoff indicates that a server should stop after receiving the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ClientHello and pause the handshake in such a way that |SSL_get_error|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// returns |SSL_ERROR_HANDOFF|. This is copied in |SSL_new| from the |SSL_CTX|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// element of the same name and may be cleared if the handoff is declined.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">handoff</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// shed_handshake_config indicates that the handshake config (this object!)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// should be freed after the handshake completes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">shed_handshake_config</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// jdk11_workaround is whether to disable TLS 1.3 for JDK 11 clients, as a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// workaround for https://bugs.openjdk.java.net/browse/JDK-8211806.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">jdk11_workaround</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// QUIC drafts up to and including 32 used a different TLS extension
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// codepoint to convey QUIC&#39;s transport parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">quic_use_legacy_codepoint</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

<h2 class="relative group">2 握手函数 
    <div id="2-%E6%8F%A1%E6%89%8B%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2-%E6%8F%A1%E6%89%8B%E5%87%BD%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">2.1 握手相关函数 
    <div id="21-%E6%8F%A1%E6%89%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#21-%E6%8F%A1%E6%89%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>函数<code>SSL_do_handshake</code>负责继续当前连接的握手状态，有个很有趣的地方实际上要注意，需要先绑定<code>fd</code>或<code>bio</code>才能继续让<code>SSL_do_handshake</code>继续。很类似的<code>SSL__connect</code>和<code>SSL_accept</code>分别用来给client和server端使用，<code>SSL_read</code>函数和openssl代码里还是一致的，返回读取到的明文。和<code>SSL_read</code>类似的函数<code>SSL_peak</code>用来获得明文，但是不会真正的读取报文。这东西也就特定情况下需要。</p>
<p>诸如<code>KEY_UPDATE_UPDATE_REQUESTED</code>和<code>KEY_UPDATE_UPDATE_NOT_REQUESTED</code>倒是和我写的代码完全一致。</p>
<p><code>SSL_get_error</code>函数很有趣，最近的操作失败时，使用这个函数获取失败原因，统一的处理</p>


<h2 class="relative group">3 基本的属性和值 
    <div id="3-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%80%BC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%80%BC" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">3.1 protocol version和函数 
    <div id="31-protocol-version%E5%92%8C%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#31-protocol-version%E5%92%8C%E5%87%BD%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>和openssl一样，还是两个函数。但是有单独的函数去设定对应的SSL版本号。最后的函数负责获得握手时确定的版本号</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define DTLS1_VERSION_MAJOR 0xfe
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL3_VERSION_MAJOR 0x03
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SSL3_VERSION 0x0300
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TLS1_VERSION 0x0301
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TLS1_1_VERSION 0x0302
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TLS1_2_VERSION 0x0303
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TLS1_3_VERSION 0x0304
</span></span></span><span class="line"><span class="cl"><span class="cp">#define DTLS1_VERSION 0xfeff
</span></span></span><span class="line"><span class="cl"><span class="cp">#define DTLS1_2_VERSION 0xfefd
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_CTX_set_min_proto_version</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">version</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_CTX_set_max_proto_version</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">version</span><span class="p">);</span>                           <span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_version</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">);</span>                      
</span></span></code></pre></div>

<h3 class="relative group">3.2 CTX的属性和函数 
    <div id="32-ctx%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#32-ctx%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%87%BD%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>属性这一块坦白讲我觉得没啥意思，</p>
<pre tabindex="0"><code>SSL_MODE_ENABLE_PARTIAL_WRITE //允许往一个record里面写部分的报文
</code></pre>

<h3 class="relative group">3.3 证书和私钥相关函数 
    <div id="33-%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A7%81%E9%92%A5%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#33-%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A7%81%E9%92%A5%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_CTX_use_certificate</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">X509</span> <span class="o">*</span><span class="n">x509</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_use_certificate</span><span class="p">(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="n">X509</span> <span class="o">*</span><span class="n">x509</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_CTX_set0_chain</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509</span><span class="p">)</span> <span class="o">*</span><span class="n">chain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_CTX_set1_chain</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509</span><span class="p">)</span> <span class="o">*</span><span class="n">chain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">void</span> <span class="nf">SSL_CTX_set_cert_cb</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                        <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>  <span class="c1">//这个函数就很有趣了，设置回调来选择具体的证书
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OPENSSL_EXPORT</span> <span class="n">size_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">SSL_get0_peer_verify_algorithms</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">**</span><span class="n">out_sigalgs</span><span class="p">);</span><span class="c1">//这个函数就负责选择对端识别的sig算法，从而能够影响本端证书的选择
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_CTX_check_private_key</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//检测私钥证书是否匹配
</span></span></span></code></pre></div>

<h2 class="relative group">4 复用相关数据结构 
    <div id="4-%E5%A4%8D%E7%94%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4-%E5%A4%8D%E7%94%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>复用最基础的数据结构就三个，这三个就是我们主要的研究对象。</p>


<h3 class="relative group">4.1 SESSION 
    <div id="41-session" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#41-session" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p><code>SESSION</code>基本的数据结构，但是是关联SESSION ID还是SESSION CACHE是需要看SESSION里面的数据结构。实际上这意味着我们可以自由自在地往里面存储数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="nf">SSL_SESSION_new</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_SESSION_up_ref</span><span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">OPENSSL_EXPORT</span> <span class="kt">void</span> <span class="nf">SSL_SESSION_free</span><span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span> <span class="c1">//减少引用计数，引用计数为0就触发free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OPENSSL_EXPORT</span> <span class="kt">uint64_t</span> <span class="nf">SSL_SESSION_get_time</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span><span class="c1">//获取SESSION的颁发时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OPENSSL_EXPORT</span> <span class="n">size_t</span> <span class="nf">SSL_SESSION_get_master_key</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                 <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">max_out</span><span class="p">);</span><span class="c1">//获取具体的衍生秘钥
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OPENSSL_EXPORT</span> <span class="kt">int</span> <span class="nf">SSL_SESSION_should_be_single_use</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span><span class="c1">//这个就很牛逼了，只能使用一次的SESSION
</span></span></span></code></pre></div>

<h3 class="relative group">4.2 SESSION CACHE 
    <div id="42-session-cache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#42-session-cache" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>和<code>SESSION</code>有什么区别？这个问题自然而然出现了，看注释应该是一样的，都是<code>SSL_session</code>结构。boringg ssl自己内置了一种SESSION CACHE的代码实现，使用的数据结构是内置的hashTable，原文引用于下</p>
<blockquote>
<p>For a server, the library implements a built-in internal session cache as an in-memory hash table. Servers may also use <code>SSL_CTX_sess_set_get_cb</code> and <code>SSL_CTX_sess_set_new_cb</code> to implement a custom external session cache. In particular, this may be used to share a session cache between multiple servers in a large deployment. An external cache may be used in addition to or instead of the internal one. Use <code>SSL_CTX_set_session_cache_mode</code> to toggle the internal cache.</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define SSL_SESS_CACHE_OFF 0x0000  </span><span class="c1">//用来关停SESSION CACHE功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">ssl_session_st</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">ssl_session_st</span><span class="p">(</span><span class="k">const</span> <span class="n">bssl</span><span class="o">::</span><span class="n">SSL_X509_METHOD</span> <span class="o">*</span><span class="n">method</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_session_st</span><span class="p">(</span><span class="k">const</span> <span class="n">ssl_session_st</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssl_session_st</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ssl_session_st</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CRYPTO_refcount_t</span> <span class="n">references</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ssl_version is the (D)TLS version that established the session.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">ssl_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// group_id is the ID of the ECDH group used to establish this session or zero
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// if not applicable or unknown.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">group_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_signature_algorithm is the signature algorithm used to authenticate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the peer, or zero if not applicable or unknown.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">peer_signature_algorithm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// secret, in TLS 1.2 and below, is the master secret associated with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// session. In TLS 1.3 and up, it is the resumption PSK for sessions handed to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the caller, but it stores the resumption secret when stored on |SSL|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">secret_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">secret</span><span class="p">[</span><span class="n">SSL_MAX_MASTER_KEY_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// session_id - valid?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="n">session_id_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">session_id</span><span class="p">[</span><span class="n">SSL_MAX_SSL_SESSION_ID_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// this is used to determine whether the session is being reused in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the appropriate context. It is up to the application to set this,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// via SSL_new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">sid_ctx_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">sid_ctx</span><span class="p">[</span><span class="n">SSL_MAX_SID_CTX_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">psk_identity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// certs contains the certificate chain from the peer, starting with the leaf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// certificate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">STACK_OF</span><span class="p">(</span><span class="n">CRYPTO_BUFFER</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">certs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">bssl</span><span class="o">::</span><span class="n">SSL_X509_METHOD</span> <span class="o">*</span><span class="n">x509_method</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// x509_peer is the peer&#39;s certificate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">X509</span> <span class="o">*</span><span class="n">x509_peer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// x509_chain is the certificate chain sent by the peer. NOTE: for historical
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reasons, when a client (so the peer is a server), the chain includes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |peer|, but when a server it does not.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509</span><span class="p">)</span> <span class="o">*</span><span class="n">x509_chain</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// x509_chain_without_leaf is a lazily constructed copy of |x509_chain| that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// omits the leaf certificate. This exists because OpenSSL, historically,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// didn&#39;t include the leaf certificate in the chain for a server, but did for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a client. The |x509_chain| always includes it and, if an API call requires
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a chain without, it is stored here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">STACK_OF</span><span class="p">(</span><span class="n">X509</span><span class="p">)</span> <span class="o">*</span><span class="n">x509_chain_without_leaf</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// verify_result is the result of certificate verification in the case of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// non-fatal certificate errors.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">long</span> <span class="n">verify_result</span> <span class="o">=</span> <span class="n">X509_V_ERR_INVALID_CALL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// timeout is the lifetime of the session in seconds, measured from |time|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is renewable up to |auth_timeout|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">SSL_DEFAULT_SESSION_TIMEOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// auth_timeout is the non-renewable lifetime of the session in seconds,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// measured from |time|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">auth_timeout</span> <span class="o">=</span> <span class="n">SSL_DEFAULT_SESSION_TIMEOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// time is the time the session was issued, measured in seconds from the UNIX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// epoch.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint64_t</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">SSL_CIPHER</span> <span class="o">*</span><span class="n">cipher</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CRYPTO_EX_DATA</span> <span class="n">ex_data</span><span class="p">;</span>  <span class="c1">// application specific data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// These are used to make removal of session-ids more efficient and to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// implement a maximum cache size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ticket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">CRYPTO_BUFFER</span><span class="o">&gt;</span> <span class="n">signed_cert_timestamp_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// The OCSP response that came with the session.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">CRYPTO_BUFFER</span><span class="o">&gt;</span> <span class="n">ocsp_response</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_sha256 contains the SHA-256 hash of the peer&#39;s certificate if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |peer_sha256_valid| is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">peer_sha256</span><span class="p">[</span><span class="n">SHA256_DIGEST_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// original_handshake_hash contains the handshake hash (either SHA-1+MD5 or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// SHA-2, depending on TLS version) for the original, full handshake that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// created a session. This is used by Channel IDs during resumption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">original_handshake_hash</span><span class="p">[</span><span class="n">EVP_MAX_MD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">original_handshake_hash_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">ticket_lifetime_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Session lifetime hint in seconds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">ticket_age_add</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ticket_max_early_data is the maximum amount of data allowed to be sent as
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// early data. If zero, 0-RTT is disallowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">ticket_max_early_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// early_alpn is the ALPN protocol from the initial handshake. This is only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// stored for TLS 1.3 and above in order to enforce ALPN matching for 0-RTT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// resumptions. For the current connection&#39;s ALPN protocol, see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |alpn_selected| on |SSL3_STATE|.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">early_alpn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// local_application_settings, if |has_application_settings| is true, is the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// local ALPS value for this connection.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">local_application_settings</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_application_settings, if |has_application_settings| is true, is the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// peer ALPS value for this connection.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">peer_application_settings</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// extended_master_secret is whether the master secret in this session was
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// generated using EMS and thus isn&#39;t vulnerable to the Triple Handshake
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// attack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">extended_master_secret</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// peer_sha256_valid is whether |peer_sha256| is valid.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">peer_sha256_valid</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Non-zero if peer_sha256 is valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// not_resumable is used to indicate that session resumption is disallowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">not_resumable</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ticket_age_add_valid is whether |ticket_age_add| is valid.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">ticket_age_add_valid</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// is_server is whether this session was created by a server.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">is_server</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// is_quic indicates whether this session was created using QUIC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">is_quic</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// has_application_settings indicates whether ALPS was negotiated in this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// session.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nl">has_application_settings</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// quic_early_data_context is used to determine whether early data must be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// rejected when performing a QUIC handshake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bssl</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">quic_early_data_context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ssl_session_st</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="kt">void</span> <span class="nf">SSL_SESSION_free</span><span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>数据结构看完了，看看<code>SESSION CACHE</code>的管理是怎么做的，几个关键函数如下，其中：</p>
<ul>
<li>
<p>从<code>session_id</code>拓展到<code>hash</code>实际上使用了<code>session_id</code>的前四字节</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">uint32_t</span> <span class="nf">ssl_hash_session_id</span><span class="p">(</span><span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">session_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Take the first four bytes of |session_id|. Session IDs are generated by the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// server randomly, so we can assume even using the first four bytes results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// in a good distribution.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">tmp_storage</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">session_id</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp_storage</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OPENSSL_memset</span><span class="p">(</span><span class="n">tmp_storage</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp_storage</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">OPENSSL_memcpy</span><span class="p">(</span><span class="n">tmp_storage</span><span class="p">,</span> <span class="n">session_id</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">session_id</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">session_id</span> <span class="o">=</span> <span class="n">tmp_storage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">session_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">      <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">session_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">      <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">session_id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">      <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">session_id</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>有了<code>hash+session_id+session_ctx-&gt;sessions</code>最后实际上是个比较函数，BORING SSL最后使用的比较函数是个宏，展开来这个宏如下。所以我们得看看LHASH到底是个什么数据结构，因为<code>ssl-&gt;session_ctx-&gt;sessions</code>的数据结构是<code>LHASH_OF(SSL_SESSION) *sessions = nullptr;</code>。这个东西在OPENSSL里面也有，说白了就是hash表，但是一个大锁对应一个HASH表可太狠了，所以我们得看看<code>ssl_lookup_session</code>的时候发生了什么</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// ssl_lookup_session looks up |session_id| in the session cache and sets
</span></span></span><span class="line"><span class="cl"><span class="c1">// |*out_session| to an |SSL_SESSION| object if found.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="k">enum</span> <span class="nc">ssl_hs_wait_t</span> <span class="nf">ssl_lookup_session</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">SSL_HANDSHAKE</span> <span class="o">*</span><span class="n">hs</span><span class="p">,</span> <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_SESSION</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">out_session</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">session_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSL</span> <span class="o">*</span><span class="k">const</span> <span class="n">ssl</span> <span class="o">=</span> <span class="n">hs</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">out_session</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">session_id</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">session_id</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">SSL_MAX_SSL_SESSION_ID_LENGTH</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ssl_hs_ok</span><span class="p">;</span><span class="c1">//session id不合法，不是合理的session id就直接放弃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_SESSION</span><span class="o">&gt;</span> <span class="n">session</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Try the internal cache, if it exists.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="o">-&gt;</span><span class="n">session_cache_mode</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">SSL_SESS_CACHE_NO_INTERNAL_LOOKUP</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">ssl_hash_session_id</span><span class="p">(</span><span class="n">session_id</span><span class="p">);</span><span class="c1">//先通过session_id计算出来hash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">cmp</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">sess</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">key_id</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">Span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">sess_id</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">MakeConstSpan</span><span class="p">(</span><span class="n">sess</span><span class="o">-&gt;</span><span class="n">session_id</span><span class="p">,</span> <span class="n">sess</span><span class="o">-&gt;</span><span class="n">session_id_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">key_id</span> <span class="o">==</span> <span class="n">sess_id</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexReadLock</span> <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">//读锁开始锁SSL连接相关的session-ctx的锁了，然后升高ssl-&gt;session-ctx-&gt;session的reference count。但是这个锁太大了！去找一下这个锁的初始化的位置，这个锁太狠了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// |lh_SSL_SESSION_retrieve_key| returns a non-owning pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">session</span> <span class="o">=</span> <span class="n">UpRef</span><span class="p">(</span><span class="n">lh_SSL_SESSION_retrieve_key</span><span class="p">(</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="o">-&gt;</span><span class="n">sessions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                <span class="o">&amp;</span><span class="n">session_id</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">cmp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO(davidben): This should probably move it to the front of the list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Fall back to the external cache, if it exists.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span> <span class="o">&amp;&amp;</span> <span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="o">-&gt;</span><span class="n">get_session_cb</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">copy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">session</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="o">-&gt;</span><span class="n">get_session_cb</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">session_id</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                                   <span class="n">session_id</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">copy</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">ssl_hs_ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">SSL_magic_pending_session_ptr</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">session</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>  <span class="c1">// This pointer is not actually owned.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">ssl_hs_pending_session</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Increment reference count now if the session callback asks us to do so
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (note that if the session structures returned by the callback are shared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// between threads, it must handle the reference count itself [i.e. copy ==
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0], or things won&#39;t be thread-safe).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">SSL_SESSION_up_ref</span><span class="p">(</span><span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Add the externally cached session to the internal cache if necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="o">-&gt;</span><span class="n">session_cache_mode</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="n">SSL_SESS_CACHE_NO_INTERNAL_STORE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">SSL_CTX_add_session</span><span class="p">(</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">session</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ssl_session_is_time_valid</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The session was from the cache, so remove it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SSL_CTX_remove_session</span><span class="p">(</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">session_ctx</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">session</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">out_session</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ssl_hs_ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>上面看完了<code>LOOKUP</code>我们看看new SESSION的时候，也就是添加SESSION的时候发生了什么？一个ssl的session最多存储多少个？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">SSL_CTX_add_session</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Although |session| is inserted into two structures (a doubly-linked list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and the hash table), |ctx| only takes one reference.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_SESSION</span><span class="o">&gt;</span> <span class="n">owned_session</span> <span class="o">=</span> <span class="n">UpRef</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">old_session</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">MutexWriteLock</span> <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//还是一把大写锁啊，蛋疼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lh_SSL_SESSION_insert</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sessions</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_session</span><span class="p">,</span> <span class="n">session</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// |ctx-&gt;sessions| took ownership of |session| and gave us back a reference to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// |old_session|. (|old_session| may be the same as |session|, in which case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// we traded identical references with |ctx-&gt;sessions|.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">owned_session</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">owned_session</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">old_session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">old_session</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">old_session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// |session| was already in the cache. There are no linked list pointers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// to update.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// There was a session ID collision. |old_session| was replaced with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// |session| in the hash table, so |old_session| must be removed from the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// linked list to match.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SSL_SESSION_list_remove</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">old_session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SSL_SESSION_list_add</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Enforce any cache size limits.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">SSL_CTX_sess_get_cache_size</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">lh_SSL_SESSION_num_items</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sessions</span><span class="p">)</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">           <span class="n">SSL_CTX_sess_get_cache_size</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remove_session_lock</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_tail</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>上面看完了<code>NEW</code>我们看看删除SESSION的时候发生了什么</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_session_lock</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">session</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">session_id_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">CRYPTO_MUTEX_lock_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>       <span class="c1">//先加锁，先把锁给锁上避免争用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">found_session</span> <span class="o">=</span> <span class="n">lh_SSL_SESSION_retrieve</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sessions</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>  <span class="c1">//好了，获取对应的SESSION看是不是还存在，不存在就说明已经被其他的线程给删除了，那我们就没啥事情了，但是需要释放锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">found_session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">found_session</span> <span class="o">=</span> <span class="n">lh_SSL_SESSION_delete</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sessions</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span><span class="c1">//从OPENSSL的hash表里面删除掉这个session
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">SSL_SESSION_list_remove</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span><span class="c1">//hash表删除掉可没玩，还需要从链表上把session删除掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">CRYPTO_MUTEX_unlock_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//ret为1，说明是当前线程执行的删除操作，因此需要释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">remove_session_cb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">remove_session_cb</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">found_session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">SSL_SESSION_free</span><span class="p">(</span><span class="n">found_session</span><span class="p">);</span><span class="c1">//释放掉内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">SSL_SESSION_list_remove</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//一个基础的链表，直接删除就成了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_tail</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// last element in list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// only one element in list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_tail</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_tail</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// first element in list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_head</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">SSL_SESSION</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_cache_head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// middle of list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">session</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//看看这一步操作，还是把当前要去掉的session的前和后置空了，对一部分人，教科书级别的打脸啊。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<p>所以可以总结<code>session_ctx-&gt;lock</code>的管辖范围，一个大锁管了一堆，虽然有lazy delete但是，没蛋用。能够看出来，实际上BORING SSL和OPENSSL都一样，都是一把大锁加个链表存储</p>


<h3 class="relative group">4.3 SESSION TICKET 
    <div id="43-session-ticket" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#43-session-ticket" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>和SESSION CACHE不同，RFC5077里面给出了SESSION TICKET的实现。对于BORING SSL而言，SESSION TICKET也是支持的。</p>
<blockquote>
<p>On the server, tickets are encrypted and authenticated with a secret key. By default, an <code>SSL_CTX</code> will manage session ticket encryption keys by generating them internally and rotating every 48 hours. Tickets are minted and processed transparently. The following functions may be used to configure a persistent key or implement more custom behavior, including key rotation and sharing keys between multiple servers in a large deployment. There are three levels of customisation possible:</p>
<ol>
<li>One can simply set the keys with <code>SSL_CTX_set_tlsext_ticket_keys</code>. 2) One can configure an <code>EVP_CIPHER_CTX</code> and <code>HMAC_CTX</code> directly for encryption and authentication. 3) One can configure an <code>SSL_TICKET_AEAD_METHOD</code> to have more control and the option of asynchronous decryption.</li>
</ol></blockquote>
<p>相比较而言，我更喜欢<code>session ticket</code>，因为这东西完全不在本地存储软件，省大了去的事啦！而且只要逻辑确定了，避开锁争用的消耗就太棒啦！看一下具体的创建session_tickets的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">add_new_session_tickets</span><span class="p">(</span><span class="n">SSL_HANDSHAKE</span> <span class="o">*</span><span class="n">hs</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">out_sent_tickets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">SSL</span> <span class="o">*</span><span class="k">const</span> <span class="n">ssl</span> <span class="o">=</span> <span class="n">hs</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="c1">// If the client doesn&#39;t accept resumption with PSK_DHE_KE, don&#39;t send a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// session ticket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">!</span><span class="n">hs</span><span class="o">-&gt;</span><span class="n">accept_psk_mode</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// We only implement stateless resumption in TLS 1.3, so skip sending
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// tickets if disabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="n">SSL_get_options</span><span class="p">(</span><span class="n">ssl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSL_OP_NO_TICKET</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">//判断能不能颁发session，看来boring ssl在老版本根本没做这工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">out_sent_tickets</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TLS 1.3 recommends single-use tickets, so issue multiple tickets in case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the client makes several connections before getting a renewal.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kNumTickets</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">//每次颁发两个single-use ticket，来保证能够多次复用，不过我很好奇这个single-use怎么做的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Rebase the session timestamp so that it is measured from ticket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// issuance.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ssl_session_rebase_time</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">hs</span><span class="o">-&gt;</span><span class="n">new_session</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>   <span class="c1">//校定时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kNumTickets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">SSL_SESSION</span><span class="o">&gt;</span> <span class="n">session</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">SSL_SESSION_dup</span><span class="p">(</span><span class="n">hs</span><span class="o">-&gt;</span><span class="n">new_session</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">SSL_SESSION_INCLUDE_NONAUTH</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RAND_bytes</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">ticket_age_add</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">//随机生成ticket_age_add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">session</span><span class="o">-&gt;</span><span class="n">ticket_age_add_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">enable_early_data</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">ssl</span><span class="o">-&gt;</span><span class="n">enable_early_data</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">!</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">quic_method</span> <span class="o">||</span> <span class="o">!</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">quic_early_data_context</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">enable_early_data</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//校定是不是需要EARLYDATA拓展
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// QUIC does not use the max_early_data_size parameter and always sets it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// to a fixed value. See draft-ietf-quic-tls-22, section 4.5.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">session</span><span class="o">-&gt;</span><span class="n">ticket_max_early_data</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">ssl</span><span class="o">-&gt;</span><span class="n">quic_method</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="mh">0xffffffff</span> <span class="o">:</span> <span class="n">kMaxEarlyDataAccepted</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static_assert</span><span class="p">(</span><span class="n">kNumTickets</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&#34;Too many tickets&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">nonce</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ScopedCBB</span> <span class="n">cbb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CBB</span> <span class="n">body</span><span class="p">,</span> <span class="n">nonce_cbb</span><span class="p">,</span> <span class="n">ticket</span><span class="p">,</span> <span class="n">extensions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">method</span><span class="o">-&gt;</span><span class="n">init_message</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">cbb</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">SSL3_MT_NEW_SESSION_TICKET</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">ticket_age_add</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_u8_length_prefixed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nonce_cbb</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonce_cbb</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nonce</span><span class="p">))</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_u16_length_prefixed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ticket</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">tls13_derive_session_psk</span><span class="p">(</span><span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">nonce</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">ssl_encrypt_ticket</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ticket</span><span class="p">,</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_u16_length_prefixed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extensions</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">enable_early_data</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//根据是否需要加入early_data来确定是不是加拓展
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">CBB</span> <span class="n">early_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CBB_add_u16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extensions</span><span class="p">,</span> <span class="n">TLSEXT_TYPE_early_data</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="n">CBB_add_u16_length_prefixed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extensions</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">early_data</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="n">CBB_add_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">early_data</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">ticket_max_early_data</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="n">CBB_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extensions</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Add a fake extension. See draft-davidben-tls-grease-01.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CBB_add_u16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extensions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="n">ssl_get_grease_value</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">ssl_grease_ticket_extension</span><span class="p">))</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="n">CBB_add_u16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extensions</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* empty */</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssl_add_message_cbb</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">cbb</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">out_sent_tickets</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后我们提一句single-use这个事情，TLS1.3 RFC对于SINGLE-USE是维持一个SESSION TICKET数据库，如果用到了就直接删除，保证不会再出现复用。那么BORING SSL怎么做的呢？我们就看看BORING SSL处理SESSION TICKET的逻辑，换言之，只要是TLS1.3之后，包括TLS1.3的版本，必然是SINGLE-USE的，这个假设可以说是相当错误，实际上没必须如此的设定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">SSL_SESSION_should_be_single_use</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL_SESSION</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ssl_session_protocol_version</span><span class="p">(</span><span class="n">session</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TLS1_3_VERSION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>那么如何实现SINGLE-USE的呢？遗憾的是，这个东西BORING SSL和OPENSSL SSL都没实现：</p>
<blockquote>
<p>Note also, in TLS 1.2 and earlier, offering sessions allows passive observers to correlate different client connections. TLS 1.3 and later fix this, provided clients use sessions at most once. Session caches are managed by the caller in BoringSSL, so this must be implemented externally. See <code>SSL_SESSION_should_be_single_use</code> for details.</p></blockquote>


<h2 class="relative group">5 拓展相关数据结构 
    <div id="5-%E6%8B%93%E5%B1%95%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5-%E6%8B%93%E5%B1%95%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">5.1 ALPN 
    <div id="51-alpn" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#51-alpn" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">5.2 NPN 
    <div id="52-npn" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#52-npn" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h2 class="relative group">结尾 
    <div id="%E7%BB%93%E5%B0%BE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%93%E5%B0%BE" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>唉，尴尬</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://i.loli.net/2020/08/27/BFHNyfpx3EsIDUG.jpg" alt="狗头的赞赏码.jpg" />
    
  </figure>
</p>

          
          
          
        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_posts\/2021-04-12-boringSSL研究笔记\/index.md"
        var oid_likes = "likes_posts\/2021-04-12-boringSSL研究笔记\/index.md"
      </script>
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
      
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/posts/2021-04-02-tls1.3_8446_rfc%E7%BF%BB%E8%AF%91/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >TLS1.3 8446 RFC翻译</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2021-04-02T00:00:00&#43;00:00">2021 年 4 月 2 日</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/posts/2021-04-14-%E5%A4%84%E4%B8%96%E4%B8%89%E4%B9%A6%E7%AC%94%E8%AE%B0/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >处世三书笔记.md</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2021-04-14T00:00:00&#43;00:00">2021 年 4 月 14 日</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="返回顶部" title="返回顶部">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      © 2025 - 2025 菜狗 All Rights Reserved.
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a> 强力驱动
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="https://hxndg.github.io/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="搜索"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="关闭 (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
