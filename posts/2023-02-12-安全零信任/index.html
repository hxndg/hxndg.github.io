<!doctype html><html lang=cn dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>2023-02-12-安全零信任 &#183; 菜狗的blog</title>
<meta name=title content="2023-02-12-安全零信任 &#183; 菜狗的blog"><meta name=description content="菜狗's website"><meta name=keywords content="security,八股,fun,"><link rel=canonical href=https://hxndg.github.io/posts/2023-02-12-%E5%AE%89%E5%85%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB/><link type=text/css rel=stylesheet href=/css/main.bundle.min.ba3775bebd52a2b4837f8da64e32ee36e5c52bf284a0ce2262562782398b701543947527ad1498487717b1b96fe2a4e48d365a02e0b5d00e224893052e99d83c.css integrity="sha512-ujd1vr1SorSDf42mTjLuNuXFK/KEoM4iYlYngjmLcBVDlHUnrRSYSHcXsblv4qTkjTZaAuC10A4iSJMFLpnYPA=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.764eb2fe8d6a6b086c7c58f87d12c64fa79a7585117fc27eb53f688f80c287a6eff16277f9d186cd223a39ff700e294d64482834faece5e07ee0498fa042d056.js integrity="sha512-dk6y/o1qawhsfFj4fRLGT6eadYURf8J+tT9oj4DCh6bv8WJ3+dGGzSI6Of9wDilNZEgoNPrs5eB+4EmPoELQVg==" data-copy data-copied></script><script src=/lib/zoom/zoom.min.3530c2657381259433194af312ec3d322a97a2ad85661810299757fe793b24c3b8e07ab97fa8e5cf96cff1208f271e75394b6eaa56c2e39e7e2c3ca49fb1921c.js integrity="sha512-NTDCZXOBJZQzGUrzEuw9MiqXoq2FZhgQKZdX/nk7JMO44Hq5f6jlz5bP8SCPJx51OUtuqlbC455+LDykn7GSHA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://hxndg.github.io/posts/2023-02-12-%E5%AE%89%E5%85%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB/"><meta property="og:site_name" content="菜狗的blog"><meta property="og:title" content="2023-02-12-安全零信任"><meta property="og:description" content="菜狗's website"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-22T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-22T00:00:00+00:00"><meta property="article:tag" content="Security"><meta property="article:tag" content="八股"><meta property="article:tag" content="Fun"><meta name=twitter:card content="summary"><meta name=twitter:title content="2023-02-12-安全零信任"><meta name=twitter:description content="菜狗's website"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"2023-02-12-安全零信任","headline":"2023-02-12-安全零信任","inLanguage":"zh-cn","url":"https:\/\/hxndg.github.io\/posts\/2023-02-12-%E5%AE%89%E5%85%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB\/","author":{"@type":"Person","name":"菜狗"},"copyrightYear":"2021","dateCreated":"2021-02-22T00:00:00\u002b00:00","datePublished":"2021-02-22T00:00:00\u002b00:00","dateModified":"2021-02-22T00:00:00\u002b00:00","keywords":["security","八股","fun"],"mainEntityOfPage":"true","wordCount":"20533"}]</script><meta name=author content="菜狗"><script src=/lib/jquery/jquery.slim.min.03cb160e3cfdb2667a2e2c80d283bebcf63ff8bbc4b629c9ab2babf6fae1d0c07ad470edae783efa4fabda2ac01c58d60e63b98b3c336be8208460f08f4354f5.js integrity="sha512-A8sWDjz9smZ6LiyA0oO+vPY/+LvEtinJqyur9vrh0MB61HDtrng++k+r2irAHFjWDmO5izwza+gghGDwj0NU9Q=="></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">菜狗的blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Home</p></a><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Posts</p></a><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Tags</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Home</p></a></li><li class=mt-1><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Posts</p></a></li><li class=mt-1><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Tags</p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">2023-02-12-安全零信任</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2021-02-22T00:00:00+00:00>2021 年 2 月 22 日</time><span class="px-2 text-primary-500">&#183;</span><span>20533 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>41 分钟</span></div></div><div class="flex author"><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">菜狗</div><div class="text-sm text-neutral-700 dark:text-neutral-400">Focus</div><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#零信任概述不用仔细看>零信任概述（不用仔细看）</a></li><li><a href=#到底什么是零信任>到底什么是零信任</a><ul><li><a href=#身份方面>身份方面</a></li></ul></li><li><a href=#现存的零信任模型>现存的零信任模型</a><ul><li><a href=#零信任的分类>零信任的分类</a></li></ul></li><li><a href=#面临的问题>面临的问题</a></li><li><a href=#零信任组件技术>零信任组件技术</a><ul><li><a href=#1-sdpspa端口隐藏>1 SDP（SPA）端口隐藏</a><ul><li><a href=#11双层隐身架构>1.1双层隐身架构</a></li></ul></li><li><a href=#2零信任网关>2零信任网关</a></li><li><a href=#21-微隔离>2.1 微隔离</a></li></ul></li><li><a href=#3-spiffe的研究微隔离>3 SPIFFE的研究（微隔离）</a><ul><li><a href=#31-spiffe-的基本概念>3.1 SPIFFE 的基本概念</a></li><li><a href=#32-以spire为入口学习spiffe>3.2 以SPIRE为入口学习SPIFFE</a><ul><li><a href=#320-spire问题>3.2.0 SPIRE问题</a></li><li><a href=#321-spire的架构>3.2.1 SPIRE的架构</a></li><li><a href=#322-spire下的svid的整体流程>3.2.2 SPIRE下的SVID的整体流程</a></li><li><a href=#323-关键过程>3.2.3 关键过程</a></li><li><a href=#323-spire的实践关键过程>3.2.3 SPIRE的实践关键过程</a></li></ul></li><li><a href=#基础安全软件的分析>基础安全软件的分析</a><ul><li></li></ul></li><li><a href=#pki体系建设实践>[PKI体系建设实践]</a><ul><li><a href=#一些实现的细节>一些实现的细节</a></li><li><a href=#10322-tls自定拓展>10.3.2.2 TLS自定拓展</a></li><li><a href=#10322-tls-pha功能和安全重协商>10.3.2.2 TLS PHA功能和安全重协商</a></li></ul></li><li><a href=#云原生安全>云原生安全</a></li><li><a href=#1-从底层linux说起>1 从底层linux说起</a><ul><li><a href=#11-权限模型方面>1.1 权限模型方面</a></li><li><a href=#12-资源隔离>1.2 资源隔离</a></li><li><a href=#13-namespace隔离>1.3 namespace隔离</a></li></ul></li><li><a href=#2-云原生安全>2 云原生安全</a><ul><li><a href=#21-云原生安全>2.1 云原生安全</a></li><li><a href=#22-kubernetes安全>2.2 kubernetes安全</a></li></ul></li><li><a href=#23-回到devsecops>2.3 回到DEVSECOPS</a></li></ul></li><li><a href=#20-云安全>2.0 云安全</a><ul><li><a href=#21-云扫描>2.1 云扫描</a></li><li><a href=#23-云防护>2.3 云防护</a></li><li><a href=#24-云siem>2.4 云SIEM</a></li></ul></li><li><a href=#3-数据安全实践>3 数据安全实践</a><ul><li><a href=#q数据保护方案>[Q数据保护方案]</a></li></ul></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#零信任概述不用仔细看>零信任概述（不用仔细看）</a></li><li><a href=#到底什么是零信任>到底什么是零信任</a><ul><li><a href=#身份方面>身份方面</a></li></ul></li><li><a href=#现存的零信任模型>现存的零信任模型</a><ul><li><a href=#零信任的分类>零信任的分类</a></li></ul></li><li><a href=#面临的问题>面临的问题</a></li><li><a href=#零信任组件技术>零信任组件技术</a><ul><li><a href=#1-sdpspa端口隐藏>1 SDP（SPA）端口隐藏</a><ul><li><a href=#11双层隐身架构>1.1双层隐身架构</a></li></ul></li><li><a href=#2零信任网关>2零信任网关</a></li><li><a href=#21-微隔离>2.1 微隔离</a></li></ul></li><li><a href=#3-spiffe的研究微隔离>3 SPIFFE的研究（微隔离）</a><ul><li><a href=#31-spiffe-的基本概念>3.1 SPIFFE 的基本概念</a></li><li><a href=#32-以spire为入口学习spiffe>3.2 以SPIRE为入口学习SPIFFE</a><ul><li><a href=#320-spire问题>3.2.0 SPIRE问题</a></li><li><a href=#321-spire的架构>3.2.1 SPIRE的架构</a></li><li><a href=#322-spire下的svid的整体流程>3.2.2 SPIRE下的SVID的整体流程</a></li><li><a href=#323-关键过程>3.2.3 关键过程</a></li><li><a href=#323-spire的实践关键过程>3.2.3 SPIRE的实践关键过程</a></li></ul></li><li><a href=#基础安全软件的分析>基础安全软件的分析</a><ul><li></li></ul></li><li><a href=#pki体系建设实践>[PKI体系建设实践]</a><ul><li><a href=#一些实现的细节>一些实现的细节</a></li><li><a href=#10322-tls自定拓展>10.3.2.2 TLS自定拓展</a></li><li><a href=#10322-tls-pha功能和安全重协商>10.3.2.2 TLS PHA功能和安全重协商</a></li></ul></li><li><a href=#云原生安全>云原生安全</a></li><li><a href=#1-从底层linux说起>1 从底层linux说起</a><ul><li><a href=#11-权限模型方面>1.1 权限模型方面</a></li><li><a href=#12-资源隔离>1.2 资源隔离</a></li><li><a href=#13-namespace隔离>1.3 namespace隔离</a></li></ul></li><li><a href=#2-云原生安全>2 云原生安全</a><ul><li><a href=#21-云原生安全>2.1 云原生安全</a></li><li><a href=#22-kubernetes安全>2.2 kubernetes安全</a></li></ul></li><li><a href=#23-回到devsecops>2.3 回到DEVSECOPS</a></li></ul></li><li><a href=#20-云安全>2.0 云安全</a><ul><li><a href=#21-云扫描>2.1 云扫描</a></li><li><a href=#23-云防护>2.3 云防护</a></li><li><a href=#24-云siem>2.4 云SIEM</a></li></ul></li><li><a href=#3-数据安全实践>3 数据安全实践</a><ul><li><a href=#q数据保护方案>[Q数据保护方案]</a></li></ul></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><script>var margin=200,marginError=50;(function(){var t=$(window),e=$("#TOCView"),s=e.height();function n(){var n=t.height()-margin;s>=n?(e.css("overflow-y","scroll"),e.css("max-height",n+marginError+"px")):(e.css("overflow-y","hidden"),e.css("max-height","9999999px"))}t.on("resize",n),$(document).ready(n)})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><h1 class="relative group">2023-02-12-安全零信任<div id=2023-02-12-%E5%AE%89%E5%85%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2023-02-12-%E5%AE%89%E5%85%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB aria-label=锚点>#</a></span></h1><h2 class="relative group">零信任概述（不用仔细看）<div id=%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%A6%82%E8%BF%B0%E4%B8%8D%E7%94%A8%E4%BB%94%E7%BB%86%E7%9C%8B class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%A6%82%E8%BF%B0%E4%B8%8D%E7%94%A8%E4%BB%94%E7%BB%86%E7%9C%8B aria-label=锚点>#</a></span></h2><p>零信任包含以下几个方面：</p><p><figure><img class="my-0 rounded-md" loading=lazy src=imgs/IMG_%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%9F%BA%E7%A1%80.png alt=IMG_零信任基础></figure></p><p>现在展开讲：</p><p>由于1 身份认证并不可靠，内网不等于可信网络，内网用户不一定是可信用户。2 网络边界越来越难以划分</p><p>因此需要展开零信任，零信任包含以下几个要求：</p><ul><li>信任最小化：任何访问主体（人/设备/应用等），在访问被允许之前，都必须要经过身份认证和授权，默认不信任；换言之1.端到端加密确保传输安全2 1.企业应用或服务不再对公网可见</li><li>分配访问权限是基于业务，越细越好，遵循最小权限原则；</li><li>多源信任评估：尽可能多的和及时的获取可能影响授权的所有信息，进行安全评估。换言之提供基于网络；设备；身份；环境认证的访问控制</li><li>权限动态化：对信息进行持续的信任评估和安全响应。换言之仅对特定应用而非网络授予访问权限</li><li>可视化，智能化：通过可视化了解和评估网络中可能产生的安全威胁，进行主动和自动化的防御。</li></ul><p>那么，在一个零信任网络里面，以下三个组件很重要：</p><ol><li>Policy engine (PE)</li><li>Policy administrator (PA)</li><li>Policy enforcement point (PEP)</li></ol><h2 class="relative group">到底什么是零信任<div id=%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E4%BF%A1%E4%BB%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E4%BF%A1%E4%BB%BB aria-label=锚点>#</a></span></h2><p>一种说法是：S.I.M.=SDP+IAM（<em>Identity and Access Management</em> (<em>IAM</em>)）+微隔离.这个说起来还是很粗的，实际上就是，<figure><img class="my-0 rounded-md" loading=lazy src=imgs/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%9B%BE%E7%89%87.jpg alt=零信任图片></figure></p><p>所以总结来说，零信任是多个方面的结合</p><h3 class="relative group">身份方面<div id=%E8%BA%AB%E4%BB%BD%E6%96%B9%E9%9D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E8%BA%AB%E4%BB%BD%E6%96%B9%E9%9D%A2 aria-label=锚点>#</a></span></h3><p>需要给出有哪些对应的软件</p><p>身份方面有很多点</p><ul><li><p>身份大数据</p><ul><li>需要定义用户，组织，设备，资源等实体的模型。还得管理生命周期。<strong>需要能够方便的检索出来一些冗余信息</strong><ul><li>对人而言，区分是员工，还是客户等，管理每个人的组织机构信息，个人信息，标签，关联设备</li><li>设备，要建立合法设备清单库，包括设备标识，软件硬件信息，设备安全状态</li><li>应用：身份标识，服务器地址，应用提供的功能菜单，</li><li>API：包括API服务是谁，访问哪些API，身份标识，接口信息，参数信息，返回信息</li></ul></li><li>需要从各种终端设备同步和用户属性相关的信息，汇聚为大数据</li><li>集中<strong>管理</strong>各种不同角色，比方说用户/员工/外包，管理能力或者说检索能力很重要</li></ul></li><li><p>身份认证的方式</p><ul><li>密码，口令，U盾牌</li><li>持续多因素认证</li></ul></li><li><p>动态授权</p><ul><li><p>比方说归结为角色：网管，开发，RBAC的直观清晰，但是角色一多就是灾难。</p></li><li><p>基于属性的授权，比方说设备的属性，设备的环境（时间，位置，ip地址），业务属性。现实往往是角色和属性的综合授权</p></li><li><p>基于任务的授权，针对用户授予某项任务的权限，任务结束立刻收回</p></li><li><p>策略。某种策略，一个策略应该包含策略主体，策略课题，策略条件，策略动作等。因为策略过于复杂，所以应该分层指定策略，用户的请求必须一层一层的递进，才能判断是否成功。比方说用户访问资源，先判断，用户是否有授权，再判断是否满足网络安全要求，再判断数据是否脱敏。授权策略完全可以依托于上面列举的点，比方说角色，属性，任务</p></li><li><p>临时权限</p></li></ul></li></ul><p>设备方面</p><ul><li>设备清单<ul><li>能够识别设备，利用ID，MAC，主板号，</li><li>设备绑定，能够和用户角色绑定</li><li>设备清单库</li></ul></li><li>设备安全<ul><li>设备认证，相关绑定人</li><li>设备安全监测，监测设备是否安全合规</li><li>设备漏洞修复</li><li>远程擦除敏感数据</li><li>可信进程管理</li><li>设备准入基线</li></ul></li></ul><p>网络方面</p><ul><li>统一的入口<ul><li>安全隧道网关</li><li>API安全网关</li><li>分布式网关集群</li><li>网络准入</li><li>网络入侵防护</li><li>安全DNS</li></ul></li></ul><p>数据方面</p><ul><li>数据访问控制<ul><li>数据分级分类</li><li>数据访问控制</li><li>数据脱敏</li></ul></li><li>数据泄密防护<ul><li>基于零信任授权策略，在用户可信等级较低或者资源要求较高，执行数字水印，敏感文件审计</li><li>终端沙箱，在设备商划分数据安全区，敏感数据只能沙箱访问，并且最终在终端的安全区访问，也许出发在这个点？</li><li>远程浏览器隔离</li><li>安全浏览器</li></ul></li></ul><p>安全审计</p><ul><li>安全审计</li><li>风险分析</li><li>新人评估</li></ul><h2 class="relative group">现存的零信任模型<div id=%E7%8E%B0%E5%AD%98%E7%9A%84%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%A8%A1%E5%9E%8B class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%8E%B0%E5%AD%98%E7%9A%84%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%A8%A1%E5%9E%8B aria-label=锚点>#</a></span></h2><h3 class="relative group">零信任的分类<div id=%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%9A%84%E5%88%86%E7%B1%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%9A%84%E5%88%86%E7%B1%BB aria-label=锚点>#</a></span></h3><p>零信任分为两种，一种是对用户的，另一种是对企业内部的。对用户的标准的架构有两种</p><ul><li>SDP标准：三个组件，SDP客户端，SDP网关，SDP管控端。用户和网关都向SDP管控端报道，管控端通知客户和SDP网关相关的身份信息和权限校验，提前两者是相互都不清楚的：用户向管控端报告以后，管控端会给网关发用户相关信息，同时提供给用户有权连接的SDP网关列表，之后SDP客户端会使用SPA（单包授权 Single Packet Authorization，理解为敲门暗号）技术向SDP网关通信，校验身份成功即开放IP端口。</li><li>NIST的标准</li></ul><p>针对企业，或者说针对云服务内部的，微隔离</p><p>例子：beyondprod，</p><h2 class="relative group">面临的问题<div id=%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98 aria-label=锚点>#</a></span></h2><h2 class="relative group">零信任组件技术<div id=%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF aria-label=锚点>#</a></span></h2><h3 class="relative group">1 SDP（SPA）端口隐藏<div id=1-sdpspa%E7%AB%AF%E5%8F%A3%E9%9A%90%E8%97%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-sdpspa%E7%AB%AF%E5%8F%A3%E9%9A%90%E8%97%8F aria-label=锚点>#</a></span></h3><ul><li>SDP网关默认拒绝所有IP的连接，常规黑客扫描不出来</li><li>客户端和SDP控制端通信，申请通过后，控制端给SDP网关和SDP客户端发送凭据和身份信息</li><li>客户端发送一个单包到SDP网关约定的端口，SDP网关收到后会添加路由，用户就可以反映了</li></ul><p>难题是怎么保证SPA是不可伪造的，因此如何保证秘钥？有三种方法</p><ul><li>客户端嵌入秘钥</li><li>用激活码生成秘钥，给用户一个随机的身份秘钥，由它派生</li><li>将临时秘钥转为正式秘钥，设定失效条件</li></ul><p>增强的手段可以为TLS敲门技术，在clienthello里面放拓展字段</p><h4 class="relative group">1.1双层隐身架构<div id=11%E5%8F%8C%E5%B1%82%E9%9A%90%E8%BA%AB%E6%9E%B6%E6%9E%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11%E5%8F%8C%E5%B1%82%E9%9A%90%E8%BA%AB%E6%9E%B6%E6%9E%84 aria-label=锚点>#</a></span></h4><p>双层隐身架构，说白了就是在企业内网边界之外使用云网关，然后客户端接入到云网关。连接器（在内网边界）直接连接云网关，这样子实际上就是转移难度到云网关</p><h3 class="relative group">2零信任网关<div id=2%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%BD%91%E5%85%B3 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%BD%91%E5%85%B3 aria-label=锚点>#</a></span></h3><p>作为零信任的中心，作用有两个</p><ul><li>分割用户和资源，零信任网关就是一个保安，或者说门卫</li><li>执行安全策略，用户连接到安全网关之后，再到达业务系统，素以安全网关可以挡住大部分的业务系统攻击。</li></ul><p>网关有多种，比方说API网关，web代理网关</p><ul><li><p>web代理网关功能主要是在下面写出来了。这种是所有流量的入口，主要在边界</p><ul><li>转发请求：根据用户域名的不同，转发到不同的服务器，</li><li>获取身份，从cookie或者数据包头部加入代表用户身份的token</li><li>验证身份，web代理网关将访问者的信息发送给管控平台，这一步严重影响性能</li></ul></li><li><p>隐身网关。类似防火墙，可以认为只有特定身份的用户可以参与进来。</p><ul><li>其类似SPA的实现方式，使用UDP就可以携带特定的身份信息直接参与到具体的敲门过程。我个人觉得这里可以让DTLS参与进来。可以参考WIREGUARD协议</li></ul></li><li><p>网络隧道网关，代理SSH等协议，四层网关</p></li><li><p>API网关，针对服务器之间的访问，主要在pod或者微隔离环境的内部。一般是将请求放协议的头部</p></li></ul><p>这些最终集合成为一个个的网关平台，根据不同的功能还要同时提供负载均衡，加密传输等功能</p><h3 class="relative group">2.1 微隔离<div id=21-%E5%BE%AE%E9%9A%94%E7%A6%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#21-%E5%BE%AE%E9%9A%94%E7%A6%BB aria-label=锚点>#</a></span></h3><p>微隔离解决的是服务器之间这么进行身份验证，安全通信的问题。</p><ul><li>在每个服务器的操作系统上配置agent客户端，基于微隔离组件实现。agent客户端统一由零信任管控平台管理。优点是底层无关，支持多种容器，这个实际上是发生在操作系统层面，可以理解为pod里面？</li><li>基于云原生的虚拟化设备自身防火墙功能进行访问控制，这种方式实际上发生在node的虚拟机管理级别。</li><li>基于第三方防火墙，最僵硬</li></ul><p>微隔离的架构</p><ol><li>微隔离组件的集中管控：微隔离组件有一个零信任管控平台统一管控，负责下发策略，分发证书，进行身份认证和访问控制校验</li><li>身份认证：微隔离组件启动后，要先向控制台发起身份认证，最简单的方式就是基于企业的PKI做认证。认证通过后就可以获取权限列表和可访问的资源。</li><li>服务端环境感知：微隔离的组件可以对服务端的安全状态进行检查，后续根据安全策略，阻止有风险的服务器接入零信任网络</li><li>端口暴露管理:控制暴露的端口</li><li>进程外联控制：检查是否有部分异常进程的奇怪连接，比方说shell连接外部ip地址</li><li>通信和校验过程：微隔离组件可以作为客户端或者服务端当成mtls的起点或者终点进行通信</li></ol><p>微隔离管控平台</p><ul><li>提供基于身份的访问策略：在云原生的环境，容器的宿主机是不确定的，服务可能直接迁移，因此基于ip地址进行管控已经失去了意义，得使用服务的身份。即对于微服务，提供基于7层而非4层的隔离。这实际上就是说在容器里面建立一个7层的访问代理。</li><li>访问策略的构成：微隔离策略的主体和客体可以是服务器，微服务，进程。微隔离策略模型可以从自身的身份，组，标签，安全属性等维度设置访问条件</li><li>可以自动学习业务策略，</li><li>业务关系可视化</li><li>策略下发</li><li>环境感知和风险监控</li></ul><h2 class="relative group">3 SPIFFE的研究（微隔离）<div id=3-spiffe%E7%9A%84%E7%A0%94%E7%A9%B6%E5%BE%AE%E9%9A%94%E7%A6%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-spiffe%E7%9A%84%E7%A0%94%E7%A9%B6%E5%BE%AE%E9%9A%94%E7%A6%BB aria-label=锚点>#</a></span></h2><p>关于零信任在生产环境的落地，很多文章实际上说的是非常不清晰的，比方说微隔离的实现等，spiffe给出了非常实用的实现方法。spiffe和spire，主要解决微服务下的各种服务框架横行的模式下，怎么进行安全通信的问题。即，spiffe的workload相互调用时使用mtls进行调用，其证书私钥如何传递，颁发的问题。</p><h3 class="relative group">3.1 SPIFFE 的基本概念<div id=31-spiffe-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#31-spiffe-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 aria-label=锚点>#</a></span></h3><p>spiffe服务端先认证云环境下的node节点，在认证完node节点后，先让节点了解到工作负载（workload）有哪些，并且申请下来证书私钥。之后如果有workload要通信，就校验是否是合法workload，从而判断是否给出证书和私钥。workload校验完成之后就可以进行mtls通信啦。</p><p>SPIFFE的基本概念</p><ul><li>workload，工作负载，简单理解a workload may often be more fine-grained than a physical or virtual node – often as fine grained as individual processes on the node.</li><li>SPIFFE ID，SPIFFE ID is a string that uniquely and specifically identifies a workload.</li><li>Trust Domain,The trust domain corresponds to the trust root of a system. A trust domain could represent an individual, organization, environment or department running their own independent SPIFFE infrastructure. All workloads identified in the same trust domain are issued identity documents that can be verified against the root keys of the trust domain.</li><li>SPIFFE Verifiable Identity Document，SVID is the document with which a workload proves its identity to a resource or caller. An SVID is considered valid if it has been signed by an authority within the SPIFFE ID’s trust domain.加密的可验证的档案，用于证明工作负载的身份。两种模式，一种是X509格式的证书和私钥，SAN（subject alternative name）放对应的spiffeid。另一种是jwt</li><li>workload API，workload API provides the following：SPIFFE ID，对应的证书，相对应的Trust Bundle(A set of certificates)。简单来说提供证书数和私钥去做mtls，还有对应的CA</li><li>When using X.509-SVIDs, a trust bundle is used by a destination workload to verify the identity of a source workload. A trust bundle is a collection of one or more certificate authority (CA) root certificates。复杂的网络环境下，多个不同的spiffe context交互，每个svid的ca可能不同，需要交换这些公钥信息，这些公钥信息就是trust bundle。</li><li>SPIFFE Federation：共享 SPIFFE Trust Bundle 的机制。名字起的很有趣，联邦</li></ul><h3 class="relative group">3.2 以SPIRE为入口学习SPIFFE<div id=32-%E4%BB%A5spire%E4%B8%BA%E5%85%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0spiffe class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#32-%E4%BB%A5spire%E4%B8%BA%E5%85%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0spiffe aria-label=锚点>#</a></span></h3><h4 class="relative group">3.2.0 SPIRE问题<div id=320-spire%E9%97%AE%E9%A2%98 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#320-spire%E9%97%AE%E9%A2%98 aria-label=锚点>#</a></span></h4><p>我个人认为，从问题入手会学习的比较快，列几个我目前还没明白的点</p><ul><li>SPIRE只是简单的在Trust Bundle中提了一嘴用来解决动态感知客户端身份的方法，至于说业务关系的可视化，基于身份的访问策略这些都没提。这些当然可以作为附加功能直接贴到SPIRE AGENT当中，我个人觉得，授权关系基于Trust Bundle的方式来做会比较简单（因为直接调用房CA证书校验不通过就行），但是Trust Bundle的动态更新，会成为一个问题点。我想到的点是授权策略还是剥离出来，但是可以采用授权策略最后更新时间作为检查的点</li><li>SPIRE在网络内部，怎么做对应证书的过期，剔除，无效化操作？</li><li>SPIRE SERVER有签发SVID的功能，这些SVID是不是要有PKI管理，很多敏感信息也要读取KMS信息，这些证书要作为可授信的凭证参与到KMS信息的管理。那么KMS是不是应该也细分为不同Trust Domain的粒度，存储不同的敏感信息。那么一旦不同的Namespace要共享一些敏感信息，这两个KMS是不是也得共享一套Trust Bundle。跨网段的沟通协同看起来很危险。</li><li>SPIRE AGENT启动时，怎么有服务端的信息，即怎么证实访问到的服务端的身份？</li><li>SPIRE AGENT启动时，为什么先获取被授权的相关工作负载</li><li>SPIRE架构下SVID的有效期和自动更新怎么做呢？</li></ul><h4 class="relative group">3.2.1 SPIRE的架构<div id=321-spire%E7%9A%84%E6%9E%B6%E6%9E%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#321-spire%E7%9A%84%E6%9E%B6%E6%9E%84 aria-label=锚点>#</a></span></h4><p>SPIRE的架构就两块：服务器和 Agent</p><ul><li><p>服务器负责签发 SVID ，这些SVID最终通过 Agent 传递给工作负载；它要同时保存很多workload的注册信息，简单来说就是哪些workload可以调用workload api的问题；</p><ul><li>SPIRE Server 负责在SPIFFE信任域管理和签发身份信息，因此它存储着 <a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#workload-registration target=_blank>registration entries</a> (用于判断是否应该签发出来对应的SPIFFE ID) ，签发密钥, 用 <a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-attestation target=_blank>node attestation</a> 来自动认证服务器节点, 为工作负载创建SVIDs</li><li>其架构要求一些插件的参与<ul><li><strong>Node attestor plugins</strong> 同 <a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-attestation target=_blank>Node Attestation</a> 一起认证节点</li><li><strong>Node resolver plugins</strong> which expand the set of selectors the server can use to identify the node by verifying additional properties about the node. See the section <a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-resolution target=_blank>Node Resolution</a> for more information.</li><li><strong>Datastore plugins</strong>, 服务器检索，更新，存储信息的地方，比方说存储registration entries](<a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#workload-registration%29 target=_blank>https://spiffe.io/docs/latest/spire-about/spire-concepts/#workload-registration)</a>, 哪些节点已经认证好了, 这些节点的选择器是哪些</li><li><strong>Key manager plugins</strong>,管理server这么签发SVID信息</li><li><strong>Upstream authority plugins</strong>. 一般默认情况SPIRE服务器自己充当CA，但是你也可以用上游CA直接参与管理</li></ul></li></ul></li><li><p>Agent 部署在每个节点上，向工作负载公开 Workload API。Workload在通信之前先请求证书和私钥（SVID），真正的签发请求透明地传递到server上。</p><ul><li><p>功能</p><ul><li>从服务端请求SVIDs，并一直缓存它们，直到有真正的调度来了。</li><li>向Workload暴露SPIFFE Workload API，证实Workload的身份</li><li>向Workload提供他们的SVIDs</li></ul></li><li><p>架构</p><ul><li>Node attestor plugins which,同 <a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-attestation target=_blank>Node Attestation</a> 一起认证节点</li><li>Workload attestor plugins – 认证工作负载，从操作系统检索进程信息，并和server端拿到的信息做比对registered the workload’s properties](<a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#workload-registration target=_blank>https://spiffe.io/docs/latest/spire-about/spire-concepts/#workload-registration</a>) 参考 <a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#workload-attestation target=_blank>Workload Attestation</a></li><li>Key manager plugins, 管理如何签发和使用SVID信息</li></ul></li></ul></li></ul><p><figure><img class="my-0 rounded-md" loading=lazy src=imgs/server_and_agent.png alt=server_and_agent></figure></p><h4 class="relative group">3.2.2 SPIRE下的SVID的整体流程<div id=322-spire%E4%B8%8B%E7%9A%84svid%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#322-spire%E4%B8%8B%E7%9A%84svid%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B aria-label=锚点>#</a></span></h4><p>这一节内容讲述了 SPIRE 签发工作负载身份的过程。这个过程从 Agent 在节点上启动开始，持续到工作负载收到有效的 X.509 SVID 为止（注意，JWT 和 X.509 的处理方式是不同的）。下面以 AWS EC2 为例。</p><ol><li><p>SPIRE Server 启动</p></li><li><p>除非用户配置了上游 CA 插件，Server 会生成一个自签名证书；Server 会使用这个证书来给信任域内所有的工作负载签发 SVID</p></li><li><p>如果这是首次启动，Server 会自动生成 Trust Bundle，这些内容会被存储在 SQL 数据库中，参考https://github.com/spiffe/spire/blob/v1.5.4/doc/plugin_server_datastore_sql.md</p></li><li><p>Server 开启注册 API，允许注册工作负载。</p></li><li><p>SPIRE Agent 在运行了工作负载的节点上启动</p></li><li><p>Agent 执行节点证实工作，向 Server 证明节点的身份。例如在 AWS EC2 实例上，通常会把 <a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html target=_blank>AWS Instance Identity Document</a> 提交给服务器，Agent 把该证据用 TLS 提交给 Server。**这里注意！这个是双方必须先配置好的共识！**SPIRE里面这个是公用配置，自己配置的时候不要搞错哦。<strong>这里出现了第一个问题，AGENT怎么知道服务器在哪里？怎么对抗欺骗？</strong></p></li><li><p>Server 调用 AWS API 对这些证据进行校验</p></li><li><p>AWS 确认身份证据的有效性，即节点通过校验</p></li><li><p>Server 对节点进行解析，验证 Agent 节点的附加属性，并更新注册数据。例如节点使用的是 Azure Managed Service Identity（MSI）。Resolver 会根据 SPIFFE ID 解析 Tenat ID 以及 Principal ID，并用多种 Azure Service 获取额外信息</p></li><li><p>Server 给 Agent 签发一个 SVID，证实 Agent 的身份</p></li><li><p>Agent 用它的 SVID 以及他的 TLS 客户端证书联系 Server，试图获得它被授权的相关工作负载</p></li><li><p>Server 用 Agent 的 SVID 验证 Agent 的身份。Agent 接下来会完成 mTLS 握手，AGENT使用 Bootstarap Bundle 完成对服务端认证。到这里我们就确定了服务器和客户端都是正确的客户端了。</p></li><li><p>Server 从数据库中抓取所有（该 Agent 下的）<a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/#authorized-registration-entries target=_blank>认证的注册条目</a>，实际上就是工作负载，发送给 Agent</p><ol><li>服务端怎么选择对应的注册条目？<ol><li>Query the database for any registration entries that have the agent’s SPIFFE ID listed as their “parent SPIFFE ID”.</li><li>Query the database for what additional properties the specific agent is associated with ("<em>node</em> selectors”).</li><li>Query the database for any registration entries that declare at least one selection on any of those <em>node</em> selectors. *</li><li>Recursively query the database for any registration entries that declare any of the entries obtained so far as their “parent SPIFFE ID” (descend to all children).</li></ol></li></ol></li><li><p>Agent 发送工作负载的 CSR 给 Server，Server 会签署和返回 Workload SVID 给客户端，客户端进行缓存</p></li><li><p>启动过程完成，Agent 开始监听 Workload API 的 Socket</p></li><li><p>Workload 调用调用 Workload API，申请 SVID</p></li><li><p>Agent 通过调用 Workload Attestor 来初始化 Workload 的证实过程，证实过程的输入以工作负载的进程 ID 启动</p></li><li><p>Attestor 使用内核和用户空间的调用，发现工作负载的附加信息</p></li><li><p>Attestor 把发现的信息返回给 Agent</p></li><li><p>Agent 通过比对缓存中的注册信息和 Workload 上报的信息，来决定是否把缓存中的 SVID 返回给工作负载。</p></li></ol><h4 class="relative group">3.2.3 关键过程<div id=323-%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#323-%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B aria-label=锚点>#</a></span></h4><p>有两个关键过程：</p><ul><li>节点证实：保障工作负载所在的节点的身份的有效性</li><li>工作负载证实：保证节点上的工作负载是有效的</li></ul><h5 class="relative group">3.2.3.1 Node Attestation<div id=3231-node-attestation class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3231-node-attestation aria-label=锚点>#</a></span></h5><p>节点的证实过程是在 Agent 启动过程中完成的，SPIRE 要求 Agent 在第一次连接到服务器的时候能够验明正身。在节点证实过程中，Agent 和服务器协作对 Agent 所在的节点进行校验。这个过程是通过 SPIRE 中被称为 Node Attestor 的插件完成的，这种插件的基本做法就是对节点以及所在环境进行查询和比对，来验证节点身份的有效性。</p><p>节点证实成功之后，Agent 就收到了一个 SPIFFE ID，Agent 会把这个 ID 作为父 ID，发放给运行在这个节点上的工作负载。</p><p>几种常见的节点身份的证据：</p><ol><li>云平台分发给节点的身份文档（例如 AWS 的 Instance Identity Document）</li><li>节点上 HSM 或者 TPM 硬件的私钥</li><li>安装 Agent 时候的手工验证过程</li><li>多节点系统中提供的身份凭据，例如 Kubernetes 的 SA Token</li></ol><p>节点证实过程会返回一组属性（Selector）给服务器，这些属性能够标识出特定的节点，另外还会有 Node Resolver 来获取节点的其他属性，这些属性一起，构成了 SPIFFE ID 的附加属性。</p><p>例如 AWS 节点的证实过程：</p><p><figure><img class="my-0 rounded-md" loading=lazy src=https://blog.fleeto.us/post/something-about-spire/images/node_attestation.png alt=node_attestation></figure></p><ol><li>Agent 上的 AWS Node Attestor 向 AWS 查询节点的身份，发送给 Agent</li><li>Agent 把身份的证据发送给服务器，服务器把信息发送给 AWS Node Attestor（的服务侧）</li><li>AWS Node Attestor 的服务端独立或者调用 AWS API 对前一个步骤获取到的信息进行验证。Node Attestor 还会为 Agent 创建一个 SPIFFE ID，并把 SPIFFE ID 和 Selecor 传给服务器进程</li><li>Server 返回一个 Agent 节点的 SVID</li></ol><p>SPIRE 支持多种环境的 Node Attestor，例如：</p><ul><li>AWS 的 EC2 实例（EC2 Instance Identity Document）</li><li>Azure 虚拟机（Azure Managed Service Identities）</li><li>GCE Instance（GCE Instance Identity Token）</li><li>Kubernetes 节点（Kubernetes Service Account Token）<ul><li>这里多赘述一下k8s的安全机制，k8s有一张rootca证书，每个node上都有对应rootca签发出来的证书和私钥</li></ul></li></ul><p>对于无法直接认证节点的平台，SPIRE 提供了如下措施：</p><ul><li>服务器和 Agent 之间可以生成一个预共享密钥作为加入的 Token，Agent 启动时进行验证，使用后立即过期</li><li>使用现存 X.509 证书</li></ul><h5 class="relative group">3.2.3.2 Workload Attestation<div id=3232-workload-attestation class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3232-workload-attestation aria-label=锚点>#</a></span></h5><p>工作负载的证实过程要回答的问题是：这个进程是谁？Agent 和 Server 都参与到了节点证实过程里；而工作负载的证实过程是由 Agent 完成的。</p><p>下图展示了工作负载证明的过程：</p><p><figure><img class="my-0 rounded-md" loading=lazy src=https://blog.fleeto.us/post/something-about-spire/images/workload_attestation.png alt="Workload Attestation"></figure></p><ol><li>工作负载调用 Workload API 申请 SVID。在 Unix 系统中，这个 API 表现为一个 Unix Domain Socket</li><li>Agent 调用节点的内核来认证调用者的进程 ID。然后回调用工作负载的证实插件，把进程号提供给他们</li><li>利用进程 ID 查询工作负载的额外信息，可能会和 Kubelet 等同节点服务进行交互</li><li>Attestor 把进程信息返回给 Agent</li><li>Agent 把属性和注册信息进行比对，返回合适的 SVID 给工作负载。</li></ol><p>工作负载的证实机制目前支持 Unix、Kubernetes 和 Docker。</p><h4 class="relative group">3.2.3 SPIRE的实践关键过程<div id=323-spire%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#323-spire%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B aria-label=锚点>#</a></span></h4><p>具体的操作流程建议直接参考https://spiffe.io/docs/latest/try/getting-started-k8s/，这个讲的挺清楚的。</p><p>只针对几个特定的步骤做讲解.</p><p>部署spire-server阶段，首先要做的实际上创建spire-server的service-account，一个名叫spire-bundle的configmap(用来提供服务校验资格），和对应的更新config-map等权限，实际上，最后一个server-cluster-role.yaml就是将spire-server 的service account做绑定的。也就是下面的一个shell命令。</p><pre tabindex=0><code># 部署spire-server阶段，手下
$ kubectl apply \
    -f server-account.yaml \
    -f spire-bundle-configmap.yaml \
    -f server-cluster-role.yaml
</code></pre><p>接下来就可以部署spire-server了，server-configmap当中实际上指定了部分有趣的东西，里面有趣的部分被我截取了出来，里面写的k8s_sat实际上用来做nodeattestor，</p><p>简单解释下，需要参考 use_token_review_api_validation 来判断怎么做节点校验，说白了，实际上是让server校验agent提供的service token，这个service token实际上就是从node上面拿到的。。。如果use_token_review_api_validation为false，那么使用本地的service_account_key_file当中的key文件来校验token是否有效，否则使用 Kubernetes Token Review API，这时候就得提供kube_config_file文件的路径来和api服务器通信。参考 <a href=https://github.com/spiffe/spire/blob/main/doc/plugin_server_nodeattestor_k8s_sat.md target=_blank>https://github.com/spiffe/spire/blob/main/doc/plugin_server_nodeattestor_k8s_sat.md</a></p><pre tabindex=0><code>$ kubectl apply \
    -f server-configmap.yaml \
    -f server-statefulset.yaml \
    -f server-service.yaml
    
</code></pre><p>官方文档里面写的use_token_review_api_validation默认不用，但是官方教程里面的还是启用了token review api，哈哈哈哈哈。service_account_allow_list是一系列service account名字，用来校验使用。关于rokenrequest api，这个东西实际上</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span><span class=l>plugins {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>DataStore &#34;sql&#34; {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=l>plugin_data {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=l>database_type = &#34;sqlite3&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=l>connection_string = &#34;/run/spire/data/datastore.sqlite3&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>NodeAttestor &#34;k8s_sat&#34; {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=l>plugin_data {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=l>clusters = {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c># NOTE: Change this to your cluster name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s2>&#34;demo-cluster&#34;</span><span class=w> </span><span class=l>= {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=l>use_token_review_api_validation = true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=l>service_account_allow_list = [&#34;spire:spire-agent&#34;]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>KeyManager &#34;disk&#34; {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=l>plugin_data {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=l>keys_path = &#34;/run/spire/data/keys.json&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>Notifier &#34;k8sbundle&#34; {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=l>plugin_data {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>}<span class=w>
</span></span></span></code></pre></div><p>这里有一点需要注意，实际上</p><blockquote><p>the service account token does not contain claims that could be used to strongly identify the node/daemonset/pod running the agent. This means that any container running in an allowed service account can masquerade as an agent, giving it access to any identity the agent is capable of issuing. It is <strong>STRONGLY</strong> recommended that agents run under a dedicated service account.</p></blockquote><p>部署spire-client阶段，spires-agent</p><p>比较有趣的configmap部分我也粘了出来。当客户端成功部署以后，实际上就会</p><pre tabindex=0><code>$ kubectl apply \
    -f agent-account.yaml \
    -f agent-cluster-role.yaml

$ kubectl apply \
    -f agent-configmap.yaml \
    -f agent-daemonset.yaml
</code></pre><p>客户端的attestor，</p><pre tabindex=0><code>   plugins {
      NodeAttestor &#34;k8s_sat&#34; {
        plugin_data {
          # NOTE: Change this to your cluster name
          cluster = &#34;demo-cluster&#34;
        }
      }

      KeyManager &#34;memory&#34; {
        plugin_data {
        }
      }

      WorkloadAttestor &#34;k8s&#34; {
        plugin_data {
          # Defaults to the secure kubelet port by default.
          # Minikube does not have a cert in the cluster CA bundle that
          # can authenticate the kubelet cert, so skip validation.
          skip_kubelet_verification = true
        }
      }

      WorkloadAttestor &#34;unix&#34; {
          plugin_data {
          }
      }
    }
</code></pre><p>最后创建两个spiffe id</p><pre tabindex=0><code>$ kubectl exec -n spire spire-server-0 -- \
    /opt/spire/bin/spire-server entry create \
    -spiffeID spiffe://example.org/ns/spire/sa/spire-agent \
    -selector k8s_sat:cluster:demo-cluster \
    -selector k8s_sat:agent_ns:spire \
    -selector k8s_sat:agent_sa:spire-agent \
    -node
    
$ kubectl exec -n spire spire-server-0 -- \
    /opt/spire/bin/spire-server entry create \
    -spiffeID spiffe://example.org/ns/default/sa/default \
    -parentID spiffe://example.org/ns/spire/sa/spire-agent \
    -selector k8s:ns:default \
    -selector k8s:sa:default
</code></pre><p>参考文章列在下面：</p><ul><li><a href=https://atbug.com/what-is-spiffe-and-spire/ target=_blank>https://atbug.com/what-is-spiffe-and-spire/</a></li><li><a href=https://spiffe.io/docs/latest/spire-about/spire-concepts/ target=_blank>https://spiffe.io/docs/latest/spire-about/spire-concepts/</a></li><li><a href=https://www.jetstack.io/blog/workload-identity-with-spiffe-trust-domains/ target=_blank>https://www.jetstack.io/blog/workload-identity-with-spiffe-trust-domains/</a></li><li><a href=https://blog.fleeto.us/post/something-about-spire/ target=_blank>https://blog.fleeto.us/post/something-about-spire/</a></li></ul><h3 class="relative group">基础安全软件的分析<div id=%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90 aria-label=锚点>#</a></span></h3><h5 class="relative group">Vault<div id=vault class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#vault aria-label=锚点>#</a></span></h5><p>相关的资料很多，毕竟是开源产品。产品资料比较全面，</p><p>产品的优点在于：</p><ul><li>相比其他产品，特意提出了吊销管理<strong>Revocation</strong>，作为自己的一个特色。</li><li>密钥的管理相对而言比较灵活，可以对密钥种类，密钥功能，密钥衍生等进行检索。</li></ul><p>缺点在于：</p><ul><li>根据使用接口来说，使用方式不够灵活，细节不够具体。</li></ul><p>提供的服务包括五个角度：</p><ul><li>安全存储：存储介质上的私钥是加密过的，获得存储介质上的文件并不会导致信息泄露。</li><li>动态密钥生成：根据需求生成不同的密钥，</li><li>数据加密：</li><li>租约和管理：voalt中所有的密钥都有租约关联，租约到期vault自动将之吊销。</li><li>吊销：吊销管理不单独针对具体的密钥，可以针对密钥种类/密钥树等类型。</li></ul><p>这个文章似乎不错，可以用来学习vault的结构</p><p><a href=https://shuhari.dev/blog/2018/02/vault-introduction target=_blank>https://shuhari.dev/blog/2018/02/vault-introduction</a></p><h5 class="relative group">[Self Design Kms]<div id=self-design-kms class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#self-design-kms aria-label=锚点>#</a></span></h5><p>这个产品优点在于：</p><ul><li>它基于实际的角度设计了一款KMS服务，并且提炼出通用KMS服务的基本点，诸如分级密钥，密钥管理</li><li>虽然是在抽象角度，但是很详细地给出了KMS中的具体模块及功能。</li><li>只关注核心部分，易于拓展<ul><li>比方说想在k8s的环境使用，可以使用k8s的crd（这个建议参考vault来做）</li></ul></li></ul><p>缺点在于：</p><ul><li>可以标准化的组件没有利用好，不能提炼成模块。</li><li>依然需要端到端加密来提供通信的安全性</li><li>理论上，为了实现完全的无状态，应该缓存所有的历史的kek和ak，换言之，ak里面存储了对应的kek是谁，这里的kek是谁是一个unique的标识，它并不包含版本信息，如果访问的时候发现这个kek已经过期了，那么应该获取具体的业务当前对应的kek，这样来实现轮转的过程，几个简单的例子，有个业务叫做read-book有个ak叫做readkey1，对应的kek标识是abc-def-hig，然后一直没人用。直到一百年了，read-book服务来读取readkey1，做解密的时候发现kek是abc-def-hig太旧了，就换成当前的kek，然后lazy写入数据库</li></ul><p>密钥分级：</p><ol><li>数据加密密钥(AK):将用于数据加密的密钥,也称三级密钥(AK);一般公司里面一个应用对应一个AK；</li><li>密钥加密密钥(KEK):保护三级的密钥,也称二级密钥(KEK 即对AK进行加密);一般公司里面一个部门对应一个KEK，AK在KEK管辖之内。</li><li>根密钥(RootKey):保护二级密钥的密钥，也称一级密钥(RootKey，即是对KEK进行加密)，根密钥构成了整个密钥管理系统的关键。</li></ol><p>基本架构：</p><ol><li>KMS / PKI的核心应该完全自洽，除了少数的东西之外，要做到完全自洽。建议证书的签发或者核心服务的调用走证书，白名单+mtls</li><li>SDK：主要提供给服务的使用者集成到自己开发的项目中,实现密钥的创建、导入、启用、禁用等相关密钥管理和加密以及解密等常见操作。SDK分为:Client模块、加解密模块，主要负责提供简单接口完成加密解密功能。</li><li>KMS服务：主要负责从<del>硬件安全模块获</del>取和保存根密钥,并且安全地保存在后台内存中,然后通过密钥的派生算法生成KEK进而生成AK。分为，根密钥加载模块、密钥派生模块、Server模块。</li><li>~~HSM：提供根密钥生成和保管服务。~~实际上根本没法买hsm。正常情况应该是kek的生成，解密都是在hsm当中获得，启动的时候将所有的kek做解密，然后放到cache里面。</li></ol><p>待改进：</p><ul><li>数据库里面的密钥应该包含一个meta信息，指定包括版本，密钥等多方面信息</li></ul><p>技术细节：</p><p>对于一级根密钥，推荐使用安全门限算法保证分割安全，这里是指启动的时候必须输入多个用户的秘钥，即必须多个揭密者的密钥都获得的情况下，才能成功解密一级根密钥。</p><p>关于信封加密</p><p>实现：</p><blockquote><p>another method：包裹一层vault</p></blockquote><ul><li><p>具体的客户机器，甚至包括操作数据库的机器，每台机器上存在一个KMS-Agent，每个KMS-Agent有私钥和公钥（证书），握手的时候使用证书私钥校验身份。证书当中包含该KMS-Agent的身份appkey，该KMS-Agent能够获取的秘钥必须都是对该appkey授权的秘钥。KMS-Agent获取的秘钥必须以加密方式存储，数据的结构如下，这里有一点要注意，Environment是环境变量，不会存储在数据结构里，对客户是透明的：</p><table><thead><tr><th>namespace</th><th>name</th><th>encrypted_key</th><th>key_type</th><th>srand</th><th>timestamp</th><th>version</th><th>kms_secret_version</th></tr></thead></table><p>namespace & name用来确定密钥，key_type确定key类型，比方说rsa/ecc/hmac等等，srand为随机数增加随机性，timestamp用来确定加密时间，一起参与到存储中。version用来存储秘钥的版本</p><p>encrypted_key = Encrypted(plan_key)，秘钥为KMS-Agent Secret HKDF with srand & timestamp。kms_secret_version用来在迭代kms密钥时使用。</p><p>这里面有一点要注意，encrypted_key需要使用base64编码，然后存入数据库</p></li><li><p>HSM存储RootKey，可以用来生成二级密钥KEK，加密二级密钥KEK，RootKey从来不出HSM</p></li><li><p>数据库密钥的存储</p><ul><li><p>KEK使用ROOTKEY+SRAND+TIMESTAMP存储于主数据库，</p><table><thead><tr><th>namespace</th><th>encrytped_kek</th><th>key_type</th><th>srand</th><th>timestamp</th><th>environment</th><th>version</th><th>root_version</th><th>owner</th></tr></thead></table><p>一个KEK对应一个namespace下的密钥，encrypted_kek = Encrypted(plan_kek)，加密操作为rootkey HKDF with srand & timestamp。timestamp为生成的日期，version用于轮转，轮转的频率可以设置，每次最多保留两个相邻版本的不同的encrypted_kek，当所有的由老版本的kek保护的具体应用秘钥ak都更新为使用新版本的key之后。老版本的key记录到日志更新操作里面。</p><p>这里面有几点需要注意：</p><ul><li>encrypted_kek使用base64编码存入数据库，方便显示和查看。</li><li>namespace使用uniqueIndex</li><li>kek的duprivated，应该由另外一个程序执行操作取进行废除。不需要自己保证，来降低代码开发的复杂度，aka无状态</li></ul></li><li><p>AK，用户具体使用AK存储各种秘钥</p><table><thead><tr><th>namespace</th><th>name</th><th>encrypted_ak</th><th>key_type</th><th>srand</th><th>timestamp</th><th>environment</th><th>version</th><th>kek_version</th><th>owner</th></tr></thead></table><p>每一个AK都有一个namespace，namespace由KEK保护，encrypted_ak= Encrypted(plan_ak)，加密操作为kek HKDF with srand & timestamp，每个timestamp,srand,都是秘钥自己的属性，和具体使用的kek的timestamp没关系，通过kek_version确定用的哪个kek做保护。</p><p>这里面有三点要注意，encrypted_ak需要使用base64编码，然后存入数据库</p><ul><li>kms agent，即每个docker上面的kms 私钥也是需要存储在数据库当中的，所以还需要一个agent secret table。需不需要证书库呢？</li><li>理论上，不同版本的密钥应该是只做新建，不做更新操作，换言之为了做到完全的无状态，历史的ak（请注意，这里不包括KE）不应该被直接删除，而应该是直接归档为不可用状态，换言之，此时只能管理员检索，而不是历史的数据被删除</li><li>encrypted_ak使用base64编码存入数据库，方便显示和查看。</li><li>namespace，name，version使用uniqueIndex</li></ul></li><li><p>AK授权关系，用来指定授权关系，根据指定具体的appkey来决定是不是授权</p><table><thead><tr><th>namespace</th><th>name</th><th>environment</th><th>ownerappkey</th><th>grantedappkey</th><th>behavior</th></tr></thead></table><p>namespace+name+environment用来指定秘钥是哪个，granted_appkey则指定该appkey可以获取该秘钥，behavior的权限为读和写。不过一帮都是只允许读</p></li><li><p>用户信息</p><table><thead><tr><th>Name</th><th>AppKey</th><th>Cert</th><th>KeyCipherText</th><th>KeyType</th><th>Srand</th><th>TimeStamp</th><th>Version</th><th>KEKVersion</th></tr></thead></table><p>用户信息实际上和普通的Ak非常类似，只不过多了appkey和cert的存储，其中的keyciphertext是密文存储的用户私钥，需要事先创建名为”user“的production的KEK。</p></li></ul></li><li><p>KMS初始化的操作</p><ul><li>初始化数据库的连接和各种内部的数据表</li></ul></li><li><p>为了完全实现无状态</p></li><li><p>部署层面，正常情况，自研KMS/PKI是有一个核心的，这个核心负责签发证书，密钥颁发等关键功能。这个核心是部署的重点，从功能和依赖的角度来说，可以拆为这几个方面</p><ul><li><p>对内：考虑高可用，数据一致性等方面。理论上需要除了对分部署数据库等依赖之外，包括RAM，监控什么的都做到完全的自洽</p><ul><li><p>强依赖：处于高可用的考虑，理论上机房要做双电源，双服务器等多种资源冗余。当然，我做的时候啥都没有。另外，要做到</p><ul><li>数据库，在当前为了保证数据一致性和高可用，如果不想自己去做，数据库可以使用云上分布式数据库。为了保证安全性，数据库有两个必须保证的点：<strong>1 不能明文存储密钥信息 2 必须做访问控制，来限制只能是核心访问，不允许外部访问</strong>。在Q的时候，我没使用高可用性，直接就是一个数据库放到特定机器，访问控制这块是只允许特定的IP连接。</li><li>独立机房 & 网络 & HSM：机房&网络 & 硬件模块要包含多个，做到物理隔离和网络隔离。硬件HSM一般也是和具体的机房在一起，如果为了高可用，确实可能需要多个机房布置存储了同样敏感信息的hsm，hsm的敏感信息同步是一个关键点。原先实现的时候没用hsm，因为不可能给钱买</li></ul></li><li><p>弱依赖</p><ul><li>监控：监控服务的可用性，可用性实际上只做了简单的query探测，</li><li>堡垒机：这个实际上也没做，使用了公司的jumpserver和k8s本身的权限，对机器的特定访问只有少数授权用户可以使用</li><li>日志：日志这部分根据需要做介入，我个人是直接用阿里云k8s那一套</li><li>CI/CD：CI/CD直接嵌入了gitlab基础代码库，可以方便地直接做部署</li></ul></li></ul></li><li><p>对外：</p><ul><li>ha/slb：对外提供服务，使用mtls进行通信。这里我使用的是k8s本身的svc做的。</li></ul></li></ul></li></ul><p>如何构建PKI</p><ul><li><a href=https://insights.thoughtworks.cn/microservices-authentication-token-management/ target=_blank>https://insights.thoughtworks.cn/microservices-authentication-token-management/</a></li><li><a href=https://www.zhaohuabing.com/2018/02/03/authentication-and-authorization-of-microservice/ target=_blank>https://www.zhaohuabing.com/2018/02/03/authentication-and-authorization-of-microservice/</a></li><li><a href=https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/ target=_blank>https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/</a></li><li><a href=https://insights.thoughtworks.cn/tag/security/ target=_blank>https://insights.thoughtworks.cn/tag/security/</a></li><li><a href=https://devops.com/how-to-automate-pki-for-devops-with-open-source-tools/ target=_blank>https://devops.com/how-to-automate-pki-for-devops-with-open-source-tools/</a></li><li><a href=https://www.keyfactor.com/blog/the-4-best-open-source-pki-software-solutions-and-choosing-the-right-one/ target=_blank>https://www.keyfactor.com/blog/the-4-best-open-source-pki-software-solutions-and-choosing-the-right-one/</a></li></ul><h3 class="relative group">[PKI体系建设实践]<div id=pki%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE%E5%AE%9E%E8%B7%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pki%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE%E5%AE%9E%E8%B7%B5 aria-label=锚点>#</a></span></h3><p>对于甲方证书体系管理而言，有诸多实践上的问题，所以记录下遇到的问题和解决方法，最后附上几种开源的CA比较</p><ul><li><p>什么是安全的证书</p><ul><li>声明周期方面：证书需要按照服务类型等方面，针对性的缩短生命周期。</li><li>加解密key类型方面：使用安全的加解密秘钥类型，比方说rsa申请4096字节以上。或者说选择正确的算法</li></ul></li><li><p>证书的安全审计，如何全面地监控证书的使用情况。</p><ul><li>证书的申请实际上是通过在CD的k8s context上面挂载了对应的CD的证书（私钥，身份）什么的，每次签发用哪个做自动化触发。然后直接使用ejbca的cms功能，不过生命周期比较短。</li><li>日志用的是k8s日志那一套，没有进行特别复杂的设计，因为没有那种需要。毕竟每天请求并不多</li></ul></li><li><p>证书如何安全存储：</p></li><li><p>如何对证书做自动化管理：</p><ul><li>企业内部一般是由自己的devops的，因此在CD的时候需要做镜像的机器拥有一张权限较高的证书和私钥，该证书对应的角色需要能够为服务进行证书申请。举个简单的例子，在做CD的POD上挂载阿里云的配置的secret，这个secret的内容就是证书和私钥。这里需要保证这个证书和私钥是绝对不能泄露的。</li><li>对于服务pod上的证书，这个服务pod上面的证书更新实际上就是服务pod自己的任务了，agent可以使用mtls访问证书管理服务申请和自己证书san一致的更新证书。或者使用类似acme等方式来进行更新.</li><li>理论上每个证书应该是颁发一次就直接吊销旧的，不过我们目前没实现这种。直接就是声明周期比较短，直接一周搞定</li></ul></li></ul><p>几种开源的CA对比</p><img src=imgs/open_source_ca.png alt=cve style=zoom:44%><p>四种选择，最简单的还是第一种ejbca，测试环境下的部署。这里注意，在调试情况下是不会有administor的限制的，谁都可以申请证书。因此正常使用需要使用开启了客户端认证的ejbca，然后使用控制台输出的指令，下载证书并且登陆。</p><pre tabindex=0><code>docker run -it --rm -p 80:8080 -p 443:8443 -h qkmsca -e TLS_SETUP_ENABLED=&#34;simple&#34; primekey/ejbca-ce
</code></pre><p>签发证书时，需要提供三种信息</p><ul><li>证书侧写（certificate profile），用来提供证书的限制，比方说可以使用什么key，可以提供什么拓展。<ul><li>一般情况下，证书的用处总是非常限制明显的，比方说用来做client auth，用来做root啥的</li></ul></li><li>终端实体侧写（end entity profile），用来确定哪些信息需要写到证书当中，比方说邮件等等，此外还有提供证书的格式文件啥的类型</li><li>添加终端实体，这里实际上就是手动添加终端实体的过程，添加响应的用户</li></ul><p>EJBCA还有个好处，可以将EJBCA当成一个证书管理系统使用即，CMS</p><p>Q内部目前都没有，还需要调研关于颁发设备证书的东西，参考https://www.zybuluo.com/zhongdao/note/1000973</p><p>参考：</p><p><a href=https://doc.primekey.com/ejbca/tutorials-and-guides/using-ejbca-as-a-certificate-management-system-cms target=_blank>https://doc.primekey.com/ejbca/tutorials-and-guides/using-ejbca-as-a-certificate-management-system-cms</a></p><p>证书管理</p><h4 class="relative group">一些实现的细节<div id=%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BB%86%E8%8A%82 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BB%86%E8%8A%82 aria-label=锚点>#</a></span></h4><p>那么问题来了，零信任怎么和四层的TLS建立起来连接呢？TLS基于四层，因此是其他层面的基石，那么问题来了TLS怎么和零信任契合起来呢？TLS协议实际上是个非常灵活的东西，以下几个点值得关注。</p><h5 class="relative group">10.3.2.0 TLS协议的基本保证<div id=10320-tls%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%9D%E8%AF%81 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10320-tls%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%9D%E8%AF%81 aria-label=锚点>#</a></span></h5><p>由于是从四层来做，因此单调地依赖层提供的保障不再现实：TLS层就要提供身份认证和权限管理的功能，而TLS上层的协议需要能够获取TLS层的身份信息。这意味着上层需要获得已经认证的资源和证书，即上层可以和下层通信。</p><h5 class="relative group">10.3.2.1 TLS基础协议的认证功能<div id=10321-tls%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10321-tls%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD aria-label=锚点>#</a></span></h5><p>针对TLS1.3，TLS协议的基本认证功能主要集中在服务端的证书消息和客户端的证书消息，身份和证书绑定，终端的网络情况可以和具体的拓展或者和心跳包相关联，从而服务器能够检测出是否要再次进行权限校验功能。有一点需要注意，如果开启REUSE功能或者0-RTT功能，那么意味着身份信息需要在SESSION IDENTITY里面记录相关信息，当然这不会造成太大的问题。</p><h5 class="relative group">10.3.2.1 TLS心跳拓展<div id=10321-tls%E5%BF%83%E8%B7%B3%E6%8B%93%E5%B1%95 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10321-tls%E5%BF%83%E8%B7%B3%E6%8B%93%E5%B1%95 aria-label=锚点>#</a></span></h5><p>TLS的心跳拓展是个非常有趣的东西，这个拓展实际上就给上层协议做TLS的状态监测等方面提供了功能，换言之，这个功能使得安全网关能够主动请求并鉴定客户端的网络状态。心跳拓展包的类型为两种： heartbeat_request(1)和heartbeat_response(2)。心跳包的具体格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>心跳协议消息包含了类型</span><span class=err>，</span><span class=n>任意载荷和填充</span><span class=err>。</span><span class=n>结构如下</span><span class=err>：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>HeartbeatMessageType</span><span class=w> </span><span class=n>type</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>uint16</span><span class=w> </span><span class=n>payload_length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>opaque</span><span class=w> </span><span class=n>payload</span><span class=o>[</span><span class=n>HeartbeatMessage</span><span class=p>.</span><span class=na>payload_length</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>opaque</span><span class=w> </span><span class=n>padding</span><span class=o>[</span><span class=n>padding_length</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w> </span><span class=n>HeartbeatMessage</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>心跳消息的总长度不能超过2</span><span class=o>^</span><span class=n>14或者规定的最大分片单元的长度</span><span class=err>。</span><span class=w>
</span></span></span></code></pre></div><p>这意味着我们可以在心跳包当中嵌入任意长度的消息，只要保证安全性就可以解决问题。</p><p>接收方要告诉对方一个告警消息“illegal_parameter这个行为也可以用来记录相关的安全信息。</p><p>从简单的角度来说，对心跳包的拓展是最简单的检查功能。</p><p>具体内容参考RFC 6520https://tools.ietf.org/html/rfc6520和RFC8447https://tools.ietf.org/html/rfc8447。</p><h4 class="relative group">10.3.2.2 TLS自定拓展<div id=10322-tls%E8%87%AA%E5%AE%9A%E6%8B%93%E5%B1%95 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10322-tls%E8%87%AA%E5%AE%9A%E6%8B%93%E5%B1%95 aria-label=锚点>#</a></span></h4><p>在TLS1.3中自定拓展是个非常有趣的事情。EncryptedExtension和ClientHello都能加入拓展，CLientHello中可以使用明文，当然如果算上0-RTT报文当中包含权限或拓展信息就很有趣。</p><h4 class="relative group">10.3.2.2 TLS PHA功能和安全重协商<div id=10322-tls-pha%E5%8A%9F%E8%83%BD%E5%92%8C%E5%AE%89%E5%85%A8%E9%87%8D%E5%8D%8F%E5%95%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10322-tls-pha%E5%8A%9F%E8%83%BD%E5%92%8C%E5%AE%89%E5%85%A8%E9%87%8D%E5%8D%8F%E5%95%86 aria-label=锚点>#</a></span></h4><p>TLS1.3的PHA功能简直是对从新认证的完美实现，只要客户端带PHA_HANDSHAKE_AUTH拓展，那么服务器可以在任意时刻发送PHA认证消息，客户端必须按照符合格式的方式回复。当然可能服务器在收到认证报文之前可能受到大量无意义报文，这个情况要注意。</p><p>但是PHA只是身份认证相关的工作，无法包含更多的其他信息，因此对于零信任的场景安全重协商更靠谱，可以重新产生相应的身份信息和拓展信息。</p><h3 class="relative group">云原生安全<div id=%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8 aria-label=锚点>#</a></span></h3><h3 class="relative group">1 从底层linux说起<div id=1-%E4%BB%8E%E5%BA%95%E5%B1%82linux%E8%AF%B4%E8%B5%B7 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%E4%BB%8E%E5%BA%95%E5%B1%82linux%E8%AF%B4%E8%B5%B7 aria-label=锚点>#</a></span></h3><h4 class="relative group">1.1 权限模型方面<div id=11-%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B%E6%96%B9%E9%9D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B%E6%96%B9%E9%9D%A2 aria-label=锚点>#</a></span></h4><p>linux为了应对权限问题，引入了一种新的权限控制模型，叫做capabilities，这种模型主要的特点是<strong>将一些特权划分成了不同的单元，并且可以灵活*<em>**地**</em>*控制其独立或者组合进行启用或禁用</strong>。参考https://www.man7.org/linux/man-pages/man7/capabilities.7.html</p><p>capabilities 当前作为每个线程的属性存在，也可以作用在可执行文件上。实际上使用docker作为我们运行的环境的时候，其权限就是通过设置下面的东西来确定的</p><ul><li>如果用作线程属性存在，我们称之为 Thread capability sets；<ul><li><strong>第一个集合，Permitted</strong>。它不会直接影响到线程的 capability，而是<strong>作为一个约束，定义了线程最多能使用的 capability 集合的上限</strong>。对于线程而言，它可以通过 <code>capset()</code> 这样的系统调用来对 Inheritable 和 Effective 集合进行 capability 的增加或者删除，但是所操作的这些 capability 必须先定义在 Permitted 集合中，不过也会受到 Bounding 集合的一些影响。当然，如果想要真正能通过 <code>capset()</code> 系统调用来操作 Inheritable 集合的话，也需要保证其 Effective 集合中有 <code>CAP_SETPCAP</code> 的 capability 。</li><li><strong>第二个集合，Inheritable</strong>。它主要定义了一组跨 <code>execve(2)</code> 系统调用时<strong>可继承的 capability 集合</strong>。但是它的影响是会将 Inheritable 集合中的 capability 应用于新线程的 Permitted 集合中，而非直接设置成新线程的 Effective 集合。</li><li><strong>第三个集合，Effective</strong>。它<strong>定义了线程可执行的全部特权</strong>。内核对线程执行特权操作时的检查便是去检查 Effective 集合。前面我们提到 Permitted 集合定义了线程最多能使用的 capability 集合的上限，所以可以通过删除线程 Effective 集合中的 capability 来达到禁用 capability 的目的。当然，后续也可以再从 Permitted 集合进行恢复。</li><li><strong>第四个集合，Bounding</strong>。它<strong>定义了可被继承的 capability 集合的超集</strong>，类似于 Permitted 之于 Effective。如果一个 capability 存在于 Inheritable 中，但未定义在 Bounding 集合中，那该 capability 同样是无法进行继承的。在 Linux 2.6.25 版本之前，这是一个系统级别的全局属性；自 Linux 2.6.25 之后，它成为了每个线程独立的属性。</li><li><strong>第五个集合，Ambient</strong>。它是<strong>对 Inheritable 集合的一种补充</strong>，从 Linux 4.3 开始引入。如果一个 capability 未在 Permitted 和 Inheritable 集合中设置，那么 Ambient 集合也不能进行设置。但如果某个 capability 已经添加到了线程的 Ambient 集合中，那么当它执行 <code>fork()</code> 和 <code>execve(2)</code> 系统调用时，便可自动继承下去。</li></ul></li><li>如果用作可执行文件的扩展属性上，则称之为 File capability sets。<ul><li><strong>第一个集合，Permitted</strong>。它定义的 capability 会自动添加到线程的 Permitted 集合中，但最终线程的 Permitted 集合中的 capability 实际上是它与线程的 Bounding 集合取交集的结果。</li><li><strong>第二个集合，Inheritable</strong>。它定义的 capability 会与线程的 Inheritable 取交集，然后添加到 <code>execve(2)</code> 产生的线程 Permitted 集合中。</li><li><strong>第三个集合，Effective</strong>。它并不是一个真正的 capability 集合，它仅仅是一个标志位。如果设置为开启，那么在 <code>execve(2)</code> 系统调用执行后，线程 Permitted 集合中的 capability 将被同时设置到 Effective 集合中。</li></ul></li></ul><h4 class="relative group">1.2 资源隔离<div id=12-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#12-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB aria-label=锚点>#</a></span></h4><p><strong>对于容器化技术而言，实现资源的隔离和限制是其核心</strong>，上面的权限控制只是执行相关，而<strong>资源隔离主要使用 namespace 完成</strong>，因此linux启用了cgroup。</p><p>具体的cgroup可以参考目录<code>/sys/fs/cgroup</code> 下包含很多可供选择的资源目录。比方说如下图。可以针对性想限制的资源文件夹下面创建对应的新cgroup。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>qcraft@BJ-vgdog:~/qcraft$ ls -l -a  /sys/fs/cgroup/
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>15</span> root root <span class=m>380</span> 2月  <span class=m>13</span> 11:42 .
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>11</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 ..
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>5</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 blkio
</span></span><span class=line><span class=cl>lrwxrwxrwx  <span class=m>1</span> root root  <span class=m>11</span> 2月  <span class=m>13</span> 11:42 cpu -&gt; cpu,cpuacct
</span></span><span class=line><span class=cl>lrwxrwxrwx  <span class=m>1</span> root root  <span class=m>11</span> 2月  <span class=m>13</span> 11:42 cpuacct -&gt; cpu,cpuacct
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>5</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 cpu,cpuacct
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>3</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 cpuset
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>6</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 devices
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>4</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 freezer
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>3</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 hugetlb
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>5</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 memory
</span></span><span class=line><span class=cl>lrwxrwxrwx  <span class=m>1</span> root root  <span class=m>16</span> 2月  <span class=m>13</span> 11:42 net_cls -&gt; net_cls,net_prio
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>3</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 net_cls,net_prio
</span></span><span class=line><span class=cl>lrwxrwxrwx  <span class=m>1</span> root root  <span class=m>16</span> 2月  <span class=m>13</span> 11:42 net_prio -&gt; net_cls,net_prio
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>3</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 perf_event
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>5</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 pids
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>2</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 rdma
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>6</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 systemd
</span></span><span class=line><span class=cl>dr-xr-xr-x  <span class=m>6</span> root root   <span class=m>0</span> 2月  <span class=m>13</span> 11:42 unified
</span></span></code></pre></div><p>在容器环境中实际上docker已经按照cgroup啥的给配置了资源配比，</p><p><strong>总之，cgroup 的出现满足了容器对于资源配额管理的需求，同时我们可以通过使用 cgroup 对进程资源进行非常方便的资源限制，以免进程之间出现资源抢占的问题。</strong></p><p>在容器环境中，cgroup 的使用频率非常高，对于 Kubernetes 环境，也建议你对 Pod 进行 request 和 limit 的限制（实际上底层还是 cgroup 在起作用）。</p><h4 class="relative group">1.3 namespace隔离<div id=13-namespace%E9%9A%94%E7%A6%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-namespace%E9%9A%94%E7%A6%BB aria-label=锚点>#</a></span></h4><p>namespace。主要是为了让该系统中的每个进程组通过拥有自己独立的 namespace 抽象，以达到这些<strong>进程组之间的文件系统彼此隔离、互不可见</strong>的目的。</p><p>namespace 有很多种，目前已经实现的有 8 种：Network、PID、Mount、IPC、UTS、User、cgroup 和 Time。</p><h3 class="relative group">2 云原生安全<div id=2-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8 aria-label=锚点>#</a></span></h3><h4 class="relative group">2.1 云原生安全<div id=21-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#21-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8 aria-label=锚点>#</a></span></h4><p>针对runtime安全，一般是两种情况</p><ul><li>事前<ul><li>直接镜像内添加非root用户</li><li>镜像内不允许让root用户运行</li></ul></li><li>事后<ul><li>falco，https://falco.org/</li></ul></li></ul><p>如果希望从容器内部就开始进行安全防护，那么需要关注</p><ul><li>容器镜像内容安全性的保障；<ul><li>简单来说就是SBOM 就是一份可用于表明 <strong>用于构建软件的相关组件及其依赖项的详细信息及软件自身元数据信息</strong> 的清单文件。保证产品完整性，保证供应链安全管理<ul><li>如何生成SBOM，使用syft</li><li>如何扫描SBOM，使用grype，输入syft输入的json文件</li></ul></li><li>使用trivy进行镜像安全扫描</li></ul></li><li>容器镜像分发过程中的安全性保障。</li><li>关于安全容器<ul><li>gvisor</li><li>kata containers</li><li>fire cracker</li></ul></li></ul><h4 class="relative group">2.2 kubernetes安全<div id=22-kubernetes%E5%AE%89%E5%85%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#22-kubernetes%E5%AE%89%E5%85%A8 aria-label=锚点>#</a></span></h4><p>在 Kubernetes 中所有的请求都需要经过 kube-apiserver，而 kube-apiserver 最基础的功能就是按照请求路径对请求进行处理和路由。在此之后，会分别进行认证（Authentication）和授权（Authorization）的逻辑，再之后会有准入控制器（Admission controller）等进行处理，经过这一系列处理，请求才能与 ETCD 中的数据进行交互。</p><ul><li>X509 客户端证书：这种方式使用很频繁，多数时候我们使用 kubectl 命令行工具和 Kubernetes 集群交互时候也是使用这种方式进行认证。</li><li>service account：<ul><li>Service Account 是 Kubernetes 集群内认证最关键的一环，它是进行 JWT 认证的主体。默认情况下，Kubernetes 会为每个 Pod 指定一个名为 <code>default</code> 的 Service Account，并且在 Pod 内挂载该 Service Account 与 kube-apiserver 的认证凭据。</li><li>想要为 ServiceAccount 进行授权，主要会涉及到以下两类资源。<ul><li><code>Role</code> 和 <code>ClusterRole</code>：这两个资源的区别是前者为 Namespace 范围的，后者是 Cluster 级别的。它们用于定义角色，以及角色所具备的权限。</li><li><code>RoleBinding</code> 和 <code>ClusterRoleBinding</code>：这两个资源的区别是前者为 Namespace 范围的，后者是 Cluster 级别的。它们用于将角色和 Kubernetes 中具体的"用户"/&ldquo;身份"进行绑定，完成授权。</li><li>最终还是要涉及到token request</li></ul></li></ul></li><li>基于 OpenID Connect Token</li></ul><h3 class="relative group">2.3 回到DEVSECOPS<div id=23-%E5%9B%9E%E5%88%B0devsecops class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#23-%E5%9B%9E%E5%88%B0devsecops aria-label=锚点>#</a></span></h3><p>参考如下：</p><ul><li><p>Static Application Security Testing</p></li><li><p>syft+grype做安全分析，实际上还真的发现了一些有趣的东西</p><img src=imgs/cve_repot.jpeg alt=cve style=zoom:44%></li><li><p>Trivy</p></li></ul><h2 class="relative group">2.0 云安全<div id=20-%E4%BA%91%E5%AE%89%E5%85%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#20-%E4%BA%91%E5%AE%89%E5%85%A8 aria-label=锚点>#</a></span></h2><h3 class="relative group">2.1 云扫描<div id=21-%E4%BA%91%E6%89%AB%E6%8F%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#21-%E4%BA%91%E6%89%AB%E6%8F%8F aria-label=锚点>#</a></span></h3><p>云扫描包含多个部分，包含资产扫描，漏洞扫描，网站扫描和安全配置扫描。现在一部分企业连清楚自己有哪些东西都不知道</p><ul><li>资产扫描，发现企业内部资产和互联网报路面为主<ul><li>需要回答企业的核心资产是什么</li><li>扫描内容包含企业的各种核心资产，除了硬件资源还包括软件资源，数据等，总结来说是硬件资产和软件资产</li><li>除了常规的内网icmp扫描，还可以通过网络层流量，云环境开放接口</li></ul></li><li>漏洞扫描<ul><li>需要衡量漏洞的严重程度</li></ul></li><li>网站扫描<ul><li>主要针对网站引用，做黑河扫描</li></ul></li><li>安全配置扫描<ul><li>针对不同平台的安全配置扫描，比方说服务器，数据库等</li></ul></li></ul><p>下面给一些开源的扫描工具</p><p>资产扫描工具</p><ul><li>NMAP，扫描主机和开放端口，确定哪些服务在运行，推测主机平台等信息</li><li>ZMAP</li><li>MASSCAN</li></ul><p>漏洞扫描工具</p><ul><li>openvas</li><li>nessus</li></ul><p>网站扫描</p><ul><li>nikto</li><li>sqlmap</li><li>xsser</li></ul><p>安全配置扫描</p><ul><li>lynis</li></ul><h3 class="relative group">2.3 云防护<div id=23-%E4%BA%91%E9%98%B2%E6%8A%A4 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#23-%E4%BA%91%E9%98%B2%E6%8A%A4 aria-label=锚点>#</a></span></h3><p>安全攻击层出不穷，从防御的角度，需要有防御的工具，因此出现了WAF，和防火墙一样WAF保护的是网站类应用，其目标是防御逐入，xss，cc工具，</p><p>一些开源的云waf工具</p><ul><li>modsecurity，nginx+modsecurity</li><li>openresty+ngx_lua_waf</li></ul><h3 class="relative group">2.4 云SIEM<div id=24-%E4%BA%91siem class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#24-%E4%BA%91siem aria-label=锚点>#</a></span></h3><p>检测和分析中心</p><h2 class="relative group">3 数据安全实践<div id=3-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5 aria-label=锚点>#</a></span></h2><p>数据安全能力成熟度模型（Data Security Capability Maturity Mode,简称<em>DSMM</em>）是阿里的一套模型，一般来说按照下面的方面进行分类。如果从通用的角度来管理，还需要注意几个细节方面：1 合规管理，需要专门的法务和技术人员对数据合规的法律法规进行对自身数据的分析 2 数据资产管理 3 元数据管理，这里面之所以单独提出来元数据，是因为元数据是数据最外层的表现，也是敏感的终端</p><ol><li><p>数据采集安全</p><ul><li>数据分级分类机制安全管理，需要能够。**工具方面需要有相应的数据资产管理工具，实现对数据分类分级自动进行标示。**分类可以按照业务，关系，内容进行分类。分级可以按照价值，敏感程度，司法影响范围分级。比方说可以拆分为非敏感数据，敏感数据，涉密数据。里面还可以继续拆分为公开，首先公开，内部使用，限制使用，审核公开，保密管理，禁止公开。不过这些流程是可以慢慢拓展的，不是必须不变的<ul><li>根据数据不同的级别指定不同的标示和管理</li><li>应对不同类别和级别的数据建立相应的访问控制，数据加解密，数据脱敏</li><li>明确等级变更的流程，因为数据级别可能会发生改变，因此需要明确等级变更的流程</li></ul></li><li>数据采集安全管理，工具方面需要有详细的日志记录功能，<strong>确保数据采集和授权过程中记录的完整性</strong><ul><li>明确数据源，频度，渠道，方式，数据防伪和类型进行风险评估。</li><li>给出明确的数据采集原则，定义业务的数据采集流程和方法。同时对外部数据源的合法性进行辨认。</li><li>确保采集过程中的个人信息和重要数据不泄露</li></ul></li><li>数据源鉴别及记录<ul><li>能够认证数据源</li><li>对数据需要做到能够数据溯源，即可以通过打标的方式或者是逆向函数的方式</li></ul></li><li>数据质量管理</li></ul></li><li><p>数据传输安全</p><ul><li>数据传输加密，<strong>工具部分要对数据完整性做检测，部署对通道安全配置，密码算法配置，密钥管理等手段做审核和监控的技术</strong><ul><li>明确数据传输的安全要求，比方说传输通道加密，数据内容加密</li><li>网络可用性管理，这个需要保证网络对抗入侵，数据泄漏等方面攻击</li></ul></li></ul></li><li><p>数据存储安全</p><ul><li>该部分主要保证数据完整性，保密性和可用性即CIA三个方面<ul><li>存储物理介质的安全</li><li>存储逻辑介质的安全**，明确各数据逻辑存储介质的管理员，由其负责执行数据逻辑存储系统，系统设备的安全管理和运维工作。要明确存储系统的账号权限管理，访问控制，日志管理，加密管理。要确保数据租户是相互隔离的**</li><li>数据备份和恢复，明确数据备份和恢复的管理制度；明确数据备份和恢复的频率，防伪，工具过程，日志记录，数据保存市场；明确归档数据的压缩或者加密要求；明确授权管控，非授权人员不得访问</li></ul></li></ul></li><li><p>数据处理安全</p><ul><li>脱敏</li><li>分析</li><li>保证数据正当使用，完全隔离用户，整个过程透明最简单</li><li>终端安全，需要保证数据使用的终端是安全的，也是一个复杂的话题</li></ul></li><li><p>数据交换安全。我们必须能够对数据进行审批和授权，确定数据的范围/类型/内容/格式/.</p><ul><li>数据共享安全<ul><li>保证数据共享的原则和安全规范，明确数据使用者的安全责任和安全防护能力</li></ul></li><li>数据发包安全<ul><li>明确数据公开内容，适用范围及规范，明确发布者和使用者的权利和义务</li></ul></li><li>数据接口安全<ul><li>明确数据接口安全访问控制策略，明确接口的安全限制和安全控制策略，比方说使用身份鉴别，访问控制，授权策略，签名，时间戳等</li><li>明确接口名称，接口参数等</li><li>明确数据的使用目的，供应方式，保密约定等</li></ul></li></ul></li><li><p>数据销毁安全</p></li></ol><h3 class="relative group">[Q数据保护方案]<div id=q%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#q%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88 aria-label=锚点>#</a></span></h3><p>长久以来，诸如run数据，保密数据全都是以明文方式放在阿里云OSS上，在数据传递/使用的过程中极易造成数据的泄露，因此需要提供数据安全的方案。利用已经存在的KMS方案，可以建立对应的授权和保密机制。类比金钱交易，现金就是具体的数据，银行卡就是生成的token，token可以无负担地在服务之间流转</p><ul><li>生成方调用数据加密服务保存run数据，提供数据名字参数（数据名字需包含逻辑含义）；数据加密服务返回一个token，代指该数据<ul><li>数据加密服务使用使用方的名字/服务名字为kek（namepsace），数据名字为name，生成一个秘钥，存储到kms中。</li><li>使用该namespace（kek）和name生成的秘钥（ak），对数据进行加密。加密完成后做hash生成token。需要保存该token和，namepsace & name的对应关系，方便检索。这里ldap就有用了</li></ul></li><li>生成方获取该token后就可以将token代指数据，传递给具体使用方，整个数据在传递过程当中没有明文传递的。<ul><li>token需要提供数据匿名的功能，即不暴露数据拥有者和使用者的信息</li></ul></li><li>使用方获得token之后，向数据生成方请求token数据的授权，从而进行解密<ul><li>token数据的授权读取需要拆分为两个部分，授权的部分实际上是授权kms里面的某个秘钥给使用方可读</li><li>token对应的数据的读取应该是发送密文到使用方本地，然后使用方利用授权拿到的秘钥做解密</li></ul></li></ul><p>这种方案的优点为</p><ul><li>token对应为kms，可以轻松的轮转秘钥等东西</li><li>可以轻松的生成文件分享的途径，到期进行文件的管控，比方说删除</li></ul><p>这种方案的缺点为</p><ul><li>数据不可轻易分割</li></ul><p>信封加密</p><ul><li>用户发送（创建）一个KEK。利用该KEK生成对应的AK，并使用KEK加密，将加密以后的AK密文和AK明文一起返回给用户</li><li>用户使用AK的明文做加密，将数据密文和加密的秘钥一起存储。销毁明文秘钥</li><li>用户存储密文秘钥和密文文件一起存储到本地</li><li>用户使用的时候调用KEK解密密文秘钥，拿到明文秘钥解密即可</li></ul><p>如果提供给外部，原始数据应当包含一些冗余信息（二进制格式的grpc proto可以非常方便的添加容易），这些冗余信息为第三方身份信息。使用流程如下</p><ul><li>数据做加密存储，加密使用的秘钥使用KEK做加密后和密文数据放到一起，存储于云上或者某个地方</li><li>用户调用提供的接口，（它需要有一个身份或者说证书什么的）从我们的KMS服务拿到对应的KEK对加面的秘钥做解密之后，开始解密相应的文件</li><li>以上操作应该发生在数据的接入层，也就是说整个过程除了用户的身份信息，对用户都是透明的。</li></ul><p>参考下四维的敏感地图是怎么使用的</p><p>与“使用STS临时访问凭证访问OSS”结合的数据保护方案，</p><p>终端用户应该使用软件内嵌证书来控制最末端的身份认证体系，通过证书进行管理</p><p>一些问题</p><ul><li>PKI设计部分：证书精确的粒度到底是什么？文档里面写的是车端VIN+ECU，这是说不同的板子使用不同的证书吗？车端业务后段是都一张证书，不做具体的区分吗？</li><li>CA及证书层级：只有这么几层吗？中间CA的层级有多少？另外trustbundle这么交换</li><li>证书签名：上传CSR是说提供托管公钥，私钥不存储的能力吗？如果不提供，云端是否要保存私钥？提供什么能力？</li><li>证书本身的签发不是什么问题，但是证书的安全使用，存储才是关键，如果cover？以后再设计？likey cover</li><li>DK，DK的meta表里面为什么没有对应kek的版本？我理解kek是有中间态的吧？</li><li></li></ul><h2 class="relative group">结尾<div id=%E7%BB%93%E5%B0%BE class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BB%93%E5%B0%BE aria-label=锚点>#</a></span></h2><p>唉，尴尬</p><p><figure><img class="my-0 rounded-md" loading=lazy src=https://i.loli.net/2020/08/27/BFHNyfpx3EsIDUG.jpg alt=狗头的赞赏码.jpg></figure></p></div></div><script>var oid="views_posts\\2023-02-12-安全零信任\\index.md",oid_likes="likes_posts\\2023-02-12-安全零信任\\index.md"</script><script type=text/javascript src=/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q+oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/2021-01-31-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">汇编笔记</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2021-01-31T00:00:00+00:00>2021 年 1 月 31 日</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/posts/2021-02-22-%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B0%E5%AD%A6+%E5%8D%8F%E8%AE%AE%E7%AF%87/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">2021-02-22-安全方面的基础知识（数学+协议篇）</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2021-02-22T00:00:00+00:00>2021 年 2 月 22 日</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">© 2025 - 2025 菜狗 All Rights Reserved.</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://hxndg.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>