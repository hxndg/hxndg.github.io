<!doctype html><html lang=cn dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>2023-03-31-架构之路 &#183; 菜狗的blog</title>
<meta name=title content="2023-03-31-架构之路 &#183; 菜狗的blog"><meta name=description content="菜狗's website"><meta name=keywords content="架构,"><link rel=canonical href=https://hxndg.github.io/posts/2023-03-31-%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/><link type=text/css rel=stylesheet href=/css/main.bundle.min.ba3775bebd52a2b4837f8da64e32ee36e5c52bf284a0ce2262562782398b701543947527ad1498487717b1b96fe2a4e48d365a02e0b5d00e224893052e99d83c.css integrity="sha512-ujd1vr1SorSDf42mTjLuNuXFK/KEoM4iYlYngjmLcBVDlHUnrRSYSHcXsblv4qTkjTZaAuC10A4iSJMFLpnYPA=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.764eb2fe8d6a6b086c7c58f87d12c64fa79a7585117fc27eb53f688f80c287a6eff16277f9d186cd223a39ff700e294d64482834faece5e07ee0498fa042d056.js integrity="sha512-dk6y/o1qawhsfFj4fRLGT6eadYURf8J+tT9oj4DCh6bv8WJ3+dGGzSI6Of9wDilNZEgoNPrs5eB+4EmPoELQVg==" data-copy data-copied></script><script src=/lib/zoom/zoom.min.3530c2657381259433194af312ec3d322a97a2ad85661810299757fe793b24c3b8e07ab97fa8e5cf96cff1208f271e75394b6eaa56c2e39e7e2c3ca49fb1921c.js integrity="sha512-NTDCZXOBJZQzGUrzEuw9MiqXoq2FZhgQKZdX/nk7JMO44Hq5f6jlz5bP8SCPJx51OUtuqlbC455+LDykn7GSHA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://hxndg.github.io/posts/2023-03-31-%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"><meta property="og:site_name" content="菜狗的blog"><meta property="og:title" content="2023-03-31-架构之路"><meta property="og:description" content="菜狗's website"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-28T00:00:00+00:00"><meta property="article:tag" content="架构"><meta property="og:image" content="https://hxndg.github.io/posts/2023-03-31-%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/featured.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hxndg.github.io/posts/2023-03-31-%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/featured.png"><meta name=twitter:title content="2023-03-31-架构之路"><meta name=twitter:description content="菜狗's website"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"2023-03-31-架构之路","headline":"2023-03-31-架构之路","inLanguage":"zh-cn","url":"https:\/\/hxndg.github.io\/posts\/2023-03-31-%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF\/","author":{"@type":"Person","name":"菜狗"},"copyrightYear":"2023","dateCreated":"2023-03-28T00:00:00\u002b00:00","datePublished":"2023-03-28T00:00:00\u002b00:00","dateModified":"2023-03-28T00:00:00\u002b00:00","keywords":["架构"],"mainEntityOfPage":"true","wordCount":"18231"}]</script><meta name=author content="菜狗"><script src=/lib/jquery/jquery.slim.min.03cb160e3cfdb2667a2e2c80d283bebcf63ff8bbc4b629c9ab2babf6fae1d0c07ad470edae783efa4fabda2ac01c58d60e63b98b3c336be8208460f08f4354f5.js integrity="sha512-A8sWDjz9smZ6LiyA0oO+vPY/+LvEtinJqyur9vrh0MB61HDtrng++k+r2irAHFjWDmO5izwza+gghGDwj0NU9Q=="></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">菜狗的blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Home</p></a><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Posts</p></a><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Tags</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Home</p></a></li><li class=mt-1><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Posts</p></a></li><li class=mt-1><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Tags</p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div id=hero class="h-[150px] md:h-[200px]"></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/posts/2023-03-31-%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/featured_hu4370388524629176199.png)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral-100 dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">2023-03-31-架构之路</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2023-03-28T00:00:00+00:00>2023 年 3 月 28 日</time><span class="px-2 text-primary-500">&#183;</span><span>18231 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>37 分钟</span></div></div><div class="flex author"><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">菜狗</div><div class="text-sm text-neutral-700 dark:text-neutral-400">Focus</div><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#0-架构的基本思路>0 架构的基本思路</a></li><li><a href=#05-clean-architecture-zh学习>0.5 Clean-Architecture-zh学习</a><ul><li><a href=#2-两个价值观>2 两个价值观</a></li></ul></li><li><a href=#3-编程范式>3 编程范式</a><ul><li><a href=#4-设计准则>4 设计准则</a></li><li><a href=#5-设计方法>5 设计方法</a><ul><li><a href=#51-ddd>5.1 DDD</a></li><li><a href=#52-add>5.2 ADD</a></li></ul></li></ul></li><li><a href=#1-远程服务>1 远程服务</a><ul><li><a href=#11-rpc的可靠性问题>1.1 RPC的可靠性问题</a></li><li><a href=#12-rpc要解决的问题>1.2 RPC要解决的问题</a></li><li><a href=#13-rest>1.3 REST</a></li></ul></li><li><a href=#2-事务处理>2 事务处理</a></li><li><a href=#3-流量治理分级与分流>3 流量治理（分级与分流）</a><ul><li><a href=#31-服务容错>3.1 服务容错</a><ul><li><a href=#311-容错策略>3.1.1 容错策略</a></li><li><a href=#312-容错设计模式>3.1.2 容错设计模式</a></li><li><a href=#313-流量控制>3.1.3 流量控制</a></li></ul></li></ul></li><li><a href=#架构安全>架构安全</a></li><li><a href=#2-k8s学习笔记>2 K8S学习笔记</a><ul><li><a href=#21-基本概念>2.1 基本概念</a></li><li><a href=#22-核心组件运行原理>2.2 核心组件运行原理</a></li><li><a href=#23-节点调度相关>2.3 节点调度相关</a></li><li><a href=#24-安全机制>2.4 安全机制</a></li><li><a href=#25-kubernetes运维管理>2.5 kubernetes运维管理</a></li><li><a href=#26-kubernetes开发>2.6 kubernetes开发</a></li></ul></li><li><a href=#3-云工程师>3 云工程师</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#0-架构的基本思路>0 架构的基本思路</a></li><li><a href=#05-clean-architecture-zh学习>0.5 Clean-Architecture-zh学习</a><ul><li><a href=#2-两个价值观>2 两个价值观</a></li></ul></li><li><a href=#3-编程范式>3 编程范式</a><ul><li><a href=#4-设计准则>4 设计准则</a></li><li><a href=#5-设计方法>5 设计方法</a><ul><li><a href=#51-ddd>5.1 DDD</a></li><li><a href=#52-add>5.2 ADD</a></li></ul></li></ul></li><li><a href=#1-远程服务>1 远程服务</a><ul><li><a href=#11-rpc的可靠性问题>1.1 RPC的可靠性问题</a></li><li><a href=#12-rpc要解决的问题>1.2 RPC要解决的问题</a></li><li><a href=#13-rest>1.3 REST</a></li></ul></li><li><a href=#2-事务处理>2 事务处理</a></li><li><a href=#3-流量治理分级与分流>3 流量治理（分级与分流）</a><ul><li><a href=#31-服务容错>3.1 服务容错</a><ul><li><a href=#311-容错策略>3.1.1 容错策略</a></li><li><a href=#312-容错设计模式>3.1.2 容错设计模式</a></li><li><a href=#313-流量控制>3.1.3 流量控制</a></li></ul></li></ul></li><li><a href=#架构安全>架构安全</a></li><li><a href=#2-k8s学习笔记>2 K8S学习笔记</a><ul><li><a href=#21-基本概念>2.1 基本概念</a></li><li><a href=#22-核心组件运行原理>2.2 核心组件运行原理</a></li><li><a href=#23-节点调度相关>2.3 节点调度相关</a></li><li><a href=#24-安全机制>2.4 安全机制</a></li><li><a href=#25-kubernetes运维管理>2.5 kubernetes运维管理</a></li><li><a href=#26-kubernetes开发>2.6 kubernetes开发</a></li></ul></li><li><a href=#3-云工程师>3 云工程师</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><script>var margin=200,marginError=50;(function(){var t=$(window),e=$("#TOCView"),s=e.height();function n(){var n=t.height()-margin;s>=n?(e.css("overflow-y","scroll"),e.css("max-height",n+marginError+"px")):(e.css("overflow-y","hidden"),e.css("max-height","9999999px"))}t.on("resize",n),$(document).ready(n)})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><h1 class="relative group">架构之路<div id=%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF aria-label=锚点>#</a></span></h1><p>经历</p><ul><li>华耀面临的难题是非常具体的技术问题，面向协议，语言层面。需要对tls，密码学基础知识，计算机体系结构比较熟悉。一个难题的例子是移植ZX5580CPU遇到的汇编无符号证书除法稳定出错的问题，表现形式为证书生成失败，难度在于从私钥/公钥计算，证书签发中等一系列流程怎么精确找到出错的地点，毕竟出错的地方是一个特定条件才会触发的div汇编除法错误。<ul><li>技术实现<ul><li>标记用户可用的行为，规定哪些行为是安全的，哪些行为是不安全的，并且将各种行为记录日志。这种行为是不能过于破坏安全特性的。</li><li>从实现者的角度，保证安全准则/逻辑没有漏洞，不会泄露客户的敏感信息。实际上我们自己规定了一些准则，按照这些准则执行开发。</li><li>从产品的角度，来提供一个完整系统，保证端到端加密，它的逻辑/设计理念必须是连续的。（比方说我们对0-RTT的争吵）</li><li>针对单独产品，怎么实现稳定性和可靠性的考虑<ul><li>硬件方面<ul><li>磁盘RAID，双路电源。</li></ul></li><li>软件层面<ul><li>针对错误的输入，比方说一些奇特的mbuf数据包（网络数据包）会对数据的格式做校验（我们系统出过几次coredump）。此外会限制ICMP PING RESPONSE的数量为200/s</li><li>针对失控程序占用一些CPU资源，内存，磁盘，网络空间和网络的问题，我们的进程在每个核上每隔一段时间就回去喂狗，软的watchdog。如果一定时间watchdog没有喂到，就会出发NMI，从而系统PANIC进而重启。</li><li>针对系统依赖的服务变慢，实际上不单纯是依赖的服务，对ATCP而言，还包括后面的服务。我们会有一个其他的进程定期去检查后面服务的状态，如果采用最短有效，那么就回去访问当前最高可用的机器。除此之外还有特定的健康检查进程去更新后台RS的状态，如果后台RS无效，那么我们会直接拒绝让rs的连接走这个服务，提供可靠性。</li><li>会有一个守护进程去检查进程的活跃状态，如果某个工作进程挂掉了，那么会被守护进程拉起来。</li><li>针对异常问题，我们统一了错误码，整体都是RST报文里面的WIN字段</li><li>针对安全1，无论是客户端证书还是后面的rs（尤其是双向，）复用的时候我们会比较客户端TICKET IDENTITY LIFETIME和我们的TICKET IDENTITY LIFETIME的差别，如果过大我们就拒绝复用（复用不需要证书），让它走完整握手。</li><li>针对安全2，TLS1.3下，我们拒绝0-RTT的时候会检查收到的错误的0-RTT报文数量，太多的话就直接拒绝连接。</li><li>针对安全3，对于证书链的校验执行最严格的审查，任何证书链必须里面的一环必须可验证/有效/，而且不能是全局的ROOT CA（为了可靠，我们和MOZILLA ROOT CA开源的保持一致），必须是针对per vhost导入的CA，从而执行最严格校验。</li><li>针对安全4，OCSP/CRL证书的校验，正常情况下如果OCSP服务器连接不上，没办法验证证书有效无效的时候都是允许证书通过验证的。我们采用了最严格校验，如果没连上直接拒绝。</li></ul></li></ul></li></ul></li></ul></li><li>美团面对的问题一部分集中在语言层面，另一部分集中在是内部C/C++基础组件混乱情况下的工程适配。比方说不同组GCC版本不同，有4.8或者5.6，高版本用我们低版本编出来的包稳定crash，因为一些数据结构变了，所以数据结构的锁位置变了，但是代码还是老的地方改变触发异常<ul><li>职业规划实现：实现功能的时候，能够筛选产品，评估缺陷和不足（针对特定技术）。也就是说一方面提出技术的评估，另一方面提出结果的评估。这个是对业界的理解。</li></ul></li><li>轻舟面对的问题就从具体语言层面，变为结构设计，组件的划分，还有一些是分布式系统性通用问题。难题是复杂环境下问题排查和功能取舍，举个功能取舍简单的例子，仿真测试是轻舟CI最后一环，它使用cpfscache对象存储自动热更新，但更新线程有限，遇到大量数据需要会拖崩cpfs，无法挂载。功能取舍就是舍弃掉对全部数据热更新，只维护热点数据，更新采用定期手动更新的方式。另一个比方说 轻舟从微型公司到小中型还有很多问题，比方说快速重试，编译服务用户限流<ul><li>技术实现<ul><li>分布式的快速失败，快速重试具体实践，限流，功能取舍</li></ul></li><li>职业规划实现<ul><li>针对一个研发的体系，（实际上是抄的）能够制定一套安全的开发准则，够制定一套安全的设计准则，能够制定一套安全的审计准则</li><li>给出足够简单并且有效（逻辑可推理）的解决方案。比方说安全，在有KMS的参与下做授权，直接就是授权关键密钥</li></ul></li></ul></li><li>理想<ul><li>攻击检测样本怎么搭建？请求包含哪些信息？</li></ul></li></ul><h2 class="relative group">0 架构的基本思路<div id=0-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#0-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF aria-label=锚点>#</a></span></h2><p>做事做人的<strong>原则</strong></p><ul><li>拥抱现实，应对现实<ul><li>真相（或者更精确地说，对现实的准确理解）是任何良好结果的根本依据，要做到头脑极度开放、极度透明，不要担心其他人的看法，使之成为你的障碍</li><li>观察自然，学习现实规律，不要固守你对事物“应该”是什么样的看法，这将使你无法了解真实的情况，一个东西要“好”，就必须符合<strong>现实的规律</strong>，并<strong>促进整体的进化</strong>，这能带来最大的回报。</li><li>在你不擅长的领域请教擅长的其他人，依赖“全部证据”，这是一个你无论如何都应该培养的出色技能，这将帮助你建立起安全护栏，避免自己做错事。</li></ul></li><li>做到头脑极度开放，谨记，你是在寻找最好的答案，而不是你自己能得出的最好答案。</li><li>一个系统有要素，关联和功能三个东西构成。因此，系统具备层次性，自组织和适应性（弹性），因此要努力培养系统的弹性</li></ul><p>做事的<strong>方法</strong>和<strong>原则</strong></p><ul><li><p>原则，要清楚，单一因素直接引起后果是程序员的线性，或者说理性思维。系统往往是复杂系统，多方面糅合。除了从上向下的方式去追求通用原则，从下往上排查实际，具体的流程才是认清楚系统多样性的最好方法。在非线性的世界，不要用线性的思维模式</p></li><li><p>原则：系统分为三个要素，要素，联系和功能。我们平时重点应该是关注联系，因为是联系提供了系统的三个特征（适应性，层次性，自组织）里面的适应性。所以关注系统不应该看存量，而应该看适应性</p></li><li><p>方法：用四步流程实现你的人生愿望：</p><ul><li>有明确的目标，<strong>排列优先顺序</strong>，不要混淆目标和欲望</li><li>找出问题，<strong>要精准地找到问题所在，不要把问题的某个原因误认为问题本身；区分大问题和小问题；诊断问题，找到问题的根源；先把问题是什么弄明白，再决定怎么做；区分直接原因和根本原因</strong></li><li>通过快速试错以适应现实是无价的，拥有灵活性并自我归责，那么几乎没有什么能阻止你成功</li><li>建立<em><strong>清晰的衡量标准来确保你在严格执行方案</strong></em>，很多时候如果不能建立衡量标准，那么可能就不应该定做什么的目标</li><li>关键是要做一个清晰的“产品定义‘，即要做什么出来</li></ul></li><li><p>学习如何有效决策，要认识到</p><ul><li>影响好决策的最大威胁是有害的情绪</li><li>决策是一个两步流程（先了解后决定）<ul><li>a. 综合分析眼前的形势<strong>你能做的最重要的决定之一是决定问谁</strong>。</li><li>b．不要听到什么信什么。</li><li>c．所有东西都是放在眼前看更大。</li><li>d．不要夸大新东西的好处。</li><li>e.不要过度分析细节</li><li>f.不要过于着急做决定</li></ul></li><li>始终记住改善事物的速度和水平，以及两者的关系</li><li>谨记“80/20法则”，并明白关键性的“20%”是什么。</li><li>不必过于精确，不要做完美主义者，对于决策的后果而言，如果收益比付出要大，那么这个事情就是可以做的</li><li>高效地综合考虑各个层次a．用“基线以上”和“基线以下”来确定谈话位于哪一层。b．谨记，决策需要在合理的层次做出，但也应在各层次之间保持一致。</li><li>不要把可能性当作概率</li><li>从上往下学习</li><li>这里有一个批判性思维<ul><li>问“五个为什么”，</li><li>谁从中获益？</li><li>有什么背景</li><li>为什么这是个问题？是否存在一个基础模型，这个模型这么工作？</li><li>什么时候可以从哪里工作起来，不要停留在一阶思维，要进行二阶思维：当它结束后还会发生什么？</li></ul></li></ul></li><li><p>如何找到机会</p><ul><li><p>如何找到机会</p><ul><li>首先你得知道什么是好的</li><li>然后思考为什么目前好的东西为啥还没普及</li></ul></li><li><p>另外一个方面，寻找附加价值。比方说充电桩</p><ul><li>因为充电速度太慢，所以不能直接从充电翻桌率盈利</li><li>但是可以从补贴上面拿到赚的钱</li></ul></li><li><p>降维打击</p></li><li><p>多样性对抗</p></li></ul></li><li><p>如何找到研究的idea？</p><ul><li><p>下面的内容为：《How to Look for Ideas in Computer Science Research》</p></li><li><p>阅读其它的论文或者关键点，学习如何理解识别research idea的形成模式：</p><ol><li>填表法：</li><li>拓展：</li><li></li></ol></li></ul></li></ul><p>目前企业的根本实际上并不是做善事，或者出发时是善良的，但是附加是邪恶的。对企业而言，付费的才是真正的客户，如果你是免费用户，那么“从实际”的角度来说，你是产品。</p><p>通用工具库：</p><ul><li><p>分治思想</p><ul><li>分库分表</li><li>读写分离</li><li>冷热分离</li></ul></li><li><p>系统的八大陷阱</p><ol><li>政策阻力：治标不治本。这种问题往往是因为不同参与者有不同的目标，将系统存量往<ul><li>解决办法，重新制定更大的总体目标，让参与者突破各自的有限理性，追求共同目标</li></ul></li></ol></li><li><p>系统的12大变革方式</p></li><li><p>基础知识：网络分布式八宗罪</p></li><li><p>程序员主要涉及到两个价值观：行为(behavior）和结构(structor)，一半需求要的是行为，而我们关注的是结构，实际上我们应该讲机制和实现相分离，我们需要的是机制，而不是具体的实现</p></li><li><p>更精确地说让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖</p></li><li><p>转变观念，将问题从“是或否”的二元属性，转变为可以按照不同强度分开讨论的多元属性，在确保代价的情况下获得一定的收益。总之从具体的操作上面的变成问题，上升为一个全局权衡的架构问题。</p></li><li><p>通用手段：先将满足不同需求的代码分组（即 SRP），然后再来调整这些分组之间的依赖关系（即 DIP）</p></li></ul><p>进步的手段：</p><p>每年学习一门新的语言</p><p>每月阅读一本技术书</p><p>每月阅读一本非技术书</p><p>与时俱进</p><h2 class="relative group">0.5 Clean-Architecture-zh学习<div id=05-clean-architecture-zh%E5%AD%A6%E4%B9%A0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#05-clean-architecture-zh%E5%AD%A6%E4%B9%A0 aria-label=锚点>#</a></span></h2><h3 class="relative group">2 两个价值观<div id=2-%E4%B8%A4%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%E4%B8%A4%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82 aria-label=锚点>#</a></span></h3><p>程序员主要涉及到两个价值观：行为(behavior）和结构(structor)，一般需求要的是行为，而程序员需要关注结构。只关注行为不关注结构会最终导致失序</p><ul><li>行为：行为是其最直观的价值维度。程序员的工作就是让机器按照某种指定方式运转，给系统的使用者创造或者提高利润。简单来说就是需求</li><li>结构（架构）：当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。变更实施的难度应该和变更的范畴（scope）成等比关系，而与变更的具体形状（shape）无关。因此程序员需要关心结构（ The difficulty in making such a change should be proportional only to the scope of the change, and not to the shape of the change.）</li></ul><p>行为和结构哪个重要呢？按照艾森豪威尔的紧急/重要矩阵</p><blockquote><p>I have two kinds of problems, the urgent and the important. The urgent are not important, and the important are never urgent.</p></blockquote><p>一般来说，事情可以为分为四种</p><blockquote><ol><li>重要且紧急</li><li>重要不紧急</li><li>不重要但紧急</li><li>不重要且不紧急</li></ol></blockquote><p>软件的系统架构——那些重要的事情——占据了该列表的前两位，而系统行为——那些紧急的事情——只占据了第一和第三位。功能从来都是不重要但是紧急，但是业务部门原本就是没有能力评估系统架构的重要程度的，这本来就应该是研发人员自己的工作职责！所以，平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。</p><h2 class="relative group">3 编程范式<div id=3-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F aria-label=锚点>#</a></span></h2><ul><li>结构化编程</li><li>面向对象编程：很多OO编程语言声称面向对象就是封装，继承和多态，然后封装本质是无需了解本质，比方说.h泄露了内部信息。目前并不符合，而多态才是关心的重点，因此什么是OO？业界在这个问题上存在着很多不同的说法和意见。然而对一个软件架构师来说，其含义应该是非常明确的：面向对象编程就是以对象为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可必编译成插件，实现独立于高层组件的开发和部署。</li><li>函数式编程：</li></ul><h3 class="relative group">4 设计准则<div id=4-%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4-%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99 aria-label=锚点>#</a></span></h3><p>SOLID准则：我自己加一个准则</p><ul><li><p>SRP：A module should be responsible to one, and only one, actor。应当只服务于一种角色？举个例子：</p><ul><li>某个工资管理程序中的 Employee 类有三个函数 calculatePay()、reportHours() 和 save()；calculatePay() 函数是由财务部门制定的，他们负责向 CFO 汇报。；reportHours() 函数是由人力资源部门制定并使用的，他们负责向 COO 汇报。；save() 函数是由 DBA 制定的，他们负责向 CTO 汇报。；这三个函数被放在同一个源代码文件，即同一个 Employee 类中，程序员这样 做实际上就等于使三类行为者的行为耦合在了一起，这有可能会导致 CFO 团队的命令影响到 C 00 团队所依赖的功能。这就违背了SRP原则，因为任何改动可能带来给其他团队的副作用</li><li>解决方法非常简单，直接拆分为角色为三种不同的类型，而不是对基类Employee</li><li>在组件层面，我们可以将其称为共同闭包原则（Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心（Axis of Change）。</li></ul></li><li><p>OCP准则：A software artifact should be open for extension but closed for modification.该怎么做呢？</p><ol><li>先将满足不同需求的代码分组（即 SRP），然后再来调整这些分组之间的依赖关系（即 DIP）。</li><li>接下来，我们就该修改其源代码之间的依赖关系了。这样做的目的是保证其中一个操作被修改之后不会影响到另外一个操作。同时，我们所构建的新的组织形式应该保证该程序后续在行为上的扩展都无须修改现有代码。换句话说保证所有组件之间的关系都是单向依赖的</li><li>让我们再来复述一下这里的设计原则：如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件。</li><li>总之：OCP 是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。</li></ol></li><li><p>LSP准则：What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.1</p><ul><li><p>举一个反例来表示这个，正方形如果是长方形的子类，那么就会出现违背这种设定的情况，比方说下面的代码就会出现问题</p><pre tabindex=0><code>Rectangle r = …
r.setW(5);
r.setH(2);
assert(r.area() == 10);
</code></pre></li><li><p>LSP准则不单纯适用于继承，它是一种更广泛的、指导接口与其实现方式的设计原则。</p></li><li><p>LSP 可以且应该被应用于软件架构层面，因为一旦违背了可替换也该系统架构就不得不为此增添大量复杂的应对机制。</p></li><li><p>我怎么感觉LSP有点像是一个pot，got一样的东西，函数蹦床；简单来说就是保证接口是实现无关，直接通用的</p></li></ul></li><li><p>ISP准则：在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。从源代码层次来说，这样的依赖关系会导致不必要的重新编译和重新部署，对更高层次的软件架构设计来说，问题也是类似的。</p><ul><li>这个我觉得可以类比cpfs，它提供了缓存，更新缓存的功能，功能过于复杂。任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。</li></ul></li><li><p>DIP准则：</p><ul><li>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。这条守则适用于所有编程语言，无论静态类型语言还是动态类型语言。同时，对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂（abstract factory）这个设计模式。</li><li>不要在具体实现类上创建衍生类。上一条守则虽然也隐含了这层意思，但它还是值得被单独拿出来做一次详细声明。在静态类型的编程语言中，继承关系是所有一切源代码依赖关系中最强的、最难被修改的，所以我们对继承的使用应该格外小心。即使是在稍微便于修改的动态类型语言中，这条守则也应该被认真考虑。</li><li>不要覆盖（override）包含具体实现的函数。调用包含具体实现的函数通常 就意味着引入了源代码级别的依赖。即使覆盖了这些函数，我们也无法消除这其中的依赖——这些函数继承了那些依赖关系。在这里，控制依赖关系的唯一办法，就是创建一个抽象函数，然后再为该函数提供多种具体实现。</li><li>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。这基本上是 DIP 原则的另外一个表达方式。</li></ul></li><li><p>redundancy准则：</p><ul><li>任务组件应该在支持的情况下能够存储一些方便检索的冗余信息，尤其是管理功能</li></ul></li><li><p>一部分具体的通用设计准则</p><ul><li>系统的关键数据（这里我推荐使用DDD的实体的概念）要有元信息管理，举个简单的例子，对于仿真平台而言，仿真场景是关键数据，这部分关键数据是需要提供元信息管理的</li><li>不同功能的组件或者文件的存储和检索，不应该放在一个地方，否则会造成管理问题</li><li>系统的输入和输出，包括生成的报告，存储的流程文件，都需要有相应的元信息管理。或者至少能够方便的检索和管理</li></ul></li></ul><h3 class="relative group">5 设计方法<div id=5-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95 aria-label=锚点>#</a></span></h3><p>常见的设计方法有DDD（领域驱动设计）和ADD（属性驱动设计）。初次之外，针对复杂系统，可以采用状态/事件驱动设计</p><h4 class="relative group">5.1 DDD<div id=51-ddd class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#51-ddd aria-label=锚点>#</a></span></h4><p>领域驱动设计抽象名词一大堆，专家不说人话，说白了DDD是业务架构——根据业务需求设计业务模块及其关系，<strong>将业务架构映射到系统架构上，在响应业务变化调整业务架构时，也随之变化系统架构</strong>。建议直接阅读https://tech.meituan.com/2017/12/22/ddd-in-practice.html，作为一个直观的参考</p><p>简单总结流程如下。</p><p>领域驱动设计的一般化流程如下</p><ol><li>根据需求划分出初步的领域和限界上下文，以及上下文之间的关系；<ol><li>划分领域和限界上下文指的是在特定的前提下，组织各种概念。为什么不用模块等概念，因为这是个业务架构，早于实现架构或者系统架构</li><li><strong>考虑产品所讲的通用语言，；我们将紧耦合的各自圈在一起，观察他们内在的联系，从而形成对应的界限上下文。形成之后，我们可以尝试用语言来描述下界限上下文的职责，看它是否清晰、准确、简洁和完整（划分出来的限界上下文满足自治的架构单元具备4个要素，即最小完备、自我履行、稳定空间和独立进化）。简言之，限界上下文应该从需求出发，按领域划分。</strong></li><li>总结来说：<ol><li>怎样识别限界啥下文？从中提取一些术语称之为概念对象，寻找对象之间的联系；或者从需求里提取一些动词，观察动词和对象之间的关系。四个步骤来拆分很验证限界上下文的合理性<ol><li>步骤1业务维度拆分<ol><li>使用<strong>语义相关性</strong>意味着存在相同或相似的领域概念，对应于业务服务描述的名词，如果不同的业务服务操作了相同或相似的对象，即可认为它们存在语义相关性。</li><li>使用<strong>功能相关性</strong>体现为领域行为的相关性，但它并非设计意义上领域行为之间的功能依赖，而是指业务服务是否服务于同一个业务目标。</li></ol></li><li>步骤2验证拆分合理<ul><li>正交：保证每个限界上下文对外提供的业务能力不能出现雷同，这就需要保证为完成该业务能力需要的领域知识不能出现交叉</li><li>单一抽象原则：保证一个方法中的所有操作都在同一个抽象层次，违背了单一抽象层次原则的限界上下文会导致概念层次的混乱。一个高抽象层次的概念由于内涵更小，使得它的外延更大，就有可能包含低抽象层次的概念，使得位于不同抽象层次的限界上下文存在概念上的包含关系，这实际上也违背了正交原则。例如，在一个集装箱多式联运系统中，商务上下文与合同上下文就不在一个抽象层次上</li><li>奥卡姆剃刀原则：如果对识别出来的限界上下文的准确性依然心存疑虑，比较务实的做法是保证限界上下文具备一定的粗粒度。</li></ul></li><li>步骤3管理维度</li><li>步骤4技术维度考校</li></ol></li></ol></li></ol></li><li>进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象；<ol><li>实体，实体必然有下面三个东西<ol><li>身份标识：身份标识（identity，简称为ID）是实体对象的必要标志，实体的身份标识就好像每个公民的身份号码，除了帮助我们识别实体的同一性，身份标识的主要目的还是管理实体的生命周期</li><li>属性：实体的属性用来说明主体的静态特征，并持有数据与状态。通常，我们会依据粒度的粗细将属性分为原子属性与组合属性</li><li>领域行为：实体拥有领域行为，可以更好地说明其作为主体的动态特征</li></ol></li><li>值对象，可以理解为</li></ol></li><li>对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根；只能由实体、值对象、领域服务和领域事件表示模型<ol><li>聚合实际上就是类的聚合（引入了实现）,控制类的关系具体做法<ol><li>去除不必要的关系：一部分依赖的关系是可以去除的，比方说配送单需要订单的信息，但是实际上配送单真正依赖的是包裹存单，而不是配送单。因此原本的依赖是去除的。</li><li>降低耦合的强度:<ol><li>一种策略是引入泛化提取通用特征，形成更弱的依赖或关联关系，如Car对汽车的泛化使得Driver可以驾驶各种汽车</li><li>另一种是降低耦合的细度，比方说订单Order与订单项OrderItem，依赖orderitem，而不是order</li></ol></li><li>避免双向耦合:</li></ol></li></ol></li><li>为聚合根设计仓储，并思考实体或值对象的创建方式；</li><li>在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构。</li></ol><p>以DDD为方法，我划分CI试试</p><h4 class="relative group">5.2 ADD<div id=52-add class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#52-add aria-label=锚点>#</a></span></h4><p>属性驱动设计</p><h2 class="relative group">1 远程服务<div id=1-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1 aria-label=锚点>#</a></span></h2><h3 class="relative group">1.1 RPC的可靠性问题<div id=11-rpc%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%97%AE%E9%A2%98 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-rpc%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%97%AE%E9%A2%98 aria-label=锚点>#</a></span></h3><p>远程服务也就是RPC，早先的目的实际上是为了让计算机能够与本地方法一样调用远程方法。当时使用socket接口，透明的socket给程序员带来了通信无成本的假象，因此在当时Andrew Tanenbaum发表论文对RPC发起质疑：将本地调用和RPC远程调用当做同样的调用来处理，犯了方向性的错误，将系统间调用透明化，反而会增加程序员工作的复杂度。 简单来说就是使用网络进行分布式运算的八宗罪：</p><ul><li>网络是可靠的</li><li>延迟是不存在的</li><li>带宽是无限的</li><li>网络是安全的</li><li>拓扑结构是一成不变的</li><li>总会有一个管理员</li><li>不必考虑传输成本</li><li>网络是同质化的</li></ul><p>最终RPC被定性为：RPC应该是一种高层次的或者说语言层次的特征，而不是像IPC那样子低层次或者系统层次的特征。</p><h3 class="relative group">1.2 RPC要解决的问题<div id=12-rpc%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#12-rpc%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98 aria-label=锚点>#</a></span></h3><p>在对RPC的本质有了清醒的认识之后，20世纪80年代中后期，RPC的主要问题被思考出来即</p><ul><li>如何表示数据：这里的数据包括传递给方法的参数和方法执行之后的返回值，举个简单的例子grpc的protobuf，轻量级rpc支持的json序列化</li><li>如何传递数据：如何通过网络，在两个网络的endpoint之间相互操作。两个服务交互并不只扔个序列化数据流就完事，比方说异常，超时，安全，认证，授权，事务都得处理。在计算机科学里面有个名词叫做Wire Protocol，比方说java RMI的远程消息交换，JRMP</li><li>如何表示方法：不同的语言怎么表示一个函数或者方法呢？怎么跨语言定位函数和方法，比方说统一序号啥的。</li></ul><h3 class="relative group">1.3 REST<div id=13-rest class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-rest aria-label=锚点>#</a></span></h3><p>提到RPC，不得不提到REST了，REST本质可以理解为对资源的CRUD，实际上去看kubernetes的实现就会发现它实际上就是定义各种资源，然后对资源执行CRUD。如果用RPC的方式考虑问题就是典型的对着函数（方法）编程，而使用REST一般抽象程度比较高。</p><p>为了方便理解REST，我们先看看REST的基础概念</p><ul><li>资源：</li><li>表征</li><li>状态</li><li>转移</li><li>统一接口</li><li>超文本驱动</li><li>自描述信息</li></ul><p>REST的编程思想</p><ul><li>CS架构：客户端和服务端分离，提高用户界面的可移植性</li><li>无状态**（核心原则）**：每个请求都是独立的、自成一个个体，与前后请求无关。如此好处有很多，包含可靠（容易从错误中复原）、高效能与可扩充性（可以将请求交给不同伺服器处理），而元件可以被修改、更动而不会影响到系统整体的运作。</li><li>可缓存：希望能够缓存一些关键数据，减少多次请求，提高性能</li><li>分层：这里的分层指的是客户端不需要清楚是不是直接连接到了服务器，中间服务器提供的请求也可用</li><li>在发出请求的Client 与送出回应的Server 之间可以有好几个Server 中间人（称作Connectors，下面介绍），彼此独立并且不会影响到Request 与Response。</li><li>统一接口**（核心原则）**：将操作细节抽象出来，降低耦合并提高独立性。这里指的是将软件系统设计的重点放在抽象系统有哪些资源，而不是服务有哪些行为上。这个原则可以类比计算机中对文件管理的操作来理解，管理文件可能会设计删除，修改，移动等操作，这些操作时可数的，且对所有文件是固定统一的。</li><li>按需代码：这个原则是可选的，简单来说就是指可执行的程序可以从服务端发送到客户端。</li></ul><p>最后我们来看看REST的模型评测，也就是RMM，直接参考https://martinfowler.com/articles/richardsonMaturityModel.html的医生的例子</p><ul><li>0级：完全不rest：接口的功能非常单一，就是申请和返回。得开发多个接口</li><li>1级：引入了统一资源的概念：开始考虑资源的概念，将请求都包含资源的实体</li><li>2级：引入统一接口：依赖各种http的状态码来统一的表示是否可以成功的表达接口的状态</li><li>3级：超媒体控制：完全不依赖任何已知的信息，整个服务自举，比方说输入查询指令之后，返回的接口包含如何了解医生信息，如何预约等接口</li></ul><p>REST的不足：</p><ul><li>只适合做CRUD：因为是面向资源，所以只适合做CRUD，面向过程，面向对象的逻辑更复杂。当然也不是不能用REST表示方法，只不过就得加上一些行为的表示</li><li>REST没有事务的概念</li><li>REST没有传输可靠性的支持，毕竟本来就不是做这个事情的</li><li>REST缺乏对资源做部分和批量处理的能力，</li></ul><h2 class="relative group">2 事务处理<div id=2-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86 aria-label=锚点>#</a></span></h2><p>事务分为多种</p><ul><li><p>本地事务：本地事务是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。ACID里面的AIC要拆开实现</p><ul><li><p><strong>A</strong>tomic + <strong>D</strong>urability</p><ul><li>实现上<ul><li>常用“Commit Logging”（提交日志），拆分每一步不原子的操作为一系列的日志并记录。<ul><li>细节记录修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化。</li><li>commit log的问题是，因此有ARIES 理论。为了能够在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。优化磁盘 I/O 性能。方法：增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。</li></ul></li></ul></li></ul></li><li><p>隔离性<strong>I</strong>solation</p><ul><li>写锁：也叫做排他锁，如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。这里要注意：这个是不能写入数据，不能施加读锁</li><li>读锁：也叫做共享锁，多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。</li><li>范围锁：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。</li></ul><p>隔离性级别</p><ul><li><a href=https://en.wikipedia.org/wiki/SQL-92 target=_blank>ANSI/ISO SQL-92</a>中定义的最高等级的隔离级别便是<code>可串行化</code>（Serializable）。</li><li><code>可串行化</code>的下一个隔离级别是<code>可重复读</code>（Repeatable Read），<code>可重复读</code>对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。<code>可重复读</code>比<code>可串行化</code>弱化的地方在于<a href=https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Phantom_reads target=_blank>幻读问题</a>（Phantom Reads），它是指在事务执行过程中，两个完全相同的范围查询得到了不同的结果集。</li><li><code>可重复读</code>的下一个隔离级别是<code>读已提交</code>（Read Committed），<code>读已提交</code>对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。<code>读已提交</code>比<code>可重复读</code>弱化的地方在于<a href=https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Non-repeatable_reads target=_blank>不可重复读问题</a>（Non-Repeatable Reads），它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。</li><li><code>读已提交</code>的下一个级别是<code>读未提交</code>（Read Uncommitted），<code>读未提交</code>对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。<code>读未提交</code>比<code>读已提交</code>弱化的地方在于<a href=https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Dirty_reads target=_blank>脏读问题</a>（Dirty Reads），它是指在事务执行过程中，一个事务读取到了另一个事务未提交的数据。</li></ul></li></ul></li><li><p>全局事务</p><ul><li>全局事务被限定为一种适用于单个（也没说必须单个）服务使用多个数据源场景的事务解决方案。</li><li>方法：<ul><li>2PC<ul><li><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。</li><li><strong>提交阶段</strong>：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作。</li></ul></li></ul></li></ul></li></ul><h2 class="relative group">3 流量治理（分级与分流）<div id=3-%E6%B5%81%E9%87%8F%E6%B2%BB%E7%90%86%E5%88%86%E7%BA%A7%E4%B8%8E%E5%88%86%E6%B5%81 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%E6%B5%81%E9%87%8F%E6%B2%BB%E7%90%86%E5%88%86%E7%BA%A7%E4%B8%8E%E5%88%86%E6%B5%81 aria-label=锚点>#</a></span></h2><p>为什么我要郑重其事地写这条？因为我发现任何系统（这个只要是基础服务或者是稍微大一点的分布式系统/单点系统）的分级分流是必然要考虑的！buildfarm服务的机器一直在增加，但是性能依然跟不上用户的脚步，因此我们需要在前面加流量控制，容错处理啥的.</p><p>我们目前针对错误采用的就是重试策略，这一次我要采用的流量控制。</p><h3 class="relative group">3.1 服务容错<div id=31-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#31-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99 aria-label=锚点>#</a></span></h3><p>Martin Fowler 与 James Lewis 提出的“<a href=http://icyfenix.cn/architecture/architect-history/microservices.html target=_blank>微服务的九个核心特征</a>”是构建微服务系统的指导性原则，但不是技术规范，并没有严格的约束力。在实际构建系统时候，其中多数特征可能会有或多或少的妥协，譬如分散治理、数据去中心化、轻量级通信机制、演进式设计，等等。但也有一些特征是无法做出妥协的，其中的典型就是今天我们讨论的主题：容错性设计。</p><h4 class="relative group">3.1.1 容错策略<div id=311-%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#311-%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5 aria-label=锚点>#</a></span></h4><p>要落实容错性设计这条原则，除了思想观念上转变过来，正视程序必然是会出错的，对它进行有计划的防御之外，还必须了解一些常用的<strong>容错策略</strong>和<strong>容错设计模式</strong>。常见的容错策略有以下几种：</p><ul><li><strong>故障转移</strong>（Failover）：关键路径上的服务，均会部署有多个副本。如果调用的服务器出现故障，不会立即返回失败结果，而是自动切换到其他服务副本，尝试其他副本能否返回成功调用的结果，从而保证了整体的高可用性。</li><li><strong>快速失败</strong>（Failfast）：部分业务场景是不允许做故障转移的，故障转移策略能够实施的前提是要求服务具备幂等性，对于非幂等的服务，重复调用就可能产生脏数据，应直接返回失败。</li><li><strong>安全失败</strong>（Failsafe）：即使旁路逻辑调用实际失败了，也当作正确来返回，自动记录一条服务调用出错的日志备查即可，这种策略被称为安全失败。典型的有审计、日志、调试信息，等等</li><li><strong>沉默失败</strong>（Failsilent）：如果大量的请求造成服务失败，认为服务不可用，直接隔离错误的服务提供者，不再分配请求流量，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略。</li><li><strong>故障恢复</strong>（Failback）：故障恢复一般不单独存在，而是作为其他容错策略的补充措施，系统通常默认会采用快速失败加上故障恢复的策略组合：失败之后，返回失败+由系统自动开始异步重试调用。</li></ul><p>上面五种以“Fail”开头的策略是针对调用失败时如何进行弥补的，以下这两种策略则是在调用之前就开始考虑如何获得最大的成功概率。</p><ul><li><strong>并行调用</strong>（Forking）：“双重保险”或者“多重保险”的处理思路，它是指一开始就同时向多个服务副本发起调用，只要有其中任何一个返回成功，那调用便宣告成功。</li><li><strong>广播调用</strong>（Broadcast）：广播调用与并行调用是相对应的，都是同时发起多个调用，但并行调用是任何一个调用结果返回成功便宣告成功，广播调用则是要求所有的请求全部都成功。</li></ul><p>比较下表：</p><table><thead><tr><th>容错策略</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>故障转移</strong></td><td>系统自动处理，调用者对失败的信息不可见</td><td>增加调用时间，额外的资源开销</td><td>调用幂等服务 对调用时间不敏感的场景</td></tr><tr><td><strong>快速失败</strong></td><td>调用者有对失败的处理完全控制权 不依赖服务的幂等性</td><td>调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩</td><td>调用非幂等的服务 超时阈值较低的场景</td></tr><tr><td><strong>安全失败</strong></td><td>不影响主路逻辑</td><td>只适用于旁路调用</td><td>调用链中的旁路服务</td></tr><tr><td><strong>沉默失败</strong></td><td>控制错误不影响全局</td><td>出错的地方将在一段时间内不可用</td><td>频繁超时的服务</td></tr><tr><td><strong>故障恢复</strong></td><td>调用失败后自动重试，也不影响主路逻辑</td><td>重试任务可能产生堆积，重试仍然可能失败</td><td>调用链中的旁路服务 对实时性要求不高的主路逻辑也可以使用</td></tr><tr><td><strong>并行调用</strong></td><td>尽可能在最短时间内获得最高的成功率</td><td>额外消耗机器资源，大部分调用可能都是无用功</td><td>资源充足且对失败容忍度低的场景</td></tr><tr><td><strong>广播调用</strong></td><td>支持同时对批量的服务提供者发起调用</td><td>资源消耗大，失败概率高</td><td>只适用于批量操作的场景</td></tr></tbody></table><h4 class="relative group">3.1.2 容错设计模式<div id=312-%E5%AE%B9%E9%94%99%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#312-%E5%AE%B9%E9%94%99%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h4><p>为了实现各种各样的容错策略，开发人员总结出了一些被实践证明是有效的服务容错设计模式，譬如微服务中常见的断路器模式、舱壁隔离模式，重试模式，等等</p><ol><li>断路器模式：本质是一种快速失败策略的实现方式<ul><li>通过代理（断路器对象）来一对一地（一个远程服务对应一个断路器对象）接管服务调用者的远程请求。断路器会持续监控并统计服务返回的成功、失败、超时、拒绝等各种结果，当出现故障（失败、超时、拒绝）的次数达到断路器的阈值时</li></ul></li><li>舱壁隔离模式<ol><li>实现方式<ul><li>线程池方法：为每个服务单独设立线程池，这些线程池默认不预置活动线程，只用来控制单个服务的最大连接数。</li><li>信号量机制（Semaphore）。控制一个服务并发调用的最大次数，可以只为每个远程服务维护一个线程安全的计数器即可。服务开始调用时计数器加 1，服务返回结果后计数器减 1，一旦计数器超过设置的阈值就立即开始限流，在回落到阈值范围之前都不再允许请求了。</li></ul></li><li>细节：以上介绍的是从微观的、服务调用的角度应用的舱壁隔离设计模式，舱壁隔离模式还可以在更高层、更宏观的场景中使用，不是按调用线程，而是按功能、按子系统、按用户类型等条件来隔离资源都是可以的。一般来说，我们会选择将服务层面的隔离实现在服务调用端或者边车代理上，将系统层面的隔离实现在 DNS 或者网关处。</li></ol></li><li>重试模式<ol><li>有可能自己恢复（Resilient，称为自愈，也叫做回弹性）的临时性失灵，网络抖动、服务的临时过载（典型的如返回了 503 Bad Gateway 错误）这些都属于瞬时故障。这些可以用重试</li><li>使用条件：<ol><li>仅在主路逻辑的关键服务上进行同步的重试，不是关键的服务，尤其不该进行同步重试。</li><li>仅对由瞬时故障导致的失败进行重试。尽管一个故障是否属于可自愈的瞬时故障并不容易精确判定，比方说没权限就不该重试</li><li>仅对具备幂等性的服务进行重试。具体服务如何实现并无强制约束力，但我们自己建设系统时，遵循业界惯例本身就是一种良好的习惯。</li><li>重试必须有明确的终止条件，常用的终止条件有两种：<ul><li>超时终止：并不限于重试，所有调用远程服务都应该要有超时机制避免无限期的等待。</li><li>次数终止：重试必须要有一定限度，不能无限制地做下去，通常最多就只重试 2 至 5 次。</li></ul></li></ol></li></ol></li></ol><h4 class="relative group">3.1.3 流量控制<div id=313-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#313-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6 aria-label=锚点>#</a></span></h4><p>需要妥善解决以下三个问题：</p><ul><li><p><strong>依据什么限流？</strong>：要不要控制流量，要控制哪些流量，控制力度要有多大，等等这些操作都没法在系统设计阶段静态地给出确定的结论，必须根据系统此前一段时间的运行状况，甚至未来一段时间的预测情况来动态决定。</p><ul><li>主流系统大多倾向使用 HPS 作为首选的限流指标，它是相对容易观察统计的，而且能够在一定程度上反应系统当前以及接下来一段时间的压力。</li><li>方法：<ul><li><strong>每秒事务数</strong>（Transactions per Second，TPS）：TPS 是衡量信息系统吞吐量的最终标准。“事务”可以理解为一个逻辑上具备原子性的业务操作。比方说taobao买东西，真个买完了就是一个t</li><li><strong>每秒请求数</strong>（Hits per Second，HPS）：HPS 是指每秒从客户端发向服务端的请求数（请将 Hits 理解为 Requests 而不是 Clicks，国内某些翻译把它理解为“每秒点击数”多少有点望文生义的嫌疑）。</li><li><strong>每秒查询数</strong>（Queries per Second，QPS）：QPS 是指一台服务器能够响应的查询次数。如果只有一台服务器来应答请求，</li></ul></li></ul></li><li><p><strong>具体如何限流？</strong>：解决系统具体是如何做到允许一部分请求能够通行，而另外一部分流量实行受控制的失败降级，这必须了解掌握常用的服务限流算法和设计模式。</p><ul><li><p><strong>流量计数器</strong>：设置一个计算器，根据当前时刻的流量计数结果是否超过阈值来决定是否限流。譬如前面场景应用题中，我们计算得出了该系统能承受的最大持续流量是 80 TPS。但是</p><ul><li>每一秒的统计流量都没有超过 80 TPS，也不能说明系统没有遇到过大于 80 TPS 的流量压力</li><li>即使连续若干秒的统计流量都超过了 80 TPS，也不能说明流量压力就一定超过了系统的承受能力。</li></ul></li><li><p><strong>滑动时间窗</strong></p><ul><li></li></ul></li></ul></li></ul><ul><li><p><strong>漏桶</strong>：以请求对象作为元素的先入先出队列（FIFO Queue），队列长度就相当于漏桶的大小，当队列已满时便拒绝新的请求进入。漏桶实现起来很容易，困难在于如何确定漏桶的两个参数：桶的大小和水的流出速率。</p></li><li><p><strong>令牌桶</strong>：系统在 X 秒内最大请求次数不超过 Y，那就每间隔 X/Y 时间就往桶中放一个令牌，当有请求进来时，首先要从桶中取得一个准入的令牌，然后才能进入系统处理。任何时候，一旦请求进入桶中却发现没有令牌可取了</p></li><li><p><strong>分布式限流</strong>：单机限流很好办，指标都是存储在服务的内存当中，而分布式限流的目的就是要让各个服务节点的协同限流，无论是将限流功能封装为专门的远程服务</p><ul><li><p>实现</p><ul><li><p>请求进入集群时，首先在 API 网关处领取到一定数额的“货币”，将用户 A 的额度表示为 QuanityA。由于任何一个服务在响应请求时都需要消耗集群一定量的处理资源，所以访问每个服务时都要求消耗一定量的“货币”，假设服务 X 要消耗的额度表示为 CostX，那当用户 A 访问了 N 个服务以后，他剩余的额度 LimitN即表示为：</p><blockquote><p>LimitN = QuanityA - ∑NCostX</p></blockquote><p>此时，我们可以把剩余额度 LimitN作为内部限流的指标，规定在任何时候，只要一旦剩余额度 LimitN小于等于 0 时，就不再允许访问其他服务了。此时必须先发生一次网络请求，重新向令牌桶申请一次额度</p></li></ul></li></ul></li><li><p>客户端限流，如果能控制客户端的限流方式那么直接控制客户端的并发</p></li><li><p><strong>超额流量如何处理？</strong>：超额流量可以有不同的处理策略，也许会直接返回失败（如 429 Too Many Requests），或者被迫使它们进入降级逻辑，这种被称为否决式限流。也可能让请求排队等待，暂时阻塞一段时间后继续处理，这种被称为阻塞式限流。</p></li></ul><h2 class="relative group">架构安全<div id=%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8 aria-label=锚点>#</a></span></h2><p>我们重点关注5个点</p><ul><li>认证</li><li>授权</li><li>凭证</li><li>保密</li><li>传输</li><li>验证</li></ul><h2 class="relative group">2 K8S学习笔记<div id=2-k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 aria-label=锚点>#</a></span></h2><h3 class="relative group">2.1 基本概念<div id=21-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#21-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 aria-label=锚点>#</a></span></h3><p>kubernetes的概念可以拆分为多种</p><ul><li>资源类<ul><li>某种资源的对象，比方说节点，pod，服务，存储卷。资源对象一般包含一些通用属性比方说版本，类别，标签，名称注解。资源对象的名称，标签，注解是资源对象的元数据</li><li>与资源对象相关的事物和动作，比方说标签，注解，命名空间，部署，HPA，PVC</li></ul></li><li>集群类<ul><li>表示一个由master和node组成的kubernetes集群<ul><li>master是集群的控制节点，运行着关键进程<ul><li>kube-apiserver，提供http restful api接口的主要服务</li><li>kube-controller-manager，资源对象的控制中心</li><li>kube-echeduler，负责资源调度的进程，</li></ul></li><li>node，集群里面除了master之外的所有服务器<ul><li>kubelet进程</li><li>kube-proxy进程</li><li>容器runtime，比方说docker</li></ul></li><li>多租户隔离：命名空间。<ul><li>命名空间属于kubernetes的集群范畴的资源对象，不同命名空间的资源对象从逻辑上相互隔离。系统相关的资源对象比方说网络组建，dns组件，监控类组件都放在kube-system里面。</li></ul></li></ul></li></ul></li><li>应用类<ul><li>service类</li><li>pod类<ul><li>高级扩缩容功能HPA</li><li>高级扩缩容VPA</li></ul></li></ul></li><li>存储类</li></ul><h3 class="relative group">2.2 核心组件运行原理<div id=22-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#22-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86 aria-label=锚点>#</a></span></h3><p>核心组件交互实际上可以拆分为api server，controller，scheduler等组件交互流程，实际上可以理解为对etcd的简单crud。注意，这里主要用到的list watch机制</p><ul><li>kube api server原理解析<ul><li>kubeapi的listwatch接口</li><li>kubeapi server分为四层<ul><li>API</li><li>访问控制层</li></ul></li></ul></li><li>api server的网络隔离
+</li><li>scheduler原理：</li><li>controler的原理</li><li>kubeproxy机制，三代发展<ul><li>一代</li><li>二代</li><li>三代</li></ul></li></ul><h3 class="relative group">2.3 节点调度相关<div id=23-%E8%8A%82%E7%82%B9%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#23-%E8%8A%82%E7%82%B9%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3 aria-label=锚点>#</a></span></h3><h3 class="relative group">2.4 安全机制<div id=24-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#24-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6 aria-label=锚点>#</a></span></h3><h3 class="relative group">2.5 kubernetes运维管理<div id=25-kubernetes%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#25-kubernetes%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86 aria-label=锚点>#</a></span></h3><h3 class="relative group">2.6 kubernetes开发<div id=26-kubernetes%E5%BC%80%E5%8F%91 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#26-kubernetes%E5%BC%80%E5%8F%91 aria-label=锚点>#</a></span></h3><h2 class="relative group">3 云工程师<div id=3-%E4%BA%91%E5%B7%A5%E7%A8%8B%E5%B8%88 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%E4%BA%91%E5%B7%A5%E7%A8%8B%E5%B8%88 aria-label=锚点>#</a></span></h2><p>从单体架构迁移到云原生架构，需要考虑的方面很多，虽然云原生是一种文化理念，但是参考下面写的十二因素应用程序和云原生变革理念，就能知道从单体到云原生绝对不是迁移几个接口就完了的</p><p>云原生是什么？是一种理念，如果可以建议直接阅读https://tanzu.vmware.com/content/ebooks/migrating-to-cloud-native-application-architectures，或者看看https://lib.jimmysong.io/migrating-to-cloud-native-application-architectures/ 的翻译</p><p>云原生程序的架构特性</p><p>从传统的单体到云原生架构，需要文化，组织和技术的变革。云原生涉及的应用架构包括如下的方面：</p><ul><li><p>十二因素应用程序：云原生应用架构模式的集合，这些模式可以用来说明什么才是云原生</p><ul><li><p>代码库</p></li><li><p>依赖：使用可以声明的标准依赖，比方说maven，等。不该有部署环境里面隐式的依赖</p></li><li><p><strong>配置</strong>：配置或其他随发布环境（如部署、staging、生产）而变更的部分应当作为操作系统级的环境变量注入。</p></li><li><p><strong>后端服务</strong>：后端服务，例如数据库、消息代理应视为附加资源，并在所有环境中同等看待。</p></li><li><p><strong>编译、发布、运行</strong>：构建一个可部署的 app 组件并将它与配置绑定，根据这个组件 / 配置的组合来启动一个或者多个进程，这两个阶段是严格分离的。</p></li><li><p><strong>进程</strong>：该 app 执行一个或者多个无状态进程（例如 master/work），它们之间不需要共享任何东西。任何需要的状态都置于后端服务（例如 cache、对象存储等）。</p></li><li><p><strong>端口绑定</strong>：该应用程序是独立的，并通过端口绑定（包括 HTTP）导出任何 / 所有服务。</p></li><li><p><strong>并发</strong>：并发通常通过水平扩展应用程序进程来实现（尽管如果需要的话进程也可以通过内部管理的线程多路复用来实现）。</p></li><li><p><strong>可任意处置性</strong>：通过快速迅速启动和优雅的终止进程，可以最大程度上的实现鲁棒性。这些方面允许快速弹性缩放、部署更改和从崩溃中恢复。</p></li><li><p><strong>开发 / 生产平等</strong>：通过保持开发、staging 和生产环境尽可能的相同来实现持续交付和部署。</p></li><li><p><strong>日志</strong>：不管理日志文件，将日志视为事件流，允许执行环境通过集中式服务收集、聚合、索引和分析事件。</p></li><li><p><strong>管理进程</strong>行政或管理类任务（如数据库迁移），应该在与 app 长期运行的相同的环境中一次性完成。</p></li></ul></li><li><p>微服务：独立部署的服务，每个服务只做一件事情</p></li><li><p>自助服务的敏捷基础设施：快速，可重复和一致地提供应用环境和后台服务的平台，这里面有两点要注意：服务化和基础设施IAC</p></li><li><p>基于 API 的协作：发布和版本化的 API，允许在云原生应用架构中的服务之间进行交互</p><ul><li>这样子，只要不破坏现有的承诺，那么团队可以做快速的部署</li></ul></li><li><p>抗压性：根据压力变强的系统</p></li><li><p>安全：</p></li></ul><p>云原生理念带来变革</p><ul><li>文化变革<ul><li>云原生意味着将过去曾经的“信息孤岛”，比方说DBA相关的领域构建成共享的工具集、词汇表和沟通结构，以服务于专注于单一目标的文化：快速、安全得交付价值。然后创建激励结构，强制和奖励领导组织朝着这一目标迈进的行为。<strong>做产品而不是做项目</strong></li><li>从间断开发到敏捷开发：每次迭代（实际上是次每个源代码提交！）都被证明可以以自动化的方式部署。我们构建部署流水线，可自动执行每次测试，如果该测试失败，将会阻止生产部署。</li><li>从集中治理到分散自治：团队个体的分散自治和自主性是通过最小化、轻量级的结构进行平衡的，这些结构在可独立开发和部署的服务之间使用集成模式（例如，他们更喜欢 HTTP REST JSON API 而不是不同风格的 RPC）来实现。这些结构通常会在底层解决交叉问题，如容错。激励团队自己设法解决这些问题，然后自发组织与其他团队一起建立共同的模式和框架。随着整个组织中的最优解决方案出现，该解决方案的所有权通常被转移到云框架 / 工具团队，这可能嵌入到平台运营团队中也可能不会。当组织正在围绕对架构共识进行改革时，云框架 / 工具团队通常也将开创解决方案。</li></ul></li><li>组织变革：康威定律和逆康威定律<ul><li>寻求迁移到将业务能力分离的微服务等云原生架构的公司经常采用 Thoughtworks 称之为的“逆康威定律”。他们没有建立一个与其组织结构图相匹配的架构，而是决定了他们想要的架构，并重组组织以匹配该架构。</li></ul></li><li>技术变革：技术变革实际上是说现代架构的变化，采用云提供的独特能力设计新的架构，<ul><li>分解数据：<ul><li>将有界上下文与每个服务模式的数据库结合，每个微服务封装、管理和保护自己的领域模型和持久存储。在每个服务模式的数据库中，只允许一个应用程序服务访问逻辑数据存储，逻辑数据存储可能是以多租户集群中的单个 schema 或专用物理数据库中存在。</li></ul></li><li>到容器化<ul><li>容器调度相关，这个不用多解释了</li></ul></li></ul></li></ul><p>迁移指南：</p><ul><li>如何迁移到新的架构呢？<ul><li>首先，新功能用微服务构建</li><li>使用DDD经典的<ul><li><strong>表现层</strong>表现层的目的是为了简化与单体应用接口集成的过程。单体应用设计之初很可能没有考虑这个集成，因此我们引入了表现层来解决这个问题。它没有改变单体应用的模型，这很重要，注意不要将转换和集成问题耦合到一起。</li><li><strong>适配器</strong>我们用适配器来定义 service，用来提供我们需要的新功能。它知道如何获取系统请求并使用协议将请求发送给单体应用的表层。</li><li><strong>转换器</strong>转换器的职责是在单体应用与新的微服务之间进行请求和响应的领域模型转换。</li></ul></li></ul></li><li>因此，技术上我们需要使用分布式系统<ul><li>版本化和分布式配置</li><li>服务注册发现</li><li>路由和负载均衡</li><li>容错</li><li>API网关/边缘服务</li></ul></li></ul><h2 class="relative group">结尾<div id=%E7%BB%93%E5%B0%BE class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BB%93%E5%B0%BE aria-label=锚点>#</a></span></h2><p>唉，尴尬</p><p><figure><img class="my-0 rounded-md" loading=lazy src=https://i.loli.net/2020/08/27/BFHNyfpx3EsIDUG.jpg alt=狗头的赞赏码.jpg></figure></p></div></div><script>var oid="views_posts\\2023-03-31-架构之路\\index.md",oid_likes="likes_posts\\2023-03-31-架构之路\\index.md"</script><script type=text/javascript src=/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q+oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/2023-03-25-folly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">2023-03-25-folly学习笔记</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2023-03-25T00:00:00+00:00>2023 年 3 月 25 日</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/posts/2023-03-28-devsecops%E5%AE%9E%E8%B7%B5/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">2023-03-28-devsecops实践</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2023-03-28T00:00:00+00:00>2023 年 3 月 28 日</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">© 2025 - 2025 菜狗 All Rights Reserved.</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://hxndg.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>