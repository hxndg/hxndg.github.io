<!doctype html><html lang=cn dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>2024-07-04-C++20设计模式 &#183; 菜狗的blog</title>
<meta name=title content="2024-07-04-C++20设计模式 &#183; 菜狗的blog"><meta name=description content="菜狗's website"><meta name=keywords content="C++,八股,"><link rel=canonical href=https://hxndg.github.io/posts/2024-07-04-c++20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><link type=text/css rel=stylesheet href=/css/main.bundle.min.ba3775bebd52a2b4837f8da64e32ee36e5c52bf284a0ce2262562782398b701543947527ad1498487717b1b96fe2a4e48d365a02e0b5d00e224893052e99d83c.css integrity><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.764eb2fe8d6a6b086c7c58f87d12c64fa79a7585117fc27eb53f688f80c287a6eff16277f9d186cd223a39ff700e294d64482834faece5e07ee0498fa042d056.js integrity="sha512-dk6y/o1qawhsfFj4fRLGT6eadYURf8J+tT9oj4DCh6bv8WJ3+dGGzSI6Of9wDilNZEgoNPrs5eB+4EmPoELQVg==" data-copy data-copied></script><script src=/lib/zoom/zoom.min.3530c2657381259433194af312ec3d322a97a2ad85661810299757fe793b24c3b8e07ab97fa8e5cf96cff1208f271e75394b6eaa56c2e39e7e2c3ca49fb1921c.js integrity="sha512-NTDCZXOBJZQzGUrzEuw9MiqXoq2FZhgQKZdX/nk7JMO44Hq5f6jlz5bP8SCPJx51OUtuqlbC455+LDykn7GSHA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://hxndg.github.io/posts/2024-07-04-c++20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="菜狗的blog"><meta property="og:title" content="2024-07-04-C++20设计模式"><meta property="og:description" content="菜狗's website"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-04T00:00:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="八股"><meta name=twitter:card content="summary"><meta name=twitter:title content="2024-07-04-C++20设计模式"><meta name=twitter:description content="菜狗's website"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"2024-07-04-C\u002b\u002b20设计模式","headline":"2024-07-04-C\u002b\u002b20设计模式","inLanguage":"zh-cn","url":"https:\/\/hxndg.github.io\/posts\/2024-07-04-c\u002b\u002b20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/","author":{"@type":"Person","name":"菜狗"},"copyrightYear":"2024","dateCreated":"2024-07-04T00:00:00\u002b00:00","datePublished":"2024-07-04T00:00:00\u002b00:00","dateModified":"2024-07-04T00:00:00\u002b00:00","keywords":["C++","八股"],"mainEntityOfPage":"true","wordCount":"14284"}]</script><meta name=author content="菜狗"><script src=/lib/jquery/jquery.slim.min.03cb160e3cfdb2667a2e2c80d283bebcf63ff8bbc4b629c9ab2babf6fae1d0c07ad470edae783efa4fabda2ac01c58d60e63b98b3c336be8208460f08f4354f5.js integrity="sha512-A8sWDjz9smZ6LiyA0oO+vPY/+LvEtinJqyur9vrh0MB61HDtrng++k+r2irAHFjWDmO5izwza+gghGDwj0NU9Q=="></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">菜狗的blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Home</p></a><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Posts</p></a><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Tags</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Home</p></a></li><li class=mt-1><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Posts</p></a></li><li class=mt-1><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Tags</p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">2024-07-04-C++20设计模式</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2024-07-04T00:00:00+00:00>2024 年 7 月 4 日</time><span class="px-2 text-primary-500">&#183;</span><span>14284 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>29 分钟</span></div></div><div class="flex author"><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">菜狗</div><div class="text-sm text-neutral-700 dark:text-neutral-400">Focus</div><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#0-基础概念>0 基础概念</a><ul><li><a href=#1-crtp奇异递归模板>1 （CRTP）奇异递归模板</a><ul><li><a href=#11-crtp的用处>1.1 CRTP的用处</a></li><li><a href=#13-如何简单使用crtp>1.3 如何简单使用CRTP</a></li><li><a href=#14-crtp的误用>1.4 CRTP的误用</a></li></ul></li><li><a href=#2-mixin-inherence>2 MixIn inherence</a></li></ul></li><li><a href=#1-构造模式>1 构造模式</a><ul><li><a href=#11-fluent-builder>1.1 Fluent Builder</a></li><li><a href=#12-强制使用构造模式提供的函数>1.2 强制使用构造模式提供的函数</a></li><li><a href=#13-groovy-style-builder>1.3 Groovy-Style Builder</a></li><li><a href=#14-composite-builder>1.4 Composite Builder</a></li><li><a href=#15-builder-inheritance>1.5 Builder Inheritance</a></li></ul></li><li><a href=#2-工厂模式>2 工厂模式</a></li><li><a href=#3-原型模式>3 原型模式</a><ul><li><a href=#4-单例模式>4 单例模式</a><ul><li><a href=#41-单例模式的问题>4.1 单例模式的问题</a></li><li><a href=#42-per-thread单例模式>4.2 Per thread单例模式</a></li></ul></li></ul></li><li><a href=#结构相关模式>结构相关模式</a><ul><li><a href=#6-适配器模式>6 适配器模式</a></li><li><a href=#7-桥接模式>7 桥接模式</a></li><li><a href=#8-composite组合模式>8 Composite（组合）模式</a></li><li><a href=#9-装饰器模式>9 装饰器模式</a></li><li><a href=#10-facade模式>10 Facade模式</a></li><li><a href=#19-观察者模式>19 观察者模式</a></li></ul></li></ul><ul><li><a href=#1-基础模板概念>1 基础模板概念</a><ul><li><a href=#1s-关于模板互相依赖的问题>1.S 关于模板互相依赖的问题</a></li></ul></li><li><a href=#2-模板的基本概念>2 模板的基本概念</a><ul><li><a href=#21-隐式实例化>2.1 隐式实例化</a></li><li><a href=#22-显式实例化>2.2 显式实例化</a><ul><li><a href=#221-显式实例化定义>2.2.1 显式实例化定义</a></li><li><a href=#222-显式实例化声明>2.2.2 显式实例化声明</a></li></ul></li></ul></li><li><a href=#4-高级模板概念>4 高级模板概念</a><ul><li><a href=#41-名称绑定和依赖名称>4.1 名称绑定和依赖名称</a></li><li><a href=#42-两阶段名称查找>4.2 两阶段名称查找</a></li><li><a href=#43-如果依赖名称是一个类型>4.3 如果依赖名称是一个类型？</a></li><li><a href=#44-依赖模板的名称>4.4 依赖模板的名称？</a></li><li><a href=#45-模板特化>4.5 模板特化</a></li></ul></li><li><a href=#5-类型特征和条件编译>5 类型特征和条件编译</a></li><li><a href=#6-概念和约束>6 概念和约束</a></li><li><a href=#7-模式和习语>7 模式和习语</a></li><li><a href=#8-范围和算法>8 范围和算法</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#0-基础概念>0 基础概念</a><ul><li><a href=#1-crtp奇异递归模板>1 （CRTP）奇异递归模板</a><ul><li><a href=#11-crtp的用处>1.1 CRTP的用处</a></li><li><a href=#13-如何简单使用crtp>1.3 如何简单使用CRTP</a></li><li><a href=#14-crtp的误用>1.4 CRTP的误用</a></li></ul></li><li><a href=#2-mixin-inherence>2 MixIn inherence</a></li></ul></li><li><a href=#1-构造模式>1 构造模式</a><ul><li><a href=#11-fluent-builder>1.1 Fluent Builder</a></li><li><a href=#12-强制使用构造模式提供的函数>1.2 强制使用构造模式提供的函数</a></li><li><a href=#13-groovy-style-builder>1.3 Groovy-Style Builder</a></li><li><a href=#14-composite-builder>1.4 Composite Builder</a></li><li><a href=#15-builder-inheritance>1.5 Builder Inheritance</a></li></ul></li><li><a href=#2-工厂模式>2 工厂模式</a></li><li><a href=#3-原型模式>3 原型模式</a><ul><li><a href=#4-单例模式>4 单例模式</a><ul><li><a href=#41-单例模式的问题>4.1 单例模式的问题</a></li><li><a href=#42-per-thread单例模式>4.2 Per thread单例模式</a></li></ul></li></ul></li><li><a href=#结构相关模式>结构相关模式</a><ul><li><a href=#6-适配器模式>6 适配器模式</a></li><li><a href=#7-桥接模式>7 桥接模式</a></li><li><a href=#8-composite组合模式>8 Composite（组合）模式</a></li><li><a href=#9-装饰器模式>9 装饰器模式</a></li><li><a href=#10-facade模式>10 Facade模式</a></li><li><a href=#19-观察者模式>19 观察者模式</a></li></ul></li></ul><ul><li><a href=#1-基础模板概念>1 基础模板概念</a><ul><li><a href=#1s-关于模板互相依赖的问题>1.S 关于模板互相依赖的问题</a></li></ul></li><li><a href=#2-模板的基本概念>2 模板的基本概念</a><ul><li><a href=#21-隐式实例化>2.1 隐式实例化</a></li><li><a href=#22-显式实例化>2.2 显式实例化</a><ul><li><a href=#221-显式实例化定义>2.2.1 显式实例化定义</a></li><li><a href=#222-显式实例化声明>2.2.2 显式实例化声明</a></li></ul></li></ul></li><li><a href=#4-高级模板概念>4 高级模板概念</a><ul><li><a href=#41-名称绑定和依赖名称>4.1 名称绑定和依赖名称</a></li><li><a href=#42-两阶段名称查找>4.2 两阶段名称查找</a></li><li><a href=#43-如果依赖名称是一个类型>4.3 如果依赖名称是一个类型？</a></li><li><a href=#44-依赖模板的名称>4.4 依赖模板的名称？</a></li><li><a href=#45-模板特化>4.5 模板特化</a></li></ul></li><li><a href=#5-类型特征和条件编译>5 类型特征和条件编译</a></li><li><a href=#6-概念和约束>6 概念和约束</a></li><li><a href=#7-模式和习语>7 模式和习语</a></li><li><a href=#8-范围和算法>8 范围和算法</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><script>var margin=200,marginError=50;(function(){var t=$(window),e=$("#TOCView"),s=e.height();function n(){var n=t.height()-margin;s>=n?(e.css("overflow-y","scroll"),e.css("max-height",n+marginError+"px")):(e.css("overflow-y","hidden"),e.css("max-height","9999999px"))}t.on("resize",n),$(document).ready(n)})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><h1 class="relative group">C++20 设计模式<div id=c20-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#c20-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h1><p>这本书的代码如果自己写的有问题就直接去看下https://github.com/Apress/design-patterns-in-modern-cpp怎么写的，我发现某个实现者在github写的胡说八道的代码，然后自己标注有问题还上传。。。。</p><h2 class="relative group">0 基础概念<div id=0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5 aria-label=锚点>#</a></span></h2><h3 class="relative group">1 （CRTP）奇异递归模板<div id=1-crtp%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-crtp%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF aria-label=锚点>#</a></span></h3><p>如何理解CRTP，CRTP我觉得最大的问题是理解难度：一个类怎么能继承自己（是派生类参数）呢？阅读这个链接https://stackoverflow.com/questions/49708984/why-curiously-recurring-template-pattern-crtp-works</p><p>什么是CRTP，如何理解CRTP呢？</p><ul><li>继承自模板类</li><li>派生类将自身作为参数传递给模板类</li></ul><p>如何理解CRTP的继承关系？一般来说继承的语义是说派生类是一种基类，将对基类的调用定向到派生类上。</p><p>然而CRTP是完全不同的，派生类并不是基类，它实际上是通过继承手段拓展了基类来增加更多函数性（With the CRTP the situation is radically different. The derived class does not express the fact it “is a” base class. Rather, it <strong>expands its interface</strong> by inherting from the base class, in order to add more functionality.）。</p><p>这种情况下，直接使用派生类才有意义，绝不要使用基类，当然只适合CRTP的前几种用法，不适合静态接口情况 (which is true for this usage of the CRTP, but not the one described below on static interfaces).</p><p>所以实际上基类不是接口，派生类也不是实现。恰恰相反，基类使用派生类的接口函数，是派生类给基类提供接口，这种CRTP的继承和传统继承关系不是相反的（ In this regard, <strong>the derived class offers an interface to the base class</strong>. This illustrates again the fact that inheritance in the context of the CRTP can express quite a different thing from classical inheritance）</p><p>CRTP的目的是什么？</p><ul><li>可以使用static_cast静态绑定将基类转换成派生类使用，而普通基类转派生类用的是dynamic_cast动态绑定。避免了虚函数的消耗</li><li>创建静态接口</li></ul><p>换言之CRTP是基类对子类的调用，一种反向调用</p><h4 class="relative group">1.1 CRTP的用处<div id=11-crtp%E7%9A%84%E7%94%A8%E5%A4%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-crtp%E7%9A%84%E7%94%A8%E5%A4%84 aria-label=锚点>#</a></span></h4><p>CRTP的用法简单来说有以下几种：</p><ul><li>Some classes provide generic functionality, that can be re-used by many other classes.</li><li>The second usage of the CRTP is, as described in this <a href=http://stackoverflow.com/a/262984 target=_blank>answer on Stack Overflow</a>, to create <strong>static interfaces</strong>. In this case, the base class does represent the interface and the derived one does represent the implementation, as usual with polymorphism.</li></ul><h5 class="relative group">1.1.1 添加通用函数<div id=111-%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#111-%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0 aria-label=锚点>#</a></span></h5><p>CRTP的作用之一是添加通用函数，比方说下面的代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sensitivity</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setValue</span><span class=p>(</span><span class=kt>double</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// rest of the sensitivity&#39;s rich interface...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>如果我要添加几个函数，那么需要改成这样子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sensitivity</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setValue</span><span class=p>(</span><span class=kt>double</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>scale</span><span class=p>(</span><span class=kt>double</span> <span class=n>multiplicator</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>setValue</span><span class=p>(</span><span class=n>getValue</span><span class=p>()</span> <span class=o>*</span> <span class=n>multiplicator</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>square</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>setValue</span><span class=p>(</span><span class=n>getValue</span><span class=p>()</span> <span class=o>*</span> <span class=n>getValue</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setToOpposite</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>scale</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// rest of the sensitivity&#39;s rich interface...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>那么我可以直接使用CRTP写一个通用函数类然后让每个其它类别继承基础类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NumericalFunctions</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>scale</span><span class=p>(</span><span class=kt>double</span> <span class=n>multiplicator</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span><span class=o>&amp;</span> <span class=n>underlying</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>underlying</span><span class=p>.</span><span class=n>setValue</span><span class=p>(</span><span class=n>underlying</span><span class=p>.</span><span class=n>getValue</span><span class=p>()</span> <span class=o>*</span> <span class=n>multiplicator</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>square</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span><span class=o>&amp;</span> <span class=n>underlying</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>underlying</span><span class=p>.</span><span class=n>setValue</span><span class=p>(</span><span class=n>underlying</span><span class=p>.</span><span class=n>getValue</span><span class=p>()</span> <span class=o>*</span> <span class=n>underlying</span><span class=p>.</span><span class=n>getValue</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setToOpposite</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>scale</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>换言之，只要让每个类别成为一个CRTP的类别，就可以实现通用代码了，不需要再手动给每个类别添加类了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sensitivity</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NumericalFunctions</span><span class=o>&lt;</span><span class=n>Sensitivity</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setValue</span><span class=p>(</span><span class=kt>double</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// rest of the sensitivity&#39;s rich interface...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>当然这带来一个问题，为啥不使用函数模板而使用CRTP呢？很简单，因为CRTP不会像函数模板一样子隐藏实现。</p><h5 class="relative group">1.2.2 static interface<div id=122-static-interface class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#122-static-interface aria-label=锚点>#</a></span></h5><p>静态多态，没有虚函数表参与。</p><p>比方说一个基础类型为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Amount</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span> <span class=k>const</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>).</span><span class=n>getValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>然后两个类别可以分别继承</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Constant42</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Amount</span><span class=o>&lt;</span><span class=n>Constant42</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=mi>42</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Variable</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Amount</span><span class=o>&lt;</span><span class=n>Variable</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Variable</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span> <span class=n>value_</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=nf>getValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>value_</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这两个类别就变成了兼容两种Amount了，虽然这里有多态参与，但是并没有运行时多态，反而为编译时多态</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>print</span><span class=p>(</span><span class=n>Amount</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>amount</span><span class=p>.</span><span class=n>getValue</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">1.3 如何简单使用CRTP<div id=13-%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8crtp class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8crtp aria-label=锚点>#</a></span></h4><p>简单来说包括两种用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>crtp</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=n>underlying</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>underlying</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span> <span class=k>const</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 class="relative group">1.4 CRTP的误用<div id=14-crtp%E7%9A%84%E8%AF%AF%E7%94%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#14-crtp%E7%9A%84%E8%AF%AF%E7%94%A8 aria-label=锚点>#</a></span></h4><p>使用CRTP并不是无代价</p><h3 class="relative group">2 MixIn inherence<div id=2-mixin-inherence class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-mixin-inherence aria-label=锚点>#</a></span></h3><p>Mixin Inherence实际上是在派生类里调用传递的类型T的某个方法，这种方法不会对基类T造成干扰，但是可能会造成拷贝成本。CRTP是给传入的类添加函数，而Mixin inherence是给传入的类生成派生类并进行调用。所以实际上Mixin inherence往往用来做拓展模式，说的感觉不像是人话，简单解释下：</p><ul><li>CRTP是使用“包含<strong>派生类的typename</strong>的基类”给“派生类”（实际上是我们传递的typename）添加功能。我们最终获得的类，就是我们传入的类，也就是派生类。</li><li>MixIn Inherence则是“包含<strong>基类的typename</strong>“，派生出来真正要使用的新类别。我们最终获得的类，不是我们传入的类（我们传入的是基类），而是基类添加了新的信息的派生类。</li></ul><pre tabindex=0><code>template &lt;typename T&gt; Struct Mixin: T {

}
</code></pre><h2 class="relative group">1 构造模式<div id=1-%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h2><p>构造模式基本是最简单的模式通信模式了，基本上稍微复杂点的类别都会调用“构造模式”（虽然可能并没有这个含义）</p><h3 class="relative group">1.1 Fluent Builder<div id=11-fluent-builder class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-fluent-builder aria-label=锚点>#</a></span></h3><p>By returning a reference to the builder itself, the builder calls can now be chained. This is what’s called a <em>fluent interface</em>:</p><pre tabindex=0><code>HtmlBuilder* add_child(string child_name, string child_text)
{
 root.elements.emplace_back(child_name, child_text);
 return this;
}
</code></pre><h3 class="relative group">1.2 强制使用构造模式提供的函数<div id=12-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%BD%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#12-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%BD%E6%95%B0 aria-label=锚点>#</a></span></h3><p>怎样强制用户使用我们提供的创建新模式的函数，而不是直接使用构造函数呢？很简单，隐藏构造函数，暴露static的函数出来</p><pre tabindex=0><code>struct HtmlElement
{
   string name;
   string text;
   vector&lt;HtmlElement&gt; elements;
   const size_t indent_size = 2;

   static unique_ptr&lt;HtmlBuilder&gt; create(const string&amp; root_name)
   {
   	return make_unique&lt;HtmlBuilder&gt;(root_name);
   }
protected: // hide all constructors
   HtmlElement() {}
   HtmlElement(const string&amp; name, const string&amp; text)
   : name{name}, text{text}
   {
   }
};
</code></pre><h3 class="relative group">1.3 Groovy-Style Builder<div id=13-groovy-style-builder class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-groovy-style-builder aria-label=锚点>#</a></span></h3><p>将构造函数改成Protected，通过让派生类的构造函数调用特定的构造函数来简化API使用难度</p><pre tabindex=0><code>struct Tag
{
 ...
protected:
   Tag(const string&amp; name, const string&amp; text)
   : name{name}, text{text} {}
   Tag(const string&amp; name, const vector&lt;Tag&gt;&amp; children)
   : name{name}, children{children} {}
};

struct P : Tag
{
   explicit P(const string&amp; text)
   : Tag{&#34;p&#34;, text} {}
   P(initializer_list&lt;Tag&gt; children)
   : Tag(&#34;p&#34;, children) {}
};
struct IMG : Tag
{
   explicit IMG(const string&amp; url)
   : Tag{&#34;img&#34;, &#34;&#34;}
   {
    	attributes.emplace_back({&#34;src&#34;, url});
   }
};
</code></pre><h3 class="relative group">1.4 Composite Builder<div id=14-composite-builder class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#14-composite-builder aria-label=锚点>#</a></span></h3><p>Composite Builder的目的是为了简化各个模块组合起来构造对象的难度，There are two aspects to Person: their address and employment information. What if we want to have separate builders for each – how can we provide the most convenient API?</p><pre tabindex=0><code>class PersonBuilderBase
{
protected:
 	Person&amp; person;
 	explicit PersonBuilderBase(Person&amp; person)
 		: person{person} {}
public:
 	operator Person()
 	{
 		return move(person);
 	}
 	// builder facets
 	PersonAddressBuilder lives() const;
 	PersonJobBuilder works() const;
};
</code></pre><p>This is much more complicated than our simple Builder earlier, so let’s discuss each member in turn:</p><ul><li>person is a reference to the object that’s being built. This may seem rather strange, but it’s done deliberately for the sub-builders. Note that the physical storage of Person is not present in this class. This is critical! The root class only holds a reference, not the constructed object.</li><li>The reference-assigning constructor is protected so that only the inheritors (PersonAddressBuilder and PersonJobBuilder) can use it.</li><li>operator Person is a trick that we’ve done before. I’m making the assumption that Person has a properly defined move constructor – it’s easy to generate one in an IDE.</li><li>lives() and works() are functions returning builder facets: those sub-builders that initialize the address and employment information separately.</li></ul><pre tabindex=0><code>class PersonBuilder : public PersonBuilderBase
{
 Person p; // object being built
public:
 PersonBuilder() : PersonBuilderBase{p} {}
};

class PersonAddressBuilder : public PersonBuilderBase
{
 	typedef PersonAddressBuilder self;
public:
 	explicit PersonAddressBuilder(Person&amp; person)
 		: PersonBuilderBase{ person } {}
 
 	self&amp; at(string street_address)
 	{
		person.street_address = street_address;
 		return *this;
 	}
 	self&amp; with_postcode(string post_code) { ... }
 	self&amp; in(string city) { ... }
};


Person p = Person::create()
 .lives().at(&#34;123 London Road&#34;)
 .with_postcode(&#34;SW1 1GB&#34;)
 .in(&#34;London&#34;)
 .works().at(&#34;PragmaSoft&#34;)
 .as_a(&#34;Consultant&#34;)
 .earning(10e6);
</code></pre><h3 class="relative group">1.5 Builder Inheritance<div id=15-builder-inheritance class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#15-builder-inheritance aria-label=锚点>#</a></span></h3><p>是否可以继承Fluent Builder？这个有一些难度，因为类型不同很难继承，比方说下面的代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonBuilder</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl> <span class=n>Person</span> <span class=n>person</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl> <span class=na>[[nodiscard]]</span> <span class=n>Person</span> <span class=n>build</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=n>person</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonInfoBuilder</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PersonBuilder</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl> <span class=n>PersonInfoBuilder</span><span class=o>&amp;</span> <span class=n>called</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>person</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonJobBuilder</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PersonInfoBuilder</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl> <span class=n>PersonJobBuilder</span><span class=o>&amp;</span> <span class=n>works_as</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>person</span><span class=p>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Why won’t the preceding code compile? It’s simple: called() returns *this, which is of type PersonInfoBuilder&amp;; this simply doesn’t have the works_as() method!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PersonJobBuilder</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>person</span> <span class=o>=</span>
</span></span><span class=line><span class=cl> <span class=n>pb</span><span class=p>.</span><span class=n>called</span><span class=p>(</span><span class=s>&#34;Dmitri&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>.</span><span class=n>works_as</span><span class=p>(</span><span class=s>&#34;Programmer&#34;</span><span class=p>)</span> <span class=c1>// will not compile
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>.</span><span class=n>build</span><span class=p>();</span>
</span></span></code></pre></div><p>这个之所以有问题是因为，called函数不是虚函数，返回的this还是自己的类型</p><p>解决办法也非常简单，调用CRTP即可，简单来说，一层一层的CRTP</p><pre tabindex=0><code>template &lt;typename TSelf&gt;
class PersonInfoBuilder : public PersonBuilder
{
public:
 TSelf&amp; called(const string&amp; name)
 {
 person.name = name;
 return static_cast&lt;TSelf&amp;&gt;(*this);
 // alternatively, *static_cast&lt;TSelf*&gt;(this)
 }
};

template &lt;typename TSelf&gt;
class PersonJobBuilder :
 public PersonInfoBuilder&lt;PersonJobBuilder&lt;TSelf&gt;&gt;
{
public:
 TSelf&amp; works_as(const string&amp; position)
 {
 this-&gt;person.position = position;
 return static_cast&lt;TSelf&amp;&gt;(*this);
 }
};
</code></pre><h2 class="relative group">2 工厂模式<div id=2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h2><p>为什么需要工厂模式？答案很简单，因为很多时候构造出来的东西需要和其它的类型产生关联，可能会造成影响，因此需要调用一个统一的工厂入口</p><h2 class="relative group">3 原型模式<div id=3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h2><p>The fact is the Prototype pattern is all about copying objects. And, of course, we do not have a universal way of actually copying an object, but there are options, and we’ll choose some of them.</p><p>简单来说就是涉及到对象拷贝的时候，到底如何满足拷贝的要求（比方说重复拷贝，比方说深度拷贝啥的应该如何实现），这个之所以复杂是因为涉及到了继承，派生什么的奇特情况。所以一种见的解决方法就是虚函数！</p><pre tabindex=0><code>class ExtendedAddress : public Address
{
public:
 	string country, postcode;
 	ExtendedAddress(const string &amp;street, const string &amp;city,
 	const int suite, const string &amp;country,
 	const string &amp;postcode)
 		: Address(street, city, suite)
 		, country{country}, postcode{postcode} {}
};

ExtendedAddress ea = ...;
Address&amp; a = ea;
// how do you deep-copy `a`?
</code></pre><p>解决办法</p><pre tabindex=0><code>virtual Address clone()
{
 	return Address{street, city, suite};
}

virtual Address* clone()
{
 	return new Address{street, city, suite};
}

ExtendedAddress* clone() override {
 	return new ExtendedAddress(street, city, suite,country, postcode);
}

ExtendedAddress ea{&#34;123 West Dr&#34;, &#34;London&#34;, 123, &#34;UK&#34;, &#34;SW101EG&#34;};
Address&amp; a = ea; // upcast
auto cloned = a.clone();
</code></pre><p>另外一个方面，如果希望信息可以多类型共享，那么直接建一个工厂模式，存储这些不同的地址，避免拷贝+避免重复。</p><pre tabindex=0><code></code></pre><h3 class="relative group">4 单例模式<div id=4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><h4 class="relative group">4.1 单例模式的问题<div id=41-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#41-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98 aria-label=锚点>#</a></span></h4><p>单例模式不需要多说了，非常经典，单例模式的问题有两种</p><ul><li>如果需要使用其他static对象，那么初始化的顺序是不能控制的，可能会出现依赖未初始化导致程序崩溃的问题</li><li>对基于单例模式的代码写UT会非常脆弱和dummy</li></ul><p>针对第二种问题的解决方式很简单，简单来说就是让代码不再依赖具体的类，而是依赖plungable的组件，或者说单例真正包含内部的代码。比方说我现在有个database类型，拓展为单例，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Database</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=n>intget_population</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SingletonDatabase</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Database</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>SingletonDatabase</span><span class=p>()</span> <span class=p>{</span> <span class=cm>/* read data from database */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>capitals</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>SingletonDatabase</span><span class=p>(</span><span class=n>SingletonDatabase</span> <span class=k>const</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>SingletonDatabase</span> <span class=k>const</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span><span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>SingletonDatabase</span><span class=o>&amp;</span> <span class=n>get</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>staticSingletonDatabase</span> <span class=n>db</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>db</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>get_population</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>capitals</span><span class=p>[</span><span class=n>name</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>那么我写一个工具函数来从Database里面拿数据，然后取出来的时候就会导致问题。因为它依赖单例，而单例里面的任何数据的改变都会导致它依赖项的变化。实际上这种做法相当于要去拿真正的数据库连接做操作。下面的代码就很糟糕。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SingletonRecordFinder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>total_population</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>names</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>name</span> <span class=p>:</span> <span class=n>names</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>      <span class=n>result</span> <span class=o>+=</span><span class=n>SingletonDatabase</span><span class=o>::</span><span class=n>get</span><span class=p>().</span><span class=n>get_population</span><span class=p>(</span><span class=n>name</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>returnresult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>RecordFinderTests</span><span class=p>,</span><span class=n>SingletonTotalPopulationTest</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>SingletonRecordFinderrf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>names</span><span class=p>{</span> <span class=s>&#34;Seoul&#34;</span><span class=p>,</span> <span class=s>&#34;Mexico City&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>inttp</span> <span class=o>=</span> <span class=n>rf</span><span class=p>.</span><span class=n>total_population</span><span class=p>(</span><span class=n>names</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>EXPECT_EQ</span><span class=p>(</span><span class=mi>17500000</span> <span class=o>+</span> <span class=mi>17400000</span><span class=p>,</span> <span class=n>tp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>所以应该怎么写呢？简单来说，写pluginable的东西。这个应该稍微有点经验的工程师都会，说实话。。。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ConfigurableRecordFinder</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>explicitConfigurableRecordFinder</span><span class=p>(</span><span class=n>Database</span><span class=o>&amp;</span> <span class=n>db</span><span class=p>)</span> <span class=o>:</span> <span class=n>db</span><span class=p>{</span><span class=n>db</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>total_population</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>names</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span><span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>name</span> <span class=p>:</span> <span class=n>names</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>result</span> <span class=o>+=</span> <span class=n>db</span><span class=p>.</span><span class=n>get_population</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>Database</span><span class=o>&amp;</span> <span class=n>db</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>          
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DummyDatabase</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Database</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>capitals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span><span class=n>DummyDatabase</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>capitals</span><span class=p>[</span><span class=s>&#34;alpha&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>capitals</span><span class=p>[</span><span class=s>&#34;beta&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>capitals</span><span class=p>[</span><span class=s>&#34;gamma&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>get_population</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>capitals</span><span class=p>[</span><span class=n>name</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>RecordFinderTests</span><span class=p>,</span> <span class=n>DummyTotalPopulationTest</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>DummyDatabase</span> <span class=n>db</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>  <span class=n>ConfigurableRecordFinder</span> <span class=n>rf</span><span class=p>{</span><span class=n>db</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>EXPECT_EQ</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>rf</span><span class=p>.</span><span class=n>total_population</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span><span class=p>{</span><span class=s>&#34;alpha&#34;</span><span class=p>,</span> <span class=s>&#34;gamma&#34;</span><span class=p>}));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">4.2 Per thread单例模式<div id=42-per-thread%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#42-per-thread%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h4><p>实际上实现起来很简单，就是加个thread_local的标志。这里多说一句，static thread_local和thread_local是一样的。</p><pre tabindex=0><code>template &lt;typename T&gt;
class SingletonCRTP {
 public:
  static T&amp; GetInstance() {
    thread_local T instance;
    return instance;
  }
 // why must be protected? Derived Singleton will call implicited 
 protected:
  SingletonCRTP() = default;
  ~SingletonCRTP() = default;

  // 禁止拷贝构造和赋值操作
  SingletonCRTP(const SingletonCRTP&amp;) = delete;
  SingletonCRTP&amp; operator=(const SingletonCRTP&amp;) = delete;
};
</code></pre><h2 class="relative group">结构相关模式<div id=%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h2><h3 class="relative group">6 适配器模式<div id=6-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><p>这个就不多说了，适配器实际上就是要使用的函数接口只支持特定格式，需要转换一层</p><h3 class="relative group">7 桥接模式<div id=7-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#7-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><h3 class="relative group">8 Composite（组合）模式<div id=8-composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#8-composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><p>composite模式从名字来说是组合模式（Composite Pattern），我个人觉得实际上是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。但是这里有个问题，本质来说，组合模式组合的对象是<strong>功能一致</strong>的对象，还是说只是<strong>接口相同</strong>的对象呢？</p><p>按照查询到的资料来说，接口相同即可。但是功能相同放到一起实际上更符合DDD之类的概念，那么这里应该如何取舍呢？这个我也没想明白。</p><p>话说回来，C++怎么实现Composite模式呢？追求能够将不同的组件组合到一起，这里（实际上也有我个人的理解）有三种方式：</p><ul><li><p>方法1 ： 利用传统的C++ 多态的方式，composite的组合 & 整体部分都使用整体的代码。代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>lass</span> <span class=n>Graphic</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Graphic</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 叶子节点，具体图形：圆
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Circle</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Graphic</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>draw</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Drawing a Circle&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 叶子节点，具体图形：正方形
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Square</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Graphic</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>draw</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Drawing a Square&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 组合节点，图形组合
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>CompositeGraphic</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Graphic</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>add</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Graphic</span><span class=o>&gt;</span> <span class=n>graphic</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>children</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>graphic</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>draw</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>child</span> <span class=p>:</span> <span class=n>children</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span><span class=o>-&gt;</span><span class=n>draw</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Graphic</span><span class=o>&gt;&gt;</span> <span class=n>children</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 具体用法就得靠调用包裹Graphic的add方法来做
</span></span></span><span class=line><span class=cl><span class=cm>std::shared_ptr&lt;CompositeGraphic&gt; compositeGraphic = std::make_shared&lt;CompositeGraphic&gt;();
</span></span></span><span class=line><span class=cl><span class=cm>compositeGraphic-&gt;add(circle1);
</span></span></span><span class=line><span class=cl><span class=cm>compositeGraphic-&gt;add(circle2);
</span></span></span><span class=line><span class=cl><span class=cm>compositeGraphic-&gt;add(square);
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div></li><li><p>方法2: 使用类似CRTP的方式，这种方法就适合实现静态的composite模式。好处是，坏处是需要多实现一些东西，比方说begin & end。这里实际上已经可以使用C++ 17 的Fold Expression了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Component</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Self</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SomeComponents</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>ConnectTo</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Component</span> <span class=o>&amp;</span><span class=nl>from</span><span class=p>:</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Self</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>Component</span> <span class=o>&amp;</span><span class=nl>to</span><span class=p>:</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>from</span><span class=p>.</span><span class=n>out</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>&amp;</span><span class=n>to</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>to</span><span class=p>.</span><span class=n>in</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>&amp;</span><span class=n>from</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>Component</span><span class=o>*</span> <span class=nf>begin</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>Component</span><span class=o>*</span> <span class=nf>end</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Component</span> <span class=o>:</span> <span class=n>SomeComponents</span><span class=o>&lt;</span><span class=n>Component</span><span class=o>&gt;</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>Component</span><span class=o>*&gt;</span> <span class=n>in</span><span class=p>,</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//默认的构造函数，提供了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Component</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Component</span> <span class=o>*</span><span class=nf>begin</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Component</span> <span class=o>*</span><span class=nf>end</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ComponentLayer</span> <span class=o>:</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Component</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>SomeComponents</span><span class=o>&lt;</span><span class=n>ComponentLayer</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ComponentLayer</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>count</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>emplace_back</span><span class=p>(</span><span class=n>Component</span><span class=p>{});</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Component</span> <span class=n>com</span><span class=p>,</span> <span class=n>com2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ComponentLayer</span> <span class=n>layer</span><span class=p>,</span> <span class=n>layer2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>com</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>com2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>com</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>layer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>layer</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>com</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>layer</span><span class=p>.</span><span class=n>connect_to</span><span class=p>(</span><span class=n>layer2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>方法3: 让我们使用微软提供的Proxy库+facade模式来实现这个蛋疼的问题。这里假设我们实现的多种模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++></code></pre></div></li></ul><h3 class="relative group">9 装饰器模式<div id=9-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#9-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><p>装饰器模式主要解决什么问题？装饰器模式（Decorator Pattern）是一种结构型设计模式，主要用于动态地给对象添加新的功能，而不改变其结构。这一模式通过创建一个装饰对象，也就是包装原始对象，实现了功能的扩展。</p><p>怎么样？是不是听起来就和Mixin Inherence非常的对应？写起来也确实如此。这里注意我们没有使用继承基类，里面包一个基类的引用来实现Dynamic Decorator，而是使用Mixin Inherence来实现Static Decorator</p><p>这里给出两种Static Decorator，一种就是拓展某个对象，另一种是拓展某个函数或者功能</p><ul><li><p>拓展对象，这里假设我们的基础对象是Shape，我们要拓展出来ColorShape和TransparentShape，那么使用Mixin inherence就可以拓展。这里请注意，使用了std::forward，即完美转发，来实现调用基类的方法。这里实际上还有一个问题，就是我们需要限制T必须是继承自最基础的Shape类型，方法有两个</p><ul><li>static_assert(is_base_of_v&lt;Shape, T></li><li>用Concept，这里我使用的是concept</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=n>string</span> <span class=nf>str</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>TransparentShape</span> <span class=o>:</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span> <span class=n>transparency</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span><span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=n>TransparentShape</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint8_t</span> <span class=n>transparency</span><span class=p>,</span> <span class=n>Args</span><span class=p>...</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=o>:</span> <span class=n>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...)</span>
</span></span><span class=line><span class=cl>    	<span class=p>,</span> <span class=n>transparency</span><span class=p>{</span> <span class=n>transparency</span> <span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li><li><p>拓展函数/功能，这里注意，暂存了result这个，来实现及时原先的函数直接返回，也可以插入进入和出来的代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>R</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>Logger3</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Logger3</span><span class=p>(</span><span class=n>function</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=o>:</span> <span class=n>func</span><span class=p>{</span><span class=n>func</span><span class=p>},</span> <span class=n>name</span><span class=p>{</span><span class=n>name</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=n>R</span> <span class=nf>operator</span><span class=p>()</span> <span class=p>(</span><span class=n>Args</span> <span class=p>...</span><span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Entering &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=n>args</span><span class=p>...);</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Exiting &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>function</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span> <span class=p>...)</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li></ul><h3 class="relative group">10 Facade模式<div id=10-facade%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10-facade%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><h3 class="relative group">19 观察者模式<div id=19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F aria-label=锚点>#</a></span></h3><p>观察者模式有很多种不同的类型，一种是属性观察，就是跟踪某个属性的变化。方法很简单，收敛对属性的写操作，每次写操作发生做通知</p><p>通用的实现类型如下</p><pre tabindex=0><code>// 实现方法1.0，这种方法的问题是field_name可能会发生变化
template&lt;typename T&gt; struct Observer
{
 	virtual void field_changed(T&amp; source,
 		const string&amp; field_name) = 0;
};
</code></pre><p>有观察者，必然就有被观察者。被观察者需要实现通知，订阅功能</p><pre tabindex=0><code>template &lt;typename T&gt; struct Observable
{
 	void notify(T&amp; source, const string&amp; name) { ... }
 	void subscribe(Observer&lt;T&gt;* f) { observers.push_back(f); }
 	void unsubscribe(Observer&lt;T&gt;* f) { ... }
private:
 	vector&lt;Observer&lt;T&gt;*&gt; observers;
};

// CRTP丢给Persion
struct Person : Observable&lt;Person&gt;
{
 void set_age(const int age)
 {
 if (this-&gt;age == age) return;
 this-&gt;age = age;
 notify(*this, &#34;age&#34;);
 }
private:
 int age;
};
</code></pre><p>将观察者和被观察者结合到一起</p><pre tabindex=0><code>struct ConsolePersonObserver : Observer&lt;Person&gt;
{
 void field_changed(Person&amp; source,
 const string&amp; field_name) override
 {
 cout &lt;&lt; &#34;Person&#39;s &#34; &lt;&lt; field_name &lt;&lt; &#34; has changed to &#34;
 &lt;&lt; source.get_age() &lt;&lt; &#34;.\n&#34;;
 }
};
</code></pre><p>对于观察者模式，有个非常经典的依赖问题。对于由一个属性变化引起的观察，可以直接在设置函数的时候做变化，但如果是需要依赖两个乃至多个属性呢？甚至如果一个属性的变化会引起多个依赖更新，那么这函数岂不是天天修改？</p><pre tabindex=0><code></code></pre><p>Reentrancy问题</p><p>简化观察者内核，使用Decrator来包裹观察者模式简化使用修改代码的难度。参看下面的内容，PersionView是真正的被观察者</p><pre tabindex=0><code>struct Person
{
 string name;
};


struct PersonView : Observable&lt;Person&gt;
{
 explicit PersonView(const Person&amp; person)
 : person(person) {}
 string&amp; get_name()
 {
 return person.name;
 }
 void set_name(const string&amp; value)
 {
 if (value != person.name) return;
 person.name = value;
 property_changed(person, &#34;name&#34;);
 }
protected:
 Person&amp; person;
};
</code></pre><h1 class="relative group">Template Metaprograming with C++<div id=template-metaprograming-with-c class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#template-metaprograming-with-c aria-label=锚点>#</a></span></h1><p>建议看看这个 <a href=https://www.bilibili.com/video/BV1JK4y1D7Yz/ target=_blank>https://www.bilibili.com/video/BV1JK4y1D7Yz/</a></p><h2 class="relative group">1 基础模板概念<div id=1-%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5 aria-label=锚点>#</a></span></h2><p>有下面几种概念，</p><ul><li>类模板</li><li>函数模板</li><li>区分类模板的成员函数</li><li>区分类成员函数模板</li><li>区分类模板的类成员函数模板</li></ul><p>还有关于类型的一些概念</p><ul><li><p>类型模板参数</p></li><li><p>非类型模板参数</p></li><li><p>双重模板参数</p><ul><li>这两天我在写一个非常扭曲的代码，简单来说就是两个类型互相依赖，最后的解决方法实际上是使用双重模板参数。</li></ul></li><li><p>可变参数模板</p></li></ul><p>关于参数包</p><ul><li><p>可变参数函数模板</p><ul><li><p>关于展开参数包有什么作用，这里注意区分argument和parameter的区别：</p><ul><li><p>模板参数列表（parameter），为模板指定参数</p></li><li><p>模板参数（argument）列表，为模板指定参数</p></li><li><p>函数参数（parameter）列表，为函数模板指定参数</p></li><li><p>函数参数（argument）列表，</p></li><li><p>圆括号初始化列表，展开包出现在直接初始化列表里面、函数样式强制转换或者，成员初始化里面</p></li><li><p>大括号初始化表达式</p></li><li><p>基类说明</p></li><li><p>使用声明</p></li><li><p>Lambda表达式，用于捕获lambda表达式</p></li><li><p>折叠表达式</p></li><li><p>sizeof···操作符</p></li></ul></li></ul></li><li><p>可变参数类模板</p><ul><li>定义<ul><li>可变参数函数模板需要指定带有两个带有重载的递归模式，一个用于一般模式，另一个用于结束</li><li>可变参数类模板也需要同样的方法。</li><li>看代码感觉不太对，看看这个https://medium.com/@r.siddhesh96/lets-learn-recursive-templates-by-implementing-std-tuple-b490933206d0</li></ul></li><li>可变参数模板太麻烦，所以有了折叠表达式。<ul><li>一元左折叠</li><li>一元右折叠</li><li>二元左折叠</li><li>二元右折叠</li></ul></li><li>可变参数别名模板</li><li>可变参数变量模板</li></ul></li></ul><h3 class="relative group">1.S 关于模板互相依赖的问题<div id=1s-%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E4%BA%92%E7%9B%B8%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1s-%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E4%BA%92%E7%9B%B8%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98 aria-label=锚点>#</a></span></h3><p>可以直接看这几个stackoverflow的问题：</p><ul><li><a href=https://stackoverflow.com/questions/213761/what-are-some-uses-of-template-template-parameters/23930985#23930985 target=_blank>https://stackoverflow.com/questions/213761/what-are-some-uses-of-template-template-parameters/23930985#23930985</a></li><li><a href=https://cplusplus.com/forum/general/115940/ target=_blank>https://cplusplus.com/forum/general/115940/</a></li><li><a href=https://stackoverflow.com/questions/34128529/breaking-template-circular-dependencies-by-using-template-template-parameters target=_blank>https://stackoverflow.com/questions/34128529/breaking-template-circular-dependencies-by-using-template-template-parameters</a></li></ul><p>简单来说，一般情况下，我们写代码都是单向依赖，即A依赖B，B依赖C。但是有的时候我们需要让B存储指向A的指针，这种情况下不算严格破坏依赖。如果写的是CC和.h分离的代码，那么具体实现依赖还没什么可说的，但是如果是模板文件，就引发一个问题，即依赖回出现循环</p><p>比方说写几个不同的类型，它们相互依赖。</p><ul><li>template &lt;typename S, typename TaskType> class TCPStream依赖类型S和类型TaskType。其中S需要存储在TCPStream，而TaskType它实际上只是在代码实现中用到了它的代码。</li><li>template &lt;typename TCPStreamType> class Task 它又依赖类型TCPStream，这个类型里面存储了一个指向TCPStream的智能指针。<strong>注意，这里如果两者都互相存储了对端对象，那是不能相互引用的！会造成循环引用，因为必须都先知道具体的内存布局，参考CRTP的解释那部分</strong></li><li>最终出现了一个经典的问题，两个模板类互相依赖，实例化的时候开始报错。</li></ul><p>这个具体的过程可以理解为</p><ol><li>实例化TCPStream且未使用Handle的代码时，暂时不需要实例化TaskType，继续</li><li>某阶段需要用到Handle的代码，实例化TaskType，发现Tasktype实际上也是个模板类。此时去实例化TaskType</li><li>发现TaskType还需要参数，此时如果把TCPStream再传递进去就无穷无尽了。</li></ol><p>可以简化为如下的代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// TCPStream 需要使用Task，而Task又需要使用TCPStream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>S</span><span class=p>,</span> <span class=k>typename</span> <span class=n>TaskType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TCPStream</span>
</span></span><span class=line><span class=cl>  <span class=n>S</span> <span class=n>socket_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>&amp;</span><span class=n>GetSocket</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>socket_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Handle</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TaskType</span><span class=o>&gt;</span> <span class=n>task</span> <span class=o>=</span> <span class=n>TaskType</span><span class=o>::</span><span class=n>Create</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>task</span><span class=o>-&gt;</span><span class=n>xxx</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=c1>// do something with task
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TCPStreamType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TCPStreamType</span><span class=o>&gt;</span> <span class=n>GetConnection</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>connection_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TCPStreamType</span><span class=o>&gt;</span> <span class=n>connection_</span><span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>那么如何解决呢？双重模板参数或许是个好的选择。按照下面的方式进行代码更新</p><ol><li><p>Task的代码不变，还是存储指向TCPStreamType的类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TCPStreamType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TCPStreamType</span><span class=o>&gt;</span> <span class=n>GetConnection</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>connection_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TCPStreamType</span><span class=o>&gt;</span> <span class=n>connection_</span><span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li><li><p>修改TCPStream的类型，指明它的第二个参数是个模板类。简单来说就是，这是一个双重模板参数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>S</span><span class=p>,</span> <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>DetectionTaskType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TCPStream</span>
</span></span><span class=line><span class=cl>  <span class=n>S</span> <span class=n>socket_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>&amp;</span><span class=n>GetSocket</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>socket_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Handle</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TaskType</span><span class=o>&gt;</span> <span class=n>task</span> <span class=o>=</span> <span class=n>TaskType</span><span class=o>::</span><span class=n>Create</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>task</span><span class=o>-&gt;</span><span class=n>xxx</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=c1>// do something with task
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li><li><p>注意，这里有个点，<strong>需要在类的内部定义DetectionTaskType包裹自己的情况</strong>。可以看到这里将DetectionTaskType包裹住了TCPStream</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// TCPStream 需要使用Task，而Task又需要使用TCPStream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>S</span><span class=p>,</span> <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>TaskType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TCPStream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 注意这里的TaskType&lt;TCPStream&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>typedef</span> <span class=n>TaskType</span><span class=o>&lt;</span><span class=n>TCPStream</span><span class=o>&gt;</span> <span class=n>WrapperTask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li><li><p>到这里就出现了好玩的东西。接下来是显式实例化。让我们一句一句看。首先在用到两个类的地方使用using显式实例化TCPStream，定义为WrapperTCPStreamT类型。这里注意，首先</p><ol><li>首先typename S，或者说Socket是TCPStream的类成员，它的实例化的时候，已经是一个完整的类型了。实际上除了TCPStream::Handle需要用Task类型，其它都不用</li><li>但是TCPStream::Handle函数还没使用到，换言之，这个时候就不会实例化TCPStream::Handle。所以这个时候对TCPStream的内存布局，类定义的实例化已经结束了。所以此时TCPStream的类定义可以认为完成了。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>using</span> <span class=n>WrapperTCPStreamT</span> <span class=o>=</span> <span class=n>TCPStream</span><span class=o>&lt;</span><span class=n>Socket</span><span class=p>,</span> <span class=n>Task</span><span class=o>&gt;</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>接下来，再使用另一个using来显式实例化Task类型。这个时候，实际上我们也没有实例化刚才的TCPStream::Handle函数。时候我们拿到了的WrapperTaskT，实际上是TaskType&lt;TCPStream>。而这个时候TCPStream已经完成了类定义。这个时候TaskType内部需要的TCPStreamType类型已经是具体的类了，它并不依赖Task类型。所以TaskType实例化完成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>using</span> <span class=n>WrapperTaskT</span> <span class=o>=</span> <span class=n>WrapperTCPStreamT</span><span class=o>::</span><span class=n>WrapperTask</span><span class=p>;</span>
</span></span></code></pre></div></li></ol><p>解释了上面的东西，我们来改一下代码，做点好玩的东西。假设TaskType内部存储的不是shared_ptr&lt;TCPStreamType>，存储的就是TCPStreamType。那么这段代码还能实例化吗？首先使用理论分析TCPStream可以实例化，因为它的内存布局不需要依赖Task。然后Task依赖的TCPStream已经实例化，所以理论上应该可以实例化。</p><p>具体实现的代码就不写了。</p><h2 class="relative group">2 模板的基本概念<div id=2-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 aria-label=锚点>#</a></span></h2><p>模板实例化是理解模板能够工作的重点，需要重点理解</p><p>模板只是蓝图，编译器在遇到模板时，会根据模板创建实际代码。从模板声明中为函数、类或 变量创建定义的行为称为模板实例化。<strong>这可以是显式的 (告诉编译器何时应该生成定义时)，也可以 是隐式的 (编译器根据需要生成新定义时)</strong></p><h3 class="relative group">2.1 隐式实例化<div id=21-%E9%9A%90%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#21-%E9%9A%90%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96 aria-label=锚点>#</a></span></h3><ul><li><p>对于函数模板，当用户代码在需要函数定义存在的上下文中引用函数时，就会发生隐式实例化。</p></li><li><p>对于类模板，当用户代码在需要完整类型的上下文中引用模板时，或者当类型的完整性影响代码时， 也会隐式实例化。此类上下文是构造此类类型的对象，</p></li><li><p>声明指向类模板的指针时就是另外一种 情况了</p></li></ul><p>比方说</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>foo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>foo</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;*</span> <span class=n>p</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>foo</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>foo</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;*</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>x</span><span class=p>.</span><span class=n>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>q</span><span class=o>-&gt;</span><span class=n>g</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过这些更改，编译器需要实例化以下内容:</p><ul><li>当声明 x 变量时，实例化 foo&lt;int></li><li>当 x.f() 调用发生时，实例化 foo&lt;int>::f()</li><li>当 q->g() 调用发生时，实例化 foo&lt;double> 和 foo&lt;double>::g()。</li></ul><p>另外，当声明指针 p 时，编译器不需要实例化 foo&lt;int>;当声明指针 q 时，也不需要实例化 foo&lt;double></p><p>简单总结就是，隐式实例化声明指针时不会实例化，声明对象时只实例化内存部分。只有实例化函数调用才会显示实例化对应的函数（和内存布局，如果原先没实例化内存布局）</p><h3 class="relative group">2.2 显式实例化<div id=22-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#22-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96 aria-label=锚点>#</a></span></h3><p>可以显式地告诉编译器实例化类模板或函数模板，这称为显式实例化。它有两种形式: <strong>显式实例化定义</strong>和<strong>显式实例化声明</strong>。</p><h4 class="relative group">2.2.1 显式实例化定义<div id=221-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%9A%E4%B9%89 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#221-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%9A%E4%B9%89 aria-label=锚点>#</a></span></h4><p>显式实例化定义实际上是传入类模板参数，定义出来类型。语法如下（如果包含namepsace，那么显示实例化定义需要包含namespace之类的信息，也叫做完全限定）。其中[1]和[2]是显式的定义。函数定义同样如此，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 类定义显式实例化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=k>class</span><span class=err>-</span><span class=nc>key</span> <span class=k>template</span><span class=o>-</span><span class=n>name</span> <span class=o>&lt;</span><span class=n>argument</span><span class=o>-</span><span class=n>list</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 函数定义显式实例化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=k>return</span><span class=o>-</span><span class=n>type</span> <span class=n>name</span><span class=o>&lt;</span><span class=n>argument</span><span class=o>-</span><span class=n>list</span><span class=o>&gt;</span><span class=p>(</span><span class=n>parameter</span><span class=o>-</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=k>return</span><span class=o>-</span><span class=n>type</span> <span class=n>name</span><span class=p>(</span><span class=n>parameter</span><span class=o>-</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>ns</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>wrapper</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=k>struct</span> <span class=nc>wrapper</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=k>struct</span> <span class=nc>ns</span><span class=o>::</span><span class=n>wrapper</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{}</span>
</span></span></code></pre></div><h4 class="relative group">2.2.2 显式实例化声明<div id=222-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A3%B0%E6%98%8E class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#222-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A3%B0%E6%98%8E aria-label=锚点>#</a></span></h4><h2 class="relative group">4 高级模板概念<div id=4-%E9%AB%98%E7%BA%A7%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4-%E9%AB%98%E7%BA%A7%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5 aria-label=锚点>#</a></span></h2><h3 class="relative group">4.1 名称绑定和依赖名称<div id=41-%E5%90%8D%E7%A7%B0%E7%BB%91%E5%AE%9A%E5%92%8C%E4%BE%9D%E8%B5%96%E5%90%8D%E7%A7%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#41-%E5%90%8D%E7%A7%B0%E7%BB%91%E5%AE%9A%E5%92%8C%E4%BE%9D%E8%B5%96%E5%90%8D%E7%A7%B0 aria-label=锚点>#</a></span></h3><p>首先需要理解名称绑定和依赖名称</p><ul><li><p>名称绑定和依赖名称：</p><ul><li><p>依赖名称和非依赖名称的定义</p><ul><li>依赖名称：依赖模板参数的类型或值的名称，可以是类型参数、非类型形参或模板参数。•依赖名称，在模板实例化时执行。</li><li>非依赖名称：不依赖于模板参数的名称称为非依赖名称。• 非依赖名称，则在模板定义时执行。</li></ul></li><li><p>依赖名称和非依赖名称的绑定</p><ul><li><p>For a <a href=https://en.cppreference.com/w/cpp/language/dependent_name target=_blank>non-dependent name</a> used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a <a href=https://en.cppreference.com/w/cpp/language/dependent_name target=_blank>dependent name</a> used in a template definition, the lookup is postponed until the template arguments are known, at which time <a href=https://en.cppreference.com/w/cpp/language/adl target=_blank>ADL</a> examines function declarations with external linkage(until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage(until C++11) that are visible from the template definition context (in other words, adding a new function declaration after template definition does not make it visible except via ADL). The behavior is undefined if there is a better match with external linkage in the namespaces examined by the ADL lookup, declared in some other translation unit, or if the lookup would have been ambiguous if those translation units were examined. In any case, if a base class depends on a template parameter, its scope is not examined by unqualified name lookup (neither at the point of definition nor at the point of instantiation).</p><blockquote><p>看下这个解释：https://stackoverflow.com/questions/63392144/when-is-adl-lookup-is-considered-for-unqualified-dependent-name</p></blockquote></li></ul></li></ul></li></ul><p>理解两种名称之后，就需要知道名称查找的流程</p><h3 class="relative group">4.2 两阶段名称查找<div id=42-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%90%8D%E7%A7%B0%E6%9F%A5%E6%89%BE class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#42-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%90%8D%E7%A7%B0%E6%9F%A5%E6%89%BE aria-label=锚点>#</a></span></h3><p>模板的实例化会分为两个阶段:</p><ul><li>第一个阶段发生在定义时，检查模板语法并将名称分类为依赖或非依赖。</li><li>第二个阶段发生在实例化时，此时模板实参替换为模板参数。依赖名称的绑定这时发生。</li></ul><p>这个分为两步的过程称为两阶段名称查找</p><h3 class="relative group">4.3 如果依赖名称是一个类型？<div id=43-%E5%A6%82%E6%9E%9C%E4%BE%9D%E8%B5%96%E5%90%8D%E7%A7%B0%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#43-%E5%A6%82%E6%9E%9C%E4%BE%9D%E8%B5%96%E5%90%8D%E7%A7%B0%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B aria-label=锚点>#</a></span></h3><p>需要显示指定这个类型是谁的类型。</p><h3 class="relative group">4.4 依赖模板的名称？<div id=44-%E4%BE%9D%E8%B5%96%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%90%8D%E7%A7%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#44-%E4%BE%9D%E8%B5%96%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%90%8D%E7%A7%B0 aria-label=锚点>#</a></span></h3><p>某些情况下，依赖名称是模板，例如函数模板或类模板。但编译器的默认行为是将依赖项名称解释为非类型</p><h3 class="relative group">4.5 模板特化<div id=45-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#45-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96 aria-label=锚点>#</a></span></h3><ul><li>转发引用</li><li>decltype：这个下面是简单理解的方式，想要精确理解看https://en.cppreference.com/w/cpp/language/decltype。注意delcltype只是查询操作数的类型，如果操作数是表达式，并不会真的执行对应的表达式<ol><li>解析过程<ol><li>若表达式是标识符或类成员访问,则结果是由表达式命名的实体类型。若实体不存在,或者是具有重载集的函数(存在多个同名函数),编译器将报错。</li><li>若表达式是函数调用或重载操作符函数,则结果为函数白的返回类型。若重载的操作符括在括号中,则忽略这些操作符。</li><li>若表达式是左值,则结果类型是对表达式类型的左值引用。</li><li>若表达式为其他类型,则结果类型为表达式的类型。</li><li>decltype表达式中使用的对象的const或volatile说明符不构成推导的类型。</li><li>对象或指针表达式是左值还是右值并不影响推导的类型。</li><li>若数据成员访问表达式括号括起来,例如decltype((expression),则前两条规则不适用。对象的const或volatile限定符确实会影响推导的类型,包括对象的值。这个说白了就是左值右值会影响表达式的类型，现在可能出现decltype是右值的情况，原先的操作数包上了（）就变成了表达式</li></ol></li><li>注意事项,参考https://cplusplus.com/forum/general/285738/，注意decltype(auto) 和auto区分的情况。这里使用decltype隐藏着传递引用回来，而如果是auto实际上是隐藏copy</li></ol></li><li>declval</li><li>模板的友情：如果希望严格控制模板友元的使用，参考律师客户模式</li><li>模板实例化</li></ul><h2 class="relative group">5 类型特征和条件编译<div id=5-%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91 aria-label=锚点>#</a></span></h2><ul><li><p>类型特征</p></li><li><p>SFINAE：</p><ul><li><p>SFINAE表示替换失败而不是错误。给一个SFINAE的例子，这里第二个参数是char(*)[1]或者是char(*)[0]，char(*)[0]对应SFINAE错误</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>size</span> <span class=n>t</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>handle</span><span class=p>(</span><span class=n>T</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arr</span><span class=p>)</span> <span class=p>[</span><span class=n>N</span><span class=p>],</span> <span class=kt>char</span><span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=p>[</span><span class=n>N</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;handle even array</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>size</span> <span class=n>t</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>handle</span><span class=p>(</span><span class=n>T</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arr</span><span class=p>)</span> <span class=p>[</span><span class=n>N</span><span class=p>],</span> <span class=kt>char</span><span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=p>[</span><span class=n>N</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>1</span><span class=p>]</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;handle odd array</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr1</span><span class=p>[]{</span> <span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>handle</span> <span class=p>(</span><span class=n>arr1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr2</span><span class=p>[]{</span> <span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>handle</span> <span class=p>(</span><span class=n>arr2</span><span class=p>);</span>
</span></span></code></pre></div></li><li><p>SFINAE只适用用模板声明（模板参数列表，函数返回类型，函数参数列表）</p></li></ul></li><li><p>enable_if：只有定义出来的东西为真才能使用对应type的东西。这里需要注意template &lt; typename T = void >的含义，参考https://stackoverflow.com/questions/34459640/what-does-typename-enable-void-mean。这里参考https://en.cppreference.com/w/cpp/types/enable_if也可。这里给一个经典的错误</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_integral_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;::</span><span class=n>type</span><span class=o>*</span> <span class=o>=</span> <span class=k>nullptr</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>output</span><span class=p>(</span><span class=n>T</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;value is &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hahahaha&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>output</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>output</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=k>nullptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 这里注意，对函数取地址是void(*)()，即函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// void*是通用指针
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>output</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>same_as</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=p>),</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=p>)()</span><span class=o>&gt;</span><span class=p>,</span> <span class=s>&#34;void(*)()&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p>用途</p><ul><li><p>定义具有默认参数的模板参数。参考</p></li><li><p>定义具有默认参数的函数参数。参考</p></li><li><p>指定函数的返回类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//std::enable_if_t，是
</span></span></span></code></pre></div></li></ul></li></ul></li><li><p>constexpr if</p></li><li><p>使用模板来构建范型函数，std::void_t 参考https://en.cppreference.com/w/cpp/types/void_t。这里有个很好玩的点，参考</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=k>struct</span> <span class=nc>has_common_type</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>false_type</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=k>struct</span> <span class=nc>has_common_type</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>void_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>common_type_t</span><span class=o>&lt;</span><span class=n>Ts</span><span class=p>...</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=n>Ts</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>true_type</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=k>constexpr</span> <span class=kt>bool</span> <span class=n>has_common_type_v</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=k>sizeof</span><span class=p>...(</span><span class=n>Ts</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>2</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>      <span class=n>has_common_type</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>,</span> <span class=n>Ts</span><span class=p>...</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 如果std::common_type_t&lt;Ts...&gt;有结果，
</span></span></span><span class=line><span class=cl><span class=c1>// 为什么这里的has_common_type&lt;void, Ts...&gt;不会直接解析到
</span></span></span><span class=line><span class=cl><span class=c1>// 上面的template &lt;typename, typename... Ts&gt; struct has_common_type : std::false_type {};
</span></span></span></code></pre></div><p>解释如下：</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>has_common_type</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>false_type</span> <span class=p>{};</span>
</span></span></code></pre></div><ul><li>默认情况下，<code>has_common_type</code>继承自<code>std::false_type</code>，意味着如果没有找到特定的特化版本，它将返回<code>false</code>。</li></ul></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>has_common_type</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>void_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>common_type_t</span><span class=o>&lt;</span><span class=n>Ts</span><span class=p>...</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=n>Ts</span><span class=p>...</span><span class=o>&gt;</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>true_type</span> <span class=p>{};</span>
</span></span></code></pre></div><ul><li><p>这个特化版本用来检测<code>std::common_type_t&lt;Ts...></code>是否有效。<code>std::void_t&lt;...></code>是一种典型的SFINAE技巧，它将类型转换为<code>void</code>，以便进行特化匹配。</p><p>如果<code>std::common_type_t&lt;Ts...></code>是一个有效类型，那么<code>std::void_t&lt;std::common_type_t&lt;Ts...>></code>也是一个有效类型，从而使得该特化匹配，并<code>has_common_type</code>继承<code>std::true_type</code>。这里注意，在<code>std::common_type_t&lt;Ts...></code>是否有效时，这个特化的例子实际上是被变成了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>has_common_type</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>,</span>  <span class=n>Ts</span><span class=p>...</span><span class=o>&gt;</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>true_type</span> <span class=p>{};</span>
</span></span></code></pre></div><p>所以命中的时候会优先命中这种代码</p></li></ul></li><li><p><code>has_common_type&lt;void, Ts...>::value</code>需要判断<code>std::common_type_t&lt;Ts...></code>的可用性：</p><ul><li><p>如果<code>std::common_type_t&lt;Ts...></code>可以成功计算，那么在积分该特化时，<code>std::void_t&lt;std::common_type_t&lt;Ts...>></code>是有效类型。因此<code>has_common_type</code>的这一特化将被选择为最匹配的特化，并导致<code>has_common_type&lt;void, Ts...>::value</code>为<code>true</code>。</p></li><li><p>如果<code>std::common_type_t&lt;Ts...></code>不能成功计算，那么<code>std::void_t&lt;std::common_type_t&lt;Ts...>></code>将导致类型替换失败（但由于SFINAE，这不是一个编译错误）。在这种情况下，特化匹配失败，编译器将退回至基本模板，导致<code>has_common_type&lt;void, Ts...>::value</code>为<code>false</code>。</p></li></ul></li></ul></li></ul><p><em><strong>在看has_common_type&lt;void, Ts&mldr;>的时候，我实际上犯了一个错误，也就是我认为是直接把void, Ts&mldr;带入到has_common_type的第二个表达式里面，变成has_common_type&lt;std::void_t&lt;std::common_type_t&lt;void, Ts&mldr;&#187;, void, Ts&mldr;>。实际上我后来又看了下https://stackoverflow.com/questions/27687389/how-do-we-use-void-t-for-sfinae 才反应过来哪里错了。因为特化本质是比较因为很有意思，所以另起一段：</strong></em></p><ol><li><p>在将类型实例化之后，对于默认的类型<code>template &lt;typename, typename... Ts> struct has_common_type : std::false_type {};</code>是必然吻合的，因为此时第一个类型是占位符。所以主模板必然匹配。</p></li><li><p>接下来进行特化模板的匹配，这个时候注意并不是将直接把void, Ts&mldr;带入到has_common_type的第二个表达式里面，变成has_common_type&lt;std::void_t&lt;std::common_type_t&lt;void, Ts&mldr;&#187;, void, Ts&mldr;>。恰恰相反，这个时候匹配的是将所谓的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>has_common_type</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这个Ts...是下面那个Ts...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span><span class=p>,</span> <span class=n>Ts</span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span></code></pre></div><p>和</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 上面的代码块的Ts不和这个跟在template &lt;typename...之后的Ts&gt;对应
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>has_common_type</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 上面的代码块的Ts...和下面的这个Ts...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>void_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>common_type_t</span><span class=o>&lt;</span><span class=n>Ts</span><span class=p>...</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=n>Ts</span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span></code></pre></div><p>也就是说这个时候执行的是<em><strong>template argument deduction.</strong></em>。这里的重点是理解下面代码块的Ts&mldr;和上面代码块的Ts&mldr;对应，而不是和这个地方认为是作为模板参数的，即跟在<code>template &lt;typename...之后的Ts></code>对应。</p></li><li><p>编译器这个时候开始推测了，因为编译器并不能确定void和<code>std::void_t&lt;std::common_type_t&lt;Ts...>></code>对应，所以这个时候，实际上编译器只能deduce出来Ts&mldr;是后面的Ts&mldr;</p></li><li><p>知道Ts&mldr;和后面匹配后，放到<code>std::void_t&lt;std::common_type_t&lt;Ts...>></code>里面看看能不能匹配，这个时候执行替换发现，欸嘿，刚好匹配。</p></li><li><p>最后一步，是选择匹配的模板，确定和哪个一致</p></li></ol><p>这里用个例子来说明，假设我现在要判断&lt;uint32_t, int, double>的情况，自然就有</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>has_common_type_v</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=o>=</span> <span class=n>has_common_type</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>,</span> <span class=n>Ts</span><span class=p>...</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>;</span> <span class=o>=</span> <span class=n>has_common_type</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>,</span> <span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><p>首先，has_common_type&lt;void,uint32_t, int, double>和主模板必然匹配</p></li><li><p>接下来判断能不能命中部分类型</p><ul><li><p>接下来判断has_common_type&lt;void, uint32_t, int, double>能不能特化。先试试看是匹配</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>has_common_type</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>void_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>common_type_t</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=kt>uint32_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span></code></pre></div><p>发现std::void_t&lt;std::common_type_t&lt;uint32_t, int, double&#187;,就是void。所以如果Ts&mldr;当成uint32_t, int, double，是可以命中特化的。</p></li><li><p>接下来判断has_common_type&lt;void,uint32_t, int, double>是不是和下面这个东西匹配，也就是Ts&mldr;能不能是除了uint32_t, int, double，之外的任何东西，比方说int, double。肯定不可能，因为要匹配必须数量一致，而且类型一致（前提是能有common type，否则就回退到别的地方去了）</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>has_common_type</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>void_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>common_type_t</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 也就是这个东西，绝对不可能
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>has_common_type</span> <span class=o>&lt;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span><span class=p>,</span> <span class=kt>int</span> <span class=p>,</span> <span class=kt>double</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span></code></pre></div></li><li><p>现在可以确定几个模板里面，特化模板可以确定，就选它了。</p></li></ul><p>可以看看这个https://gist.github.com/jefftrull/ff6083e2e92fdabb62f6</p><h2 class="relative group">6 概念和约束<div id=6-%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6-%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F aria-label=锚点>#</a></span></h2><ul><li><p>requires</p><ul><li>定义<ul><li>requires子句</li><li>requires表达式</li></ul></li><li>requires内的内容<ul><li>简单需求：</li><li>类型需求：</li></ul></li></ul></li><li><p>concept: 这里注意有个问题。就是Concept和CRTP冲突了。比方说下面的代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>JobImpl</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>requires</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span><span class=p>.</span><span class=n>GetJobDone</span><span class=p>()</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span><span class=p>.</span><span class=n>OutputName</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=n>JobImpl</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Job</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>T</span> <span class=n>CreateJob</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Done</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetJobDone</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>执行构建的话，会报错：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>note: because <span class=s1>&#39;a.GetJobDone()&#39;</span> would be invalid: member access into incomplete <span class=nb>type</span> <span class=s1>&#39;XXX&#39;</span>
</span></span></code></pre></div><p>什么原因呢？解释起来，原因就是在派生类继承基类时，其类型尚未完整，导致直接约束基类模板参数时概念检查失败。</p><p>那么怎么解决呢？很简单，因为类的定义incomplete，所以把检查滞后就可以了。这里改成检查在函数滞后就可以了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>JobImpl</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>  <span class=k>requires</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span><span class=p>.</span><span class=n>GetJobDone</span><span class=p>()</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span><span class=p>.</span><span class=n>OutputName</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 注意这里
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Job</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>T</span> <span class=n>CreateJob</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//注意这里
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Done</span><span class=p>()</span> <span class=k>requires</span> <span class=n>JobImpl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>GetJobDone</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></li></ul><h2 class="relative group">7 模式和习语<div id=7-%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B9%A0%E8%AF%AD class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#7-%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B9%A0%E8%AF%AD aria-label=锚点>#</a></span></h2><ul><li><p>MIXIN Inheritence</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyT</span> <span class=o>:</span> <span class=n>T</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MyT</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>int_my_t</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>CRTP</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Amount</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span> <span class=k>const</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>).</span><span class=n>realGetValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyAmount</span> <span class=o>:</span> <span class=n>Amount</span><span class=o>&lt;</span><span class=n>MyAmount</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>realGetValue</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>关于CRTP和Mixin Inherience有两个经典的问题，即：<ul><li><p>为什么CRTP传递进去的派生类是不完整的，它可以被派生类继承呢？简单解释就是C++对于模板的实例化是分阶段的，它只需要知道内存布局，而函数的实例化是在真正调用的位置才触发的。参考上面CRTP的例子来说，它的实例化流程如下，因此CRTP成立。但是如果Amount里面需要存储传递进去的T，它需要知道内存布局的时候，就不行了</p><ol><li>Amount将MyAmount作为模板参数的时候，它并不需要知道MyAmount的内存布局，因为它不是继承，只是一个类型，它只有函数，不需要存储MyAmount的内存。</li><li>MyAmount提供了Amount函数实现里面的realGetValue。</li><li>Amount拿到了MyAmount的realGetValue函数，其getValue完整了。</li><li>MyAmount此时继承Amount的时候，它知道自己的内存布局，也拿到了Amount包裹之后的函数</li></ol></li><li><p>为什么Mixin Inherience的派生类，就必须是完整定义的呢？因为MyT继承自T，它必须知道T的内存布局，所以T必须是一个完整定义的类型</p></li></ul></li></ul></li><li><p>类型擦除</p></li><li><p>标记分派</p></li><li><p>表达式模板</p></li></ul><h2 class="relative group">8 范围和算法<div id=8-%E8%8C%83%E5%9B%B4%E5%92%8C%E7%AE%97%E6%B3%95 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#8-%E8%8C%83%E5%9B%B4%E5%92%8C%E7%AE%97%E6%B3%95 aria-label=锚点>#</a></span></h2><h2 class="relative group">结尾<div id=%E7%BB%93%E5%B0%BE class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BB%93%E5%B0%BE aria-label=锚点>#</a></span></h2><p>唉，尴尬</p><p><figure><img class="my-0 rounded-md" loading=lazy src=https://i.loli.net/2020/08/27/BFHNyfpx3EsIDUG.jpg alt=狗头的赞赏码.jpg></figure></p></div></div><script>var oid="views_posts\\2024-07-04-C++20设计模式\\index.md",oid_likes="likes_posts\\2024-07-04-C++20设计模式\\index.md"</script><script type=text/javascript src=/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q+oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/2024-05-10-suricata/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">2024-05-10-suricata</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2024-05-10T00:00:00+00:00>2024 年 5 月 10 日</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/posts/2020-08-27-tls1.3%E5%AF%86%E9%92%A5%E8%A1%8D%E7%94%9F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E5%8A%9F%E8%83%BD/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">TLS1.3 密钥衍生计算方法和功能</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2024-08-09T23:24:22+08:00>2024 年 8 月 9 日</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">© 2025 - 2025 菜狗 All Rights Reserved.</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://hxndg.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>