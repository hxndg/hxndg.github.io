<!doctype html><html lang=cn dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>C++开发工具库 &#183; 菜狗的blog</title>
<meta name=title content="C++开发工具库 &#183; 菜狗的blog"><meta name=description content="菜狗's website"><meta name=keywords content="TOOLS,C++,"><link rel=canonical href=https://hxndg.github.io/posts/2021-07-21-c++%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%BA%93/><link type=text/css rel=stylesheet href=/css/main.bundle.min.ba3775bebd52a2b4837f8da64e32ee36e5c52bf284a0ce2262562782398b701543947527ad1498487717b1b96fe2a4e48d365a02e0b5d00e224893052e99d83c.css integrity="sha512-ujd1vr1SorSDf42mTjLuNuXFK/KEoM4iYlYngjmLcBVDlHUnrRSYSHcXsblv4qTkjTZaAuC10A4iSJMFLpnYPA=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.764eb2fe8d6a6b086c7c58f87d12c64fa79a7585117fc27eb53f688f80c287a6eff16277f9d186cd223a39ff700e294d64482834faece5e07ee0498fa042d056.js integrity="sha512-dk6y/o1qawhsfFj4fRLGT6eadYURf8J+tT9oj4DCh6bv8WJ3+dGGzSI6Of9wDilNZEgoNPrs5eB+4EmPoELQVg==" data-copy data-copied></script><script src=/lib/zoom/zoom.min.3530c2657381259433194af312ec3d322a97a2ad85661810299757fe793b24c3b8e07ab97fa8e5cf96cff1208f271e75394b6eaa56c2e39e7e2c3ca49fb1921c.js integrity="sha512-NTDCZXOBJZQzGUrzEuw9MiqXoq2FZhgQKZdX/nk7JMO44Hq5f6jlz5bP8SCPJx51OUtuqlbC455+LDykn7GSHA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://hxndg.github.io/posts/2021-07-21-c++%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%BA%93/"><meta property="og:site_name" content="菜狗的blog"><meta property="og:title" content="C++开发工具库"><meta property="og:description" content="菜狗's website"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-21T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-21T00:00:00+00:00"><meta property="article:tag" content="TOOLS"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++开发工具库"><meta name=twitter:description content="菜狗's website"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"C\u002b\u002b开发工具库","headline":"C\u002b\u002b开发工具库","inLanguage":"zh-cn","url":"https:\/\/hxndg.github.io\/posts\/2021-07-21-c\u002b\u002b%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%BA%93\/","author":{"@type":"Person","name":"菜狗"},"copyrightYear":"2021","dateCreated":"2021-07-21T00:00:00\u002b00:00","datePublished":"2021-07-21T00:00:00\u002b00:00","dateModified":"2021-07-21T00:00:00\u002b00:00","keywords":["TOOLS","C++"],"mainEntityOfPage":"true","wordCount":"17327"}]</script><meta name=author content="菜狗"><script src=/lib/jquery/jquery.slim.min.03cb160e3cfdb2667a2e2c80d283bebcf63ff8bbc4b629c9ab2babf6fae1d0c07ad470edae783efa4fabda2ac01c58d60e63b98b3c336be8208460f08f4354f5.js integrity="sha512-A8sWDjz9smZ6LiyA0oO+vPY/+LvEtinJqyur9vrh0MB61HDtrng++k+r2irAHFjWDmO5izwza+gghGDwj0NU9Q=="></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">菜狗的blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Home</p></a><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Posts</p></a><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Tags</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Home</p></a></li><li class=mt-1><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Posts</p></a></li><li class=mt-1><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Tags</p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">C++开发工具库</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2021-07-21T00:00:00+00:00>2021 年 7 月 21 日</time><span class="px-2 text-primary-500">&#183;</span><span>17327 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>35 分钟</span></div></div><div class="flex author"><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">菜狗</div><div class="text-sm text-neutral-700 dark:text-neutral-400">Focus</div><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1-并发多线程map>1 并发多线程map</a></li><li><a href=#2-并发lru实现>2 并发LRU实现</a></li><li><a href=#3-一个线程安全的连接池>3 一个线程安全的连接池</a></li><li><a href=#5-openssl签名验证签名代码>5 OPENSSL签名验证签名代码</a></li><li><a href=#6--log库>6 log库</a><ul><li><a href=#61-boost-log使用版本>6.1 boost log使用版本</a></li><li><a href=#62-spdlog>6.2 spdlog</a></li><li><a href=#7-varint编解码>7 varint编解码</a></li></ul></li><li><a href=#8-io-计算分离>8 IO 计算分离</a></li><li><a href=#8-io分离>8++ IO分离</a></li><li><a href=#9-c-环形队列>9 C++ 环形队列</a><ul><li><a href=#91-原理>9.1 原理</a></li></ul></li><li><a href=#10-线程池>10 线程池</a><ul><li><ul><li><a href=#stdfuture--stdpackaged_task>std::future && std::packaged_task</a></li></ul></li></ul></li><li><a href=#11-lfbb的实现>11 LFBB的实现</a></li><li><a href=#12-mpmc--spsc>12 MPMC & SPSC</a></li><li><a href=#13-token-bucket>13 Token Bucket</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1-并发多线程map>1 并发多线程map</a></li><li><a href=#2-并发lru实现>2 并发LRU实现</a></li><li><a href=#3-一个线程安全的连接池>3 一个线程安全的连接池</a></li><li><a href=#5-openssl签名验证签名代码>5 OPENSSL签名验证签名代码</a></li><li><a href=#6--log库>6 log库</a><ul><li><a href=#61-boost-log使用版本>6.1 boost log使用版本</a></li><li><a href=#62-spdlog>6.2 spdlog</a></li><li><a href=#7-varint编解码>7 varint编解码</a></li></ul></li><li><a href=#8-io-计算分离>8 IO 计算分离</a></li><li><a href=#8-io分离>8++ IO分离</a></li><li><a href=#9-c-环形队列>9 C++ 环形队列</a><ul><li><a href=#91-原理>9.1 原理</a></li></ul></li><li><a href=#10-线程池>10 线程池</a><ul><li><ul><li><a href=#stdfuture--stdpackaged_task>std::future && std::packaged_task</a></li></ul></li></ul></li><li><a href=#11-lfbb的实现>11 LFBB的实现</a></li><li><a href=#12-mpmc--spsc>12 MPMC & SPSC</a></li><li><a href=#13-token-bucket>13 Token Bucket</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div></details><script>var margin=200,marginError=50;(function(){var t=$(window),e=$("#TOCView"),s=e.height();function n(){var n=t.height()-margin;s>=n?(e.css("overflow-y","scroll"),e.css("max-height",n+marginError+"px")):(e.css("overflow-y","hidden"),e.css("max-height","9999999px"))}t.on("resize",n),$(document).ready(n)})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><h1 class="relative group">C++开发工具库<div id=c%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%BA%93 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#c%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%BA%93 aria-label=锚点>#</a></span></h1><h2 class="relative group">1 并发多线程map<div id=1-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8Bmap class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8Bmap aria-label=锚点>#</a></span></h2><p>坦白讲核心思想都是一样子的，多个bucket，然后每个bucket下面挂一个红黑树(实际上就是stl的map），红黑树使用boost的读写锁来保护，源代码里面我禁用了拷贝构造和赋值运算符，因为RA2（锁）不可拷贝是一个通识，如果想拷贝那么就注释调宏标记的地方，但是尽量建议使用shared_ptr来做这个事情。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#ifndef __CONCURRENT_MAP_H__
</span></span></span><span class=line><span class=cl><span class=cp>#define __CONCURRENT_MAP_H__
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/thread/locks.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/thread/shared_mutex.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 使用此代码时请注意，直接用.h文件，不要写.cpp，使用置入式模型*/</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>boost</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* bucket的代码没什么难度，只需要注意一点，更新和插入的区别。 更新是原先必须有这个值 */</span>
</span></span><span class=line><span class=cl><span class=cm>/* 因为每次查询更新数据都只会锁住一个元素，不会锁住多个元素，所以不会产生死锁 */</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>KEY_T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>VALUE_T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Compare</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcurrentBucket</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentBucket</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=o>~</span><span class=n>ConcurrentBucket</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=nf>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>map_</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Lookup</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 锁单独的生命周期要短，最好不要和原子变量混在一起 */</span>
</span></span><span class=line><span class=cl>            <span class=n>read_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>find</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>find</span> <span class=o>!=</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>value</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>find</span><span class=p>).</span><span class=n>second</span><span class=p>;</span>   <span class=cm>/* 从生成的代码来看，编译器会生成一个默认的赋值运算符函数，每个对象都会执行拷贝 */</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=nf>Size</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>read_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>map_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>Clear</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>map_</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Contain</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 锁单独的生命周期要短，最好不要和原子变量混在一起 */</span>
</span></span><span class=line><span class=cl>            <span class=n>read_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>find</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>find</span> <span class=o>!=</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Insert</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=n>InsertWithoutLock</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Update</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=n>UpdateWithoutLock</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>Remove</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>RemoveWithoutLock</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>GetAllKey</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>read_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span> <span class=p>;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>,</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>UpdateKeyBatch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>list</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>UpdateWithoutLock</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>,</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>InsertKeyBatch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>list</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>InsertWithoutLock</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>,</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>RemoveKeyBatch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>list</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>RemoveWithoutLock</span><span class=p>((</span><span class=o>*</span><span class=n>iter</span><span class=p>));</span>   
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>Echo</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; oh ho&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>      
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>RemoveWithoutLock</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>find</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>find</span> <span class=o>!=</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>map_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>find</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>InsertWithoutLock</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>find</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>find</span> <span class=o>==</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>map_</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>Compare</span><span class=p>()(</span><span class=n>value</span><span class=p>,</span> <span class=n>find</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>))</span> <span class=p>{</span>          
</span></span><span class=line><span class=cl>                    <span class=n>map_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>find</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>map_</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>                    <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>UpdateWithoutLock</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>find</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>find</span> <span class=o>!=</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>Compare</span><span class=p>()(</span><span class=n>value</span><span class=p>,</span> <span class=n>find</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>))</span> <span class=p>{</span>          
</span></span><span class=line><span class=cl>                    <span class=n>map_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>find</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>map_</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>                    <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_lock</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span><span class=o>&gt;</span> <span class=n>read_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>boost</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span><span class=o>&gt;</span> <span class=n>write_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=n>map_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* using boost shared_mutex, boost version 1.6.9 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span> <span class=n>rwlock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>KEY_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>VALUE_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Compare</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Hash</span><span class=o>=</span><span class=n>std</span><span class=o>::</span><span class=n>hash</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcurrentMap</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentMap</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>bucket_nums</span> <span class=o>=</span> <span class=mi>61</span><span class=p>,</span> <span class=n>Hash</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>hasher</span> <span class=o>=</span> <span class=n>Hash</span><span class=p>())</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>buckets_</span><span class=p>(</span><span class=n>bucket_nums</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>hasher_</span> <span class=p>(</span><span class=n>hasher</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>uint64_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>bucket_nums</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>ConcurrentBucket</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=p>,</span> <span class=n>Compare</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>LookUp</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Lookup</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Contain</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Contain</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Insert</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Insert</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Update</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Update</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Delete</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Remove</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>GetAllKey</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#if 0</span><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            //auto iter = buckets_.begin();
</span></span></span><span class=line><span class=cl><span class=c>            //这里要注意，先得对iter做解引用，得到uniqueptr,然后对unique_ptr做解引用或者用-&gt;才能进行调用
</span></span></span><span class=line><span class=cl><span class=c>            typename std::vector&lt;std::unique_ptr&lt;ConcurrentBucket&lt;KEY_T, VALUE_T, Compare&gt; &gt; &gt;::iterator iter = buckets_.begin();
</span></span></span><span class=line><span class=cl><span class=c>            for ( ; iter != buckets_.end(); ++iter ) {
</span></span></span><span class=line><span class=cl><span class=c>                (*iter)-&gt;GetAllKey(list);
</span></span></span><span class=line><span class=cl><span class=c>            }
</span></span></span><span class=line><span class=cl><span class=c></span><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>bucket_index</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>bucket_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>GetAllKey</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>UpdateKeyBatch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 更新数组的个数需要和桶的个数一致 */</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>update_lists</span><span class=p>(</span><span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将更新的元素丢入数组之中 */</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>list</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>size_t</span>  <span class=n>bucket_index</span> <span class=o>=</span> <span class=n>hasher_</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>)</span> <span class=o>%</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>update_lists</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>,</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将对应的元素更新到对应的bucket里面 */</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>bucket_index</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>bucket_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>UpdateKeyBatch</span><span class=p>(</span><span class=n>update_lists</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>RemoveKeyBatch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 删除数组的个数需要和桶的个数一致 */</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>remove_lists</span><span class=p>(</span><span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将删除的元素丢入数组之中 */</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>list</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>size_t</span>  <span class=n>bucket_index</span> <span class=o>=</span> <span class=n>hasher_</span><span class=p>(</span><span class=o>*</span><span class=n>iter</span><span class=p>)</span> <span class=o>%</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>remove_lists</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=o>*</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将对应的元素更新到对应的bucket里面 */</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>bucket_index</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>bucket_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>RemoveKeyBatch</span><span class=p>(</span><span class=n>remove_lists</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>InsertKeyBatch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 更新数组的个数需要和桶的个数一致 */</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>Insert_lists</span><span class=p>(</span><span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将更新的元素丢入数组之中 */</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(;</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>list</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>size_t</span>  <span class=n>bucket_index</span> <span class=o>=</span> <span class=n>hasher_</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>)</span> <span class=o>%</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>Insert_lists</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>,</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将对应的元素更新到对应的bucket里面 */</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>bucket_index</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>bucket_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>InsertKeyBatch</span><span class=p>(</span><span class=n>Insert_lists</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentBucket</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=p>,</span> <span class=n>Compare</span><span class=o>&gt;&amp;</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>KEY_T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=k>const</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=n>hasher_</span><span class=p>(</span><span class=n>key</span><span class=p>)</span><span class=o>%</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>*</span><span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=nf>Size</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint64_t</span> <span class=n>total_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>total_size</span> <span class=o>+=</span> <span class=n>buckets_</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>Size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>total_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>Clear</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 禁用这两者来保证绝对的安全，主要是本身mutex就是禁止拷贝的*/</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 禁用拷贝构造 */</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentMap</span><span class=p>(</span><span class=n>ConcurrentMap</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 禁用赋值运算符 */</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentMap</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>ConcurrentMap</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if 0</span><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>        /* 线程安全的拷贝构造函数 */
</span></span></span><span class=line><span class=cl><span class=c>        ConcurrentMap(ConcurrentMap const &amp;other) :
</span></span></span><span class=line><span class=cl><span class=c>            buckets_(other.buckets_.size()), 
</span></span></span><span class=line><span class=cl><span class=c>            hasher_(other.hasher_) {
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            for (uint64_t i = 0; i &lt; buckets_.size(); ++i) {
</span></span></span><span class=line><span class=cl><span class=c>                buckets_[i].reset(new ConcurrentBucket&lt;KEY_T, VALUE_T, Compare&gt;);
</span></span></span><span class=line><span class=cl><span class=c>            }
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            std::vector&lt;std::pair&lt;KEY_T, VALUE_T&gt; &gt; list;
</span></span></span><span class=line><span class=cl><span class=c>            other.GetAllKey(list);
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            InsertKeyBatch(list);
</span></span></span><span class=line><span class=cl><span class=c>        }
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>        ConcurrentMap&amp; operator=(ConcurrentMap const &amp;other) {
</span></span></span><span class=line><span class=cl><span class=c>            /* 务必保证两个bucket的大小一致，不提供可伸缩的bucket*/
</span></span></span><span class=line><span class=cl><span class=c>            assert(buckets_.size() == other.buckets_.size());
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            hasher_ = other.hasher_;
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            for (uint64_t i = 0; i &lt; buckets_.size(); ++i) {
</span></span></span><span class=line><span class=cl><span class=c>                buckets_[i].reset(new ConcurrentBucket&lt;KEY_T, VALUE_T, Compare&gt;);
</span></span></span><span class=line><span class=cl><span class=c>            }
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            std::vector&lt;std::pair&lt;KEY_T, VALUE_T&gt; &gt; list;
</span></span></span><span class=line><span class=cl><span class=c>            other.GetAllKey(list);
</span></span></span><span class=line><span class=cl><span class=c>            InsertKeyBatch(list);
</span></span></span><span class=line><span class=cl><span class=c>        }
</span></span></span><span class=line><span class=cl><span class=c></span><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 使用unique_ptr保证内存安全 */</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>ConcurrentBucket</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=p>,</span> <span class=n>Compare</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>buckets_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Hash</span> <span class=n>hasher_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 class="relative group">2 并发LRU实现<div id=2-%E5%B9%B6%E5%8F%91lru%E5%AE%9E%E7%8E%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%E5%B9%B6%E5%8F%91lru%E5%AE%9E%E7%8E%B0 aria-label=锚点>#</a></span></h2><p>实际上并发LRU的实现和并发MAP是非常相似的，并发MAP是挂了一堆的BUCKET，而并发LRU实际上也是挂了一堆的LRUBucket，然后每个找到对应的LRU。但是这个严格说，并不是完全的LRU，因为它拆分了几个不同的链表出来。我目前在用的时候使用的还是最简单的LRU，性能比较低但是严格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#ifndef __LRU_H__
</span></span></span><span class=line><span class=cl><span class=cp>#define __LRU_H__
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/thread/locks.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/thread/shared_mutex.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;list&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unordered_map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>KEY_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>VALUE_T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LRU</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>LRU</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>capacity</span> <span class=o>=</span> <span class=mi>31</span><span class=p>)</span> <span class=o>:</span> 
</span></span><span class=line><span class=cl>            <span class=n>capacity_</span><span class=p>(</span><span class=n>capacity</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>size_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>Put</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>map_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>iter</span> <span class=o>!=</span> <span class=n>map_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>touch</span><span class=p>(</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>map_</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>capacity_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>map_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>list_</span><span class=p>.</span><span class=n>back</span><span class=p>());</span>
</span></span><span class=line><span class=cl>                    <span class=n>list_</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>list_</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>map_</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>value</span><span class=p>,</span> <span class=n>list_</span><span class=p>.</span><span class=n>begin</span><span class=p>()};</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Get</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>cache_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>iter</span> <span class=o>==</span> <span class=n>cache_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>touch</span><span class=p>(</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>value</span> <span class=o>=</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>first</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 没有的话返回一个新的VALUE_T回去，此时缓存是没有的 */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 如果有的话放到最开始的地方 */</span>
</span></span><span class=line><span class=cl>        <span class=n>VALUE_T</span> <span class=nf>Get</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>cache_</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>iter</span> <span class=o>==</span> <span class=n>cache_</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>VALUE_T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>touch</span><span class=p>(</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>GetAllKey</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>res</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>read_lock</span> <span class=n>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>iter</span> <span class=p>:</span> <span class=n>map_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>iter</span><span class=p>.</span><span class=n>second</span><span class=p>.</span><span class=n>second</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>touch</span><span class=p>(</span><span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>VALUE_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=o>&gt;</span> <span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>KEY_T</span> <span class=n>key</span> <span class=o>=</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>list_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>list_</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>second</span> <span class=o>=</span> <span class=n>list_</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_lock</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span><span class=o>&gt;</span> <span class=n>read_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>boost</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span><span class=o>&gt;</span> <span class=n>write_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>capacity_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span> <span class=n>rwlock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* iterator前面需要加一个typename */</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;</span> <span class=n>list_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>VALUE_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>map_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>KEY_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>VALUE_T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Hash</span><span class=o>=</span><span class=n>std</span><span class=o>::</span><span class=n>hash</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=o>&gt;</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcurrentLRU</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentLRU</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>bucket_nums</span> <span class=o>=</span> <span class=mi>11</span><span class=p>,</span> <span class=n>Hash</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>hasher</span> <span class=o>=</span> <span class=n>Hash</span><span class=p>())</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>buckets_</span><span class=p>(</span><span class=n>bucket_nums</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>hasher_</span> <span class=p>(</span><span class=n>hasher</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>uint64_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>bucket_nums</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>LRU</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>Put</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Put</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>Get</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>VALUE_T</span> <span class=o>&amp;</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Get</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 没有的话返回一个新的VALUE_T回去，此时缓存是没有的 */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 如果有的话放到最开始的地方 */</span>
</span></span><span class=line><span class=cl>        <span class=n>VALUE_T</span> <span class=nf>Get</span><span class=p>(</span><span class=k>const</span> <span class=n>KEY_T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>key</span><span class=p>).</span><span class=n>Get</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>        
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>GetAllKey</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#if 0</span><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>            //auto iter = buckets_.begin();
</span></span></span><span class=line><span class=cl><span class=c>            //这里要注意，先得对iter做解引用，得到uniqueptr,然后对unique_ptr做解引用或者用-&gt;才能进行调用
</span></span></span><span class=line><span class=cl><span class=c>            typename std::vector&lt;std::unique_ptr&lt;LRU&lt;KEY_T, VALUE_T&gt; &gt; &gt;::iterator iter = buckets_.begin();
</span></span></span><span class=line><span class=cl><span class=c>            for ( ; iter != buckets_.end(); ++iter ) {
</span></span></span><span class=line><span class=cl><span class=c>                (*iter)-&gt;GetAllKey(list);
</span></span></span><span class=line><span class=cl><span class=c>            }
</span></span></span><span class=line><span class=cl><span class=c></span><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>bucket_index</span> <span class=o>&lt;</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>bucket_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>GetAllKey</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>LRU</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;&amp;</span> <span class=n>GetBucket</span><span class=p>(</span><span class=n>KEY_T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=k>const</span> <span class=n>bucket_index</span> <span class=o>=</span> <span class=n>hasher_</span><span class=p>(</span><span class=n>key</span><span class=p>)</span><span class=o>%</span> <span class=n>buckets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>*</span><span class=n>buckets_</span><span class=p>[</span><span class=n>bucket_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 禁用拷贝构造 */</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentLRU</span><span class=p>(</span><span class=n>ConcurrentLRU</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 禁用赋值运算符 */</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentLRU</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>ConcurrentLRU</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 使用unique_ptr保证内存安全 */</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>LRU</span><span class=o>&lt;</span><span class=n>KEY_T</span><span class=p>,</span> <span class=n>VALUE_T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>buckets_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Hash</span> <span class=n>hasher_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h2 class="relative group">3 一个线程安全的连接池<div id=3-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0 aria-label=锚点>#</a></span></h2><p>下面这个连接池在写的时候由于需要证书更新，因此需要使用TLSSocketWrapper来包裹证书/密钥/ca证书。这里要注意为了实现每次握手的时候只使用新的证书，所以这里会加一个证书的时间戳，来保证用的都是新的证书。可以发现这样子即使证书握手失败也依然会拿新的证书来执行握手。</p><p>该连接池首先执行tls握手，然后将tls握手的socket（<code>boost::shared_ptr&lt;ssl::stream&lt;ip::tcp::socket> ></code>）丢到LRU中，来保证lru总是缓存了最新的值，然后发送数据失败的情况下会重新建立连接。为了保活使用了http get对连接做get来探活，每15秒执行一次探活 。</p><p>头文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#ifndef __SYNC_TLS_CLIENT_H__
</span></span></span><span class=line><span class=cl><span class=cp>#define __SYNC_TLS_CLIENT_H__
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;lru.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;singleton.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;repeated_timer.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;istream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdlib&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/asio.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/asio/ssl.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost/thread.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost/function.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost/shared_ptr.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost/move/unique_ptr.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost/make_shared.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost/lockfree/spsc_queue.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/beast/core.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/beast/http.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/beast/version.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/asio/connect.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/asio/ip/tcp.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/asio/ssl/error.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/asio/ssl/stream.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>tcp</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>asio</span><span class=o>::</span><span class=n>ip</span><span class=o>::</span><span class=n>tcp</span><span class=p>;</span>       <span class=c1>// from &lt;boost/asio/ip/tcp.hpp&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>ssl</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>asio</span><span class=o>::</span><span class=n>ssl</span><span class=p>;</span>       <span class=c1>// from &lt;boost/asio/ssl.hpp&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>http</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>beast</span><span class=o>::</span><span class=n>http</span><span class=p>;</span>    <span class=c1>// from &lt;boost/beast/http.hpp&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>boost</span><span class=o>::</span><span class=n>asio</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define HTTP_11_VERSION 11
</span></span></span><span class=line><span class=cl><span class=cp>#define DEFAULT_HTTP_ALIVE_CONFIG &#34;timeout=60, max=1000&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define CONTENT_TYPE_JSON &#34;application/json; charset=utf-8&#34; 
</span></span></span><span class=line><span class=cl><span class=cp>#define CONTENT_TYPE_PLAIN &#34;text/plain; charset=utf-8&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define CONTENT_TYPE_HTML &#34;text/html; charset=utf-8&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define CONNECT_MAX_TRY_TIMES 4
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TLSSocketWrapper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 连接函数被封装到了TLSSocketWrapper的构造函数里面 */</span>
</span></span><span class=line><span class=cl>        <span class=n>TLSSocketWrapper</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>port</span><span class=p>,</span> <span class=n>boost</span><span class=o>::</span><span class=n>asio</span><span class=o>::</span><span class=n>io_context</span> <span class=o>&amp;</span><span class=n>global_io_context</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>cert</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ca_cert</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>time_stamp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetCert</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetKey</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetCaCert</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=nf>GetTimeStamp</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=nf>HandshakeFinished</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 下面两个不是线程安全的 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>GetMessageCore</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>PostMessageCore</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_content_type</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_body</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_lock</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span><span class=o>&gt;</span> <span class=n>read_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>boost</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span><span class=o>&gt;</span> <span class=n>write_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>ssl</span><span class=o>::</span><span class=n>stream</span><span class=o>&lt;</span><span class=n>ip</span><span class=o>::</span><span class=n>tcp</span><span class=o>::</span><span class=n>socket</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>real_socket_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_mutex</span> <span class=n>rwlock_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ip_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>port_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cert_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ca_cert_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>time_stamp_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TlsWrapperCompare</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=k>operator</span><span class=p>()</span> <span class=p>(</span><span class=k>const</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>GetTimeStamp</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>GetTimeStamp</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SyncTlsConnectionManager</span> <span class=o>:</span> <span class=k>public</span> <span class=n>hxn</span><span class=o>::</span><span class=n>Singleton</span><span class=o>&lt;</span><span class=n>SyncTlsConnectionManager</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 目前，该实例负责维护数据并保活 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=n>Init</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>HttpHeartBeat</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>io_context</span><span class=o>&amp;</span> <span class=n>GetGlobalIOContext</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentLRU</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>TlsWrapperCompare</span><span class=o>&gt;&amp;</span> <span class=n>GetGlobalSocketWrapper</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 第一个io context是给所有的tls连接用的 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>asio</span><span class=o>::</span><span class=n>io_context</span> <span class=n>global_io_context_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ConcurrentLRU</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>TlsWrapperCompare</span><span class=o>&gt;</span> <span class=n>global_sockets_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 异步定时器+线程, 使用boost asio + chrono实现*/</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=kr>thread</span><span class=o>&gt;</span> <span class=n>loop_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>RepeatedTimer</span><span class=o>&gt;</span> <span class=n>timer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 该context负责给全局定时器使用 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>io_service</span><span class=o>&gt;</span> <span class=n>io_service_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* asio socket的同步读写是线程安全的 */</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SyncTlsClient</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 探活/保活接口专用构造函数 */</span>
</span></span><span class=line><span class=cl>        <span class=n>SyncTlsClient</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>port</span><span class=p>,</span> <span class=k>const</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>connection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 时间戳为证书时间戳，或者说证书文件的时间戳 */</span>
</span></span><span class=line><span class=cl>        <span class=n>SyncTlsClient</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>port</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>cert</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ca_cert</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint64_t</span> <span class=o>&amp;</span><span class=n>time_stamp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* http心跳报文实际上是个get请求 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>HeartBeat</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>GetMessage</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>PostMessage</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_content_type</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_body</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=n>socket_wrapper_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 可以是ip/port也可能是host/port */</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ip_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>port_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>cpp文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;sync_tls_client.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* 构造函数只会在每个线程构造所以必然是线程安全的 */</span>
</span></span><span class=line><span class=cl><span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>TLSSocketWrapper</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>port</span><span class=p>,</span> <span class=n>boost</span><span class=o>::</span><span class=n>asio</span><span class=o>::</span><span class=n>io_context</span> <span class=o>&amp;</span><span class=n>global_io_context</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>cert</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ca_cert</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>time_stamp</span><span class=p>)</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_</span><span class=p>(</span><span class=n>ip</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>port_</span><span class=p>(</span><span class=n>port</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>cert_</span><span class=p>(</span><span class=n>cert</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>key_</span><span class=p>(</span><span class=n>key</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>ca_cert_</span><span class=p>(</span><span class=n>ca_cert</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>time_stamp_</span><span class=p>(</span><span class=n>time_stamp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>try_times</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>real_socket_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>try_times</span> <span class=o>&lt;</span> <span class=n>CONNECT_MAX_TRY_TIMES</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ssl</span><span class=o>::</span><span class=n>context</span> <span class=n>ssl_context</span><span class=p>{</span><span class=n>ssl</span><span class=o>::</span><span class=n>context</span><span class=o>::</span><span class=n>sslv23_client</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 两者都不为空, 才执行load */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>cert</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>||</span> <span class=n>key</span><span class=p>.</span><span class=n>empty</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>ssl_context</span><span class=p>.</span><span class=n>use_certificate_chain</span><span class=p>(</span><span class=n>buffer</span><span class=p>(</span><span class=n>cert</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>cert</span><span class=p>.</span><span class=n>size</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>                <span class=n>ssl_context</span><span class=p>.</span><span class=n>use_private_key</span><span class=p>(</span><span class=n>buffer</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>key</span><span class=p>.</span><span class=n>size</span><span class=p>()),</span> <span class=n>ssl</span><span class=o>::</span><span class=n>context</span><span class=o>::</span><span class=n>file_format</span><span class=o>::</span><span class=n>pem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ca_cert</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>ssl_context</span><span class=p>.</span><span class=n>add_certificate_authority</span><span class=p>(</span><span class=n>buffer</span><span class=p>(</span><span class=n>ca_cert</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>ca_cert</span><span class=p>.</span><span class=n>size</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>real_socket_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>ssl</span><span class=o>::</span><span class=n>stream</span><span class=o>&lt;</span><span class=n>tcp</span><span class=o>::</span><span class=n>socket</span><span class=o>&gt;</span><span class=p>(</span><span class=n>global_io_context</span><span class=p>,</span> <span class=n>ssl_context</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>boost</span><span class=o>::</span><span class=n>system</span><span class=o>::</span><span class=n>error_code</span> <span class=n>ip_invalid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ip</span><span class=o>::</span><span class=n>address</span> <span class=n>ip_address</span> <span class=o>=</span> <span class=n>ip</span><span class=o>::</span><span class=n>address</span><span class=o>::</span><span class=n>from_string</span><span class=p>(</span><span class=n>ip</span><span class=p>,</span> <span class=n>ip_invalid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>ip_invalid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* url */</span>
</span></span><span class=line><span class=cl>                <span class=n>tcp</span><span class=o>::</span><span class=n>resolver</span> <span class=n>resolver</span><span class=p>{</span><span class=n>global_io_context</span><span class=p>};</span>
</span></span><span class=line><span class=cl>                <span class=k>auto</span> <span class=k>const</span> <span class=n>results</span> <span class=o>=</span> <span class=n>resolver</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=n>ip</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>connect</span><span class=p>(</span><span class=n>real_socket_</span><span class=o>-&gt;</span><span class=n>next_layer</span><span class=p>(),</span> <span class=n>results</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>results</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>tcp</span><span class=o>::</span><span class=n>endpoint</span> <span class=n>endpoint</span><span class=p>(</span><span class=n>ip_address</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>stoi</span><span class=p>(</span><span class=n>port</span><span class=p>));</span>
</span></span><span class=line><span class=cl>                <span class=n>real_socket_</span><span class=o>-&gt;</span><span class=n>next_layer</span><span class=p>().</span><span class=n>connect</span><span class=p>(</span><span class=n>endpoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* keep下层socket alive */</span>
</span></span><span class=line><span class=cl>            <span class=n>real_socket_</span><span class=o>-&gt;</span><span class=n>next_layer</span><span class=p>().</span><span class=n>set_option</span><span class=p>(</span><span class=n>socket_base</span><span class=o>::</span><span class=n>keep_alive</span><span class=p>(</span><span class=nb>true</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>real_socket_</span><span class=o>-&gt;</span><span class=n>handshake</span><span class=p>(</span><span class=n>ssl</span><span class=o>::</span><span class=n>stream_base</span><span class=o>::</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Handshake Error: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>real_socket_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>try_times</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>GetCert</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cert_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>GetKey</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>key_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>GetTimeStamp</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>time_stamp_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>HandshakeFinished</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>real_socket_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>GetCaCert</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ca_cert_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 返回的错误码是200表示get成功了，其它代表失败 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>GetMessageCore</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>body</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>http</span><span class=o>::</span><span class=n>request</span><span class=o>&lt;</span><span class=n>http</span><span class=o>::</span><span class=n>string_body</span><span class=o>&gt;</span> <span class=n>req</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>verb</span><span class=o>::</span><span class=n>get</span><span class=p>,</span> <span class=n>server_path</span><span class=p>,</span> <span class=n>HTTP_11_VERSION</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>host</span><span class=p>,</span> <span class=n>ip_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>user_agent</span><span class=p>,</span> <span class=n>BOOST_BEAST_VERSION_STRING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>keep_alive</span><span class=p>,</span> <span class=n>DEFAULT_HTTP_ALIVE_CONFIG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>beast</span><span class=o>::</span><span class=n>flat_buffer</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>http</span><span class=o>::</span><span class=n>response</span><span class=o>&lt;</span><span class=n>http</span><span class=o>::</span><span class=n>dynamic_body</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 保持锁的时间最短 */</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=nf>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>http</span><span class=o>::</span><span class=n>write</span><span class=p>(</span><span class=o>*</span><span class=n>real_socket_</span><span class=p>,</span> <span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>http</span><span class=o>::</span><span class=n>read</span><span class=p>(</span><span class=o>*</span><span class=n>real_socket_</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>response_body</span><span class=p>{</span> <span class=n>buffers_begin</span><span class=p>(</span><span class=n>res</span><span class=p>.</span><span class=n>body</span><span class=p>().</span><span class=n>data</span><span class=p>()),</span><span class=n>buffers_end</span><span class=p>(</span><span class=n>res</span><span class=p>.</span><span class=n>body</span><span class=p>().</span><span class=n>data</span><span class=p>())</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>body</span> <span class=o>=</span> <span class=n>response_body</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//http错误码是返回值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>error_code</span> <span class=o>=</span> <span class=n>res</span><span class=p>.</span><span class=n>result_int</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Get Message Error: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=mi>500</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 返回的错误码是200表示get成功了，其它代表失败 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>TLSSocketWrapper</span><span class=o>::</span><span class=n>PostMessageCore</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_content_type</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_body</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>body</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>http</span><span class=o>::</span><span class=n>request</span><span class=o>&lt;</span><span class=n>http</span><span class=o>::</span><span class=n>string_body</span><span class=o>&gt;</span> <span class=n>req</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>verb</span><span class=o>::</span><span class=n>post</span><span class=p>,</span> <span class=n>server_path</span><span class=p>,</span> <span class=n>HTTP_11_VERSION</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>host</span><span class=p>,</span> <span class=n>ip_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>user_agent</span><span class=p>,</span> <span class=n>BOOST_BEAST_VERSION_STRING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>keep_alive</span><span class=p>,</span> <span class=n>DEFAULT_HTTP_ALIVE_CONFIG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>http</span><span class=o>::</span><span class=n>field</span><span class=o>::</span><span class=n>content_type</span><span class=p>,</span> <span class=n>request_content_type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>body</span><span class=p>()</span> <span class=o>=</span> <span class=n>request_body</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 设定完了使用prepare_payload来更新header里面的content_length */</span>
</span></span><span class=line><span class=cl>        <span class=n>req</span><span class=p>.</span><span class=n>prepare_payload</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>beast</span><span class=o>::</span><span class=n>flat_buffer</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>http</span><span class=o>::</span><span class=n>response</span><span class=o>&lt;</span><span class=n>http</span><span class=o>::</span><span class=n>dynamic_body</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 保持锁的时间最短 */</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>write_lock</span> <span class=nf>lock</span><span class=p>(</span><span class=n>rwlock_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>http</span><span class=o>::</span><span class=n>write</span><span class=p>(</span><span class=o>*</span><span class=n>real_socket_</span><span class=p>,</span> <span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>http</span><span class=o>::</span><span class=n>read</span><span class=p>(</span><span class=o>*</span><span class=n>real_socket_</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>response_body</span><span class=p>{</span> <span class=n>buffers_begin</span><span class=p>(</span><span class=n>res</span><span class=p>.</span><span class=n>body</span><span class=p>().</span><span class=n>data</span><span class=p>()),</span><span class=n>buffers_end</span><span class=p>(</span><span class=n>res</span><span class=p>.</span><span class=n>body</span><span class=p>().</span><span class=n>data</span><span class=p>())</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>body</span> <span class=o>=</span> <span class=n>response_body</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//http错误码是返回值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>error_code</span> <span class=o>=</span> <span class=n>res</span><span class=p>.</span><span class=n>result_int</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Post Message Error: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=mi>500</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>Init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>io_service_</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>io_service</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>io_service</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 添加work防止io_service 在pending时退出*/</span>
</span></span><span class=line><span class=cl>    <span class=n>io_service</span><span class=o>::</span><span class=n>work</span> <span class=n>work</span><span class=p>{</span><span class=o>*</span><span class=n>io_service_</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>loop_</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>boost</span><span class=o>::</span><span class=kr>thread</span><span class=o>&gt;</span> <span class=p>(</span><span class=k>new</span> <span class=n>boost</span><span class=o>::</span><span class=kr>thread</span><span class=p>([</span><span class=o>&amp;</span><span class=p>]{</span> <span class=n>io_service_</span><span class=o>-&gt;</span><span class=n>run</span><span class=p>();</span> <span class=p>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* lambda需要捕获this才能调用this的函数，如果是静态或者全局函数那么不需要执行捕获 */</span>
</span></span><span class=line><span class=cl>    <span class=n>timer_</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>RepeatedTimer</span><span class=o>&gt;</span> <span class=p>(</span><span class=k>new</span> <span class=n>RepeatedTimer</span><span class=p>(</span><span class=o>*</span><span class=n>io_service_</span><span class=p>,</span> <span class=p>[</span><span class=k>this</span><span class=p>](</span><span class=k>const</span> <span class=n>boost</span><span class=o>::</span><span class=n>system</span><span class=o>::</span><span class=n>error_code</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>HttpHeartBeat</span><span class=p>();}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 15秒钟运行一次心跳保活线程 */</span>
</span></span><span class=line><span class=cl>    <span class=n>timer_</span><span class=o>-&gt;</span><span class=n>Start</span><span class=p>(</span><span class=cm>/*ms=*/</span><span class=mi>1000</span><span class=o>*</span><span class=mi>15</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>HttpHeartBeat</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>global_sockets_</span><span class=p>.</span><span class=n>GetAllKey</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>iter</span> <span class=p>:</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>pos</span> <span class=o>=</span> <span class=n>iter</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=sc>&#39;#&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pos</span> <span class=o>==</span> <span class=n>iter</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>npos</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 理论上不可能发生这问题 */</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ip</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pos</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>port</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>pos</span><span class=o>+</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>        SyncTlsClient heartbeat(ip, port, iter.second);
</span></span></span><span class=line><span class=cl><span class=cm>        std::string header;
</span></span></span><span class=line><span class=cl><span class=cm>        std::string body;
</span></span></span><span class=line><span class=cl><span class=cm>        int error_code = heartbeat.HeartBeat(&#34;/monitor/alive&#34;, header, body);
</span></span></span><span class=line><span class=cl><span class=cm>        if (error_code != 200) {
</span></span></span><span class=line><span class=cl><span class=cm>        }
</span></span></span><span class=line><span class=cl><span class=cm>        */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io_context</span><span class=o>&amp;</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>GetGlobalIOContext</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>global_io_context_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ConcurrentLRU</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>TlsWrapperCompare</span><span class=o>&gt;&amp;</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>GetGlobalSocketWrapper</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>global_sockets_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 探活/保活接口专用构造函数 */</span>
</span></span><span class=line><span class=cl><span class=n>SyncTlsClient</span><span class=o>::</span><span class=n>SyncTlsClient</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>port</span><span class=p>,</span> <span class=k>const</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>connection</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_</span><span class=p>(</span><span class=n>ip</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>port_</span><span class=p>(</span><span class=n>port</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>socket_wrapper_</span><span class=p>(</span><span class=n>connection</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 时间戳为证书时间戳，或者说证书文件的时间戳 */</span>
</span></span><span class=line><span class=cl><span class=n>SyncTlsClient</span><span class=o>::</span><span class=n>SyncTlsClient</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>port</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>cert</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>ca_cert</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint64_t</span> <span class=o>&amp;</span><span class=n>time_stamp</span><span class=p>)</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_</span><span class=p>(</span><span class=n>ip</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>port_</span><span class=p>(</span><span class=n>port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>ip</span><span class=o>+</span><span class=s>&#34;#&#34;</span><span class=o>+</span><span class=n>port</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalSocketWrapper</span><span class=p>().</span><span class=n>Get</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>socket_wrapper_</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 能查到且时间戳没超时意味着可用 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>time_stamp</span> <span class=o>&lt;=</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetTimeStamp</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 不需要执行重新握手的唯一情况只有这一种，直接使用缓存数据 */</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=n>new_socket_wrapper</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=p>(</span><span class=k>new</span> <span class=n>TLSSocketWrapper</span><span class=p>(</span><span class=n>ip</span><span class=p>,</span> <span class=n>port</span><span class=p>,</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalIOContext</span><span class=p>(),</span> <span class=n>cert</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>ca_cert</span><span class=p>,</span> <span class=n>time_stamp</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>new_socket_wrapper</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 建立连接失败，不会更新全局缓存的，全局缓存只在握手成功的情况下更新*/</span>
</span></span><span class=line><span class=cl>        <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalSocketWrapper</span><span class=p>().</span><span class=n>Put</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>new_socket_wrapper</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>socket_wrapper_</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* http心跳报文实际上是个get请求 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>SyncTlsClient</span><span class=o>::</span><span class=n>HeartBeat</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_body</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* real_socket_理论来说不能为空，为空直接说明一开始尝试连接失败，直接返回错误码500即可 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>socket_wrapper_</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* asio的is_open是个无效函数，因此只能通过尝试发送数据来探测是否该socket还活着/出现异常 */</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetMessageCore</span><span class=p>(</span><span class=n>server_path</span><span class=p>,</span> <span class=n>response_header</span><span class=p>,</span> <span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 500代表连接失效了，需要重新连接，并发起请求 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>error_code</span> <span class=o>==</span> <span class=mi>500</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 因为永远保证socket_wrapper的证书/私钥/时间戳都是最新版，所以使用socket_wrapper_的证书私钥建立连接 */</span>
</span></span><span class=line><span class=cl>            <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=n>new_socket_wrapper</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=p>(</span><span class=k>new</span> <span class=n>TLSSocketWrapper</span><span class=p>(</span><span class=n>ip_</span><span class=p>,</span> <span class=n>port_</span><span class=p>,</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalIOContext</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetCert</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetKey</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetCaCert</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetTimeStamp</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>new_socket_wrapper</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>error_code</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>GetMessageCore</span><span class=p>(</span><span class=n>server_path</span><span class=p>,</span> <span class=n>response_header</span><span class=p>,</span> <span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>error_code</span> <span class=o>==</span> <span class=mi>200</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>ip_</span><span class=o>+</span><span class=s>&#34;#&#34;</span><span class=o>+</span><span class=n>port_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalSocketWrapper</span><span class=p>().</span><span class=n>Put</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>new_socket_wrapper</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>socket_wrapper_</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=mi>500</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>SyncTlsClient</span><span class=o>::</span><span class=n>GetMessage</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_body</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* real_socket_理论来说不能为空，为空直接说明一开始尝试连接失败，直接返回错误码500即可 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>socket_wrapper_</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* asio的is_open是个无效函数，因此只能通过尝试发送数据来探测是否该socket还活着/出现异常 */</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetMessageCore</span><span class=p>(</span><span class=n>server_path</span><span class=p>,</span> <span class=n>response_header</span><span class=p>,</span> <span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 500代表连接失效了，需要重新连接，并发起请求 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>error_code</span> <span class=o>==</span> <span class=mi>500</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 因为永远保证socket_wrapper的证书/私钥/时间戳都是最新版，所以使用socket_wrapper_的证书私钥建立连接 */</span>
</span></span><span class=line><span class=cl>            <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=n>new_socket_wrapper</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=p>(</span><span class=k>new</span> <span class=n>TLSSocketWrapper</span><span class=p>(</span><span class=n>ip_</span><span class=p>,</span> <span class=n>port_</span><span class=p>,</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalIOContext</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetCert</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetKey</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetCaCert</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetTimeStamp</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>new_socket_wrapper</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>error_code</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>GetMessageCore</span><span class=p>(</span><span class=n>server_path</span><span class=p>,</span> <span class=n>response_header</span><span class=p>,</span> <span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>error_code</span> <span class=o>==</span> <span class=mi>200</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>ip_</span><span class=o>+</span><span class=s>&#34;#&#34;</span><span class=o>+</span><span class=n>port_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalSocketWrapper</span><span class=p>().</span><span class=n>Put</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>new_socket_wrapper</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>socket_wrapper_</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=mi>500</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>SyncTlsClient</span><span class=o>::</span><span class=n>PostMessage</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>server_path</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_content_type</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>request_body</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_header</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>response_body</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* socket_理论来说不能为空，为空直接说明地址无效了，直接返回错误码500即可 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>socket_wrapper_</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* asio的is_open是个无效函数，因此只能通过尝试发送数据来探测是否该socket还活着 */</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>PostMessageCore</span><span class=p>(</span><span class=n>server_path</span><span class=p>,</span> <span class=n>request_content_type</span><span class=p>,</span> <span class=n>request_body</span><span class=p>,</span> <span class=n>response_header</span><span class=p>,</span> <span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 500代表连接失效了，需要重新连接，并发起请求 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>error_code</span> <span class=o>==</span> <span class=mi>500</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 因为永远保证socket_wrapper的证书/私钥/时间戳都是最新版，所以使用socket_wrapper_的证书私钥建立连接 */</span>
</span></span><span class=line><span class=cl>            <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=n>new_socket_wrapper</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>TLSSocketWrapper</span><span class=o>&gt;</span> <span class=p>(</span><span class=k>new</span> <span class=n>TLSSocketWrapper</span><span class=p>(</span><span class=n>ip_</span><span class=p>,</span> <span class=n>port_</span><span class=p>,</span> <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalIOContext</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetCert</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetKey</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetCaCert</span><span class=p>(),</span> <span class=n>socket_wrapper_</span><span class=o>-&gt;</span><span class=n>GetTimeStamp</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>new_socket_wrapper</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>HandshakeFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>error_code</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=o>-&gt;</span><span class=n>PostMessageCore</span><span class=p>(</span><span class=n>server_path</span><span class=p>,</span> <span class=n>request_content_type</span><span class=p>,</span> <span class=n>request_body</span><span class=p>,</span> <span class=n>response_header</span><span class=p>,</span> <span class=n>response_body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>error_code</span> <span class=o>==</span> <span class=mi>200</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>ip_</span><span class=o>+</span><span class=s>&#34;#&#34;</span><span class=o>+</span><span class=n>port_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>SyncTlsConnectionManager</span><span class=o>::</span><span class=n>instance</span><span class=p>().</span><span class=n>GetGlobalSocketWrapper</span><span class=p>().</span><span class=n>Put</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>new_socket_wrapper</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>socket_wrapper_</span> <span class=o>=</span> <span class=n>new_socket_wrapper</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>error_code</span> <span class=o>=</span> <span class=mi>500</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error_code</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">5 OPENSSL签名验证签名代码<div id=5-openssl%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E4%BB%A3%E7%A0%81 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-openssl%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E4%BB%A3%E7%A0%81 aria-label=锚点>#</a></span></h2><p>本来是指用crypto++库做的，然后惊讶的发现crypto++的签名/验签的性能低的令人发指。所以最后又采用了openssl的代码</p><p>头文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#ifndef __SIGN_ALGORITHM_H__
</span></span></span><span class=line><span class=cl><span class=cp>#define __SIGN_ALGORITHM_H__
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* inf cbom的crypto后面没有pp，mac装的需要加个pp */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef MAC_BUILD
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;crypto/eccrypto.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;crypto/osrng.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;crypto/rsa.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;crypto/pssr.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;crypto/base64.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cryptopp/eccrypto.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cryptopp/osrng.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cryptopp/rsa.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cryptopp/pssr.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cryptopp/base64.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;sts_enum.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/ecdsa.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/rsa.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/ssl.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/ecdh.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/evp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/sha.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/bio.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/pem.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/err.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;openssl/hmac.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define EVP_MAX_SIGNATURE_SIZE 1024
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SignAlgorithm</span><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=n>sign_with_pem</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>algorithm</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>verify_with_pem</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>algorithm</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>base64_url_encode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>base64_url_decode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>base64_encode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>base64_decode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=n>load_base64_raw_key</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem</span><span class=p>,</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ByteQueue</span> <span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>Base64Decoder</span> <span class=n>decoder</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>decoder</span><span class=p>.</span><span class=n>Attach</span><span class=p>(</span><span class=k>new</span> <span class=n>Redirector</span><span class=p>(</span><span class=n>queue</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>decoder</span><span class=p>.</span><span class=n>Put</span><span class=p>((</span><span class=k>const</span> <span class=n>byte</span><span class=o>*</span><span class=p>)</span><span class=n>pem</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>pem</span><span class=p>.</span><span class=n>length</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=n>decoder</span><span class=p>.</span><span class=n>MessageEnd</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>key</span><span class=p>.</span><span class=n>BERDecode</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl><span class=cp>#ifdef AUTH_SDK_VALIDATE_KEY
</span></span></span><span class=line><span class=cl><span class=cp></span>                <span class=n>AutoSeededRandomPool</span> <span class=n>prng</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>bool</span> <span class=n>valid</span> <span class=o>=</span> <span class=n>key</span><span class=p>.</span><span class=n>Validate</span><span class=p>(</span><span class=n>prng</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>valid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>Exception</span><span class=o>&amp;</span> <span class=n>ex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 公私密钥均为pem格式*/</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=n>ecdsa_sha256_sign</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>ecdsa_sha256_verify</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>ecdsa_sha256_sign_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>ecdsa_sha256_verify_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>rsa_sha256_sign_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>rsa_sha256_verify_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>rsa_sha256_sign</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>rsa_sha256_verify</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>hmac_sha256_sign</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>hmac_sha256_verify</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>hmac_sha256_sign_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>bool</span> <span class=nf>hmac_sha256_verify_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>cpp文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;sign_algorithm.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>sign_with_pem</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>algorithm</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>algorithm</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef USE_CRYPTOPP_ALG
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_RS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_sign</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_ES256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_sign</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_HS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_sign</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_RS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_sign_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_ES256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_sign_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_HS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_sign_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>verify_with_pem</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>algorithm</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>algorithm</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef USE_CRYPTOPP_ALG
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_RS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_verify</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_ES256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_verify</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_HS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_verify</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_RS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_verify_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_ES256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_verify_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>STS_ALG_TYPE_HS256</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_verify_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>signature</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_sign</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECDSA</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECP</span><span class=p>,</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;::</span><span class=n>PrivateKey</span> <span class=n>private_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>load_base64_raw_key</span><span class=p>(</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>private_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>AutoSeededRandomPool</span> <span class=n>prng</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECDSA</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECP</span><span class=p>,</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;::</span><span class=n>Signer</span> <span class=n>signer</span><span class=p>(</span><span class=n>private_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span> <span class=n>s</span><span class=p>(</span> <span class=n>message</span><span class=p>,</span> <span class=nb>true</span> <span class=cm>/* pump all */</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SignerFilter</span><span class=p>(</span><span class=n>prng</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                <span class=n>signer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span> <span class=n>signature</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_verify</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECDSA</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECP</span><span class=p>,</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;::</span><span class=n>PublicKey</span> <span class=n>public_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>load_base64_raw_key</span><span class=p>(</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>public_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECDSA</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>ECP</span><span class=p>,</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;::</span><span class=n>Verifier</span> <span class=n>verifier</span><span class=p>(</span><span class=n>public_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span> <span class=n>s</span><span class=p>(</span> <span class=n>signature</span><span class=o>+</span><span class=n>message</span><span class=p>,</span> <span class=nb>true</span> <span class=cm>/* pump all */</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 默认就是把校验结果放到ret里 */</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SignatureVerificationFilter</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>verifier</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>ArraySink</span><span class=p>(</span> <span class=p>(</span><span class=n>byte</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>ret</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_sign</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>RSA</span><span class=o>::</span><span class=n>PrivateKey</span> <span class=n>private_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>load_base64_raw_key</span><span class=p>(</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>private_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>RSASS</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>PSS</span><span class=p>,</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;::</span><span class=n>Signer</span> <span class=n>signer</span><span class=p>(</span><span class=n>private_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>AutoSeededRandomPool</span> <span class=n>prng</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span> <span class=n>s</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SignerFilter</span><span class=p>(</span><span class=n>prng</span><span class=p>,</span> <span class=n>signer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span> <span class=n>signature</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_verify</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>RSA</span><span class=o>::</span><span class=n>PublicKey</span> <span class=n>public_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>load_base64_raw_key</span><span class=p>(</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>public_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CryptoPP</span><span class=o>::</span><span class=n>RSASS</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>PSS</span><span class=p>,</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;::</span><span class=n>Verifier</span> <span class=n>verifier</span><span class=p>(</span><span class=n>public_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span> <span class=n>s</span><span class=p>(</span><span class=n>signature</span><span class=o>+</span><span class=n>message</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>SignatureVerificationFilter</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>verifier</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>ArraySink</span><span class=p>(</span> <span class=p>(</span><span class=n>byte</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>ret</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_sign</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 输入的密钥是base64编码的，所以需要先解码 */</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>base64_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>base64_decode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>base64_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>HMAC</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;</span> <span class=n>hmac</span><span class=p>((</span><span class=n>byte</span><span class=o>*</span><span class=p>)</span> <span class=n>base64_key</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>base64_key</span><span class=p>.</span><span class=n>length</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>HashFilter</span><span class=p>(</span><span class=n>hmac</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span><span class=n>signature</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_verify</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>computed_signature</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 输入的密钥是base64编码的，所以需要先解码 */</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>base64_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>base64_decode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>base64_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>HMAC</span><span class=o>&lt;</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>SHA256</span><span class=o>&gt;</span> <span class=n>hmac</span><span class=p>((</span><span class=n>byte</span><span class=o>*</span><span class=p>)</span> <span class=n>base64_key</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>base64_key</span><span class=p>.</span><span class=n>length</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>HashFilter</span><span class=p>(</span><span class=n>hmac</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span><span class=n>computed_signature</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>computed_signature</span><span class=p>.</span><span class=n>compare</span><span class=p>(</span><span class=n>signature</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>base64_url_encode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>out</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span><span class=p>(</span><span class=n>in</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>Base64URLEncoder</span><span class=p>(</span><span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span><span class=n>out</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>base64_url_decode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>out</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span><span class=p>(</span><span class=n>in</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>Base64URLDecoder</span><span class=p>(</span><span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span><span class=n>out</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>base64_encode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>out</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span><span class=p>(</span><span class=n>in</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>Base64Encoder</span><span class=p>(</span><span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span><span class=n>out</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>base64_decode</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>in</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>out</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>out</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSource</span><span class=p>(</span><span class=n>in</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>Base64Decoder</span><span class=p>(</span><span class=k>new</span> <span class=n>CryptoPP</span><span class=o>::</span><span class=n>StringSink</span><span class=p>(</span><span class=n>out</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>CryptoPP</span><span class=o>::</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 签名的最后结果并不一定小于64，对ECDSA而言256bit可以达到72字节。所以signature_buf长度最好保存1024，直接防备rsa 4096/1024*8的密钥 */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_sign_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>digest_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>signature_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>digest</span><span class=p>[</span><span class=n>EVP_MAX_MD_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>signature_buf</span><span class=p>[</span><span class=n>EVP_MAX_SIGNATURE_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;-----BEGIN PRIVATE KEY-----</span><span class=se>\n</span><span class=s>&#34;</span> <span class=o>+</span> <span class=n>pem_private_key</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----END PRIVATE KEY-----&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO</span> <span class=o>*</span><span class=n>bio</span> <span class=o>=</span> <span class=n>BIO_new</span><span class=p>(</span><span class=n>BIO_s_mem</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bio</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO_puts</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=n>key</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>EC_KEY</span> <span class=o>*</span><span class=n>ec_key</span> <span class=o>=</span> <span class=n>PEM_read_bio_ECPrivateKey</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ec_key</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX</span> <span class=o>*</span><span class=n>md_ctx</span> <span class=o>=</span> <span class=n>EVP_MD_CTX_create</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>md_ctx</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>EC_KEY_free</span><span class=p>(</span><span class=n>ec_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bzero</span><span class=p>(</span><span class=n>digest</span><span class=p>,</span> <span class=n>EVP_MAX_MD_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>EVP_DigestInit</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>EVP_sha256</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span><span class=n>EVP_DigestUpdate</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>message</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>message</span><span class=p>.</span><span class=n>length</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=o>||</span><span class=n>EVP_DigestFinal</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>digest_len</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=o>||</span><span class=n>ECDSA_sign</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=n>digest_len</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>signature_buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>signature_len</span><span class=p>,</span> <span class=n>ec_key</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>final_sig</span><span class=p>(</span><span class=n>signature_buf</span><span class=p>,</span> <span class=n>signature_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>signature</span> <span class=o>=</span> <span class=n>final_sig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>EC_KEY_free</span><span class=p>(</span><span class=n>ec_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX_destroy</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>ecdsa_sha256_verify_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>digest_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>signature_len</span> <span class=o>=</span> <span class=n>signature</span><span class=p>.</span><span class=n>length</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>digest</span><span class=p>[</span><span class=n>EVP_MAX_MD_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;-----BEGIN PUBLIC KEY-----</span><span class=se>\n</span><span class=s>&#34;</span> <span class=o>+</span> <span class=n>pem_pub_key</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----END PUBLIC KEY-----&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO</span> <span class=o>*</span><span class=n>bio</span> <span class=o>=</span> <span class=n>BIO_new</span><span class=p>(</span><span class=n>BIO_s_mem</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bio</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BIO_puts</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=n>key</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>EC_KEY</span> <span class=o>*</span><span class=n>ec_key</span> <span class=o>=</span> <span class=n>PEM_read_bio_EC_PUBKEY</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ec_key</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX</span> <span class=o>*</span><span class=n>md_ctx</span> <span class=o>=</span> <span class=n>EVP_MD_CTX_create</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>md_ctx</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>EC_KEY_free</span><span class=p>(</span><span class=n>ec_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bzero</span><span class=p>(</span><span class=n>digest</span><span class=p>,</span> <span class=n>EVP_MAX_MD_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>EVP_DigestInit</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>EVP_sha256</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span><span class=n>EVP_DigestUpdate</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>message</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>message</span><span class=p>.</span><span class=n>length</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=o>||</span><span class=n>EVP_DigestFinal</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>digest_len</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=o>||</span><span class=n>ECDSA_verify</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=n>digest_len</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>signature</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>signature_len</span><span class=p>,</span> <span class=n>ec_key</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>EC_KEY_free</span><span class=p>(</span><span class=n>ec_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX_destroy</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_sign_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_private_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>digest_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>signature_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>digest</span><span class=p>[</span><span class=n>EVP_MAX_MD_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>signature_buf</span><span class=p>[</span><span class=n>EVP_MAX_SIGNATURE_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;-----BEGIN PRIVATE KEY-----</span><span class=se>\n</span><span class=s>&#34;</span> <span class=o>+</span> <span class=n>pem_private_key</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----END PRIVATE KEY-----&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO</span> <span class=o>*</span><span class=n>bio</span> <span class=o>=</span> <span class=n>BIO_new</span><span class=p>(</span><span class=n>BIO_s_mem</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bio</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO_puts</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=n>key</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>RSA</span> <span class=o>*</span><span class=n>rsa_key</span> <span class=o>=</span> <span class=n>PEM_read_bio_RSAPrivateKey</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rsa_key</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX</span> <span class=o>*</span><span class=n>md_ctx</span> <span class=o>=</span> <span class=n>EVP_MD_CTX_create</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>md_ctx</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>RSA_free</span><span class=p>(</span><span class=n>rsa_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>EVP_DigestInit</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>EVP_sha256</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span><span class=n>EVP_DigestUpdate</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>message</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>message</span><span class=p>.</span><span class=n>length</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=o>||</span><span class=n>EVP_DigestFinal</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>digest_len</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=o>||</span><span class=n>RSA_sign</span><span class=p>(</span><span class=n>NID_sha256</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=n>digest_len</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>signature_buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>signature_len</span><span class=p>,</span> <span class=n>rsa_key</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>final_sig</span><span class=p>(</span><span class=n>signature_buf</span><span class=p>,</span> <span class=n>signature_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>signature</span> <span class=o>=</span> <span class=n>final_sig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>RSA_free</span><span class=p>(</span><span class=n>rsa_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX_destroy</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>rsa_sha256_verify_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>pem_pub_key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>digest_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>signature_len</span> <span class=o>=</span> <span class=n>signature</span><span class=p>.</span><span class=n>length</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>digest</span><span class=p>[</span><span class=n>EVP_MAX_MD_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;-----BEGIN PUBLIC KEY-----</span><span class=se>\n</span><span class=s>&#34;</span> <span class=o>+</span> <span class=n>pem_pub_key</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----END PUBLIC KEY-----&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO</span> <span class=o>*</span><span class=n>bio</span> <span class=o>=</span> <span class=n>BIO_new</span><span class=p>(</span><span class=n>BIO_s_mem</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bio</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BIO_puts</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=n>key</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>RSA</span><span class=o>*</span> <span class=n>rsa_key</span> <span class=o>=</span> <span class=n>PEM_read_bio_RSA_PUBKEY</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rsa_key</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX</span> <span class=o>*</span><span class=n>md_ctx</span> <span class=o>=</span> <span class=n>EVP_MD_CTX_create</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>md_ctx</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>RSA_free</span><span class=p>(</span><span class=n>rsa_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>EVP_DigestInit</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>EVP_sha256</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span><span class=n>EVP_DigestUpdate</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>message</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>message</span><span class=p>.</span><span class=n>length</span><span class=p>())</span><span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=o>||</span><span class=n>EVP_DigestFinal</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>digest_len</span><span class=p>)</span><span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=o>||</span><span class=n>RSA_verify</span><span class=p>(</span><span class=n>NID_sha256</span><span class=p>,</span> <span class=n>digest</span><span class=p>,</span> <span class=n>digest_len</span><span class=p>,</span> <span class=p>(</span><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>signature</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>signature_len</span><span class=p>,</span> <span class=n>rsa_key</span><span class=p>)</span><span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BIO_free</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>RSA_free</span><span class=p>(</span><span class=n>rsa_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>EVP_MD_CTX_destroy</span><span class=p>(</span><span class=n>md_ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_sign_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>signature_buf</span><span class=p>[</span><span class=n>EVP_MAX_MD_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>signature_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>HMAC_CTX</span> <span class=o>*</span><span class=n>hmac</span> <span class=o>=</span> <span class=n>HMAC_CTX_new</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hmac</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>real_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>base64_decode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>real_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>HMAC_Init_ex</span><span class=p>(</span><span class=n>hmac</span><span class=p>,</span> <span class=n>real_key</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>real_key</span><span class=p>.</span><span class=n>length</span><span class=p>(),</span> <span class=n>EVP_sha256</span><span class=p>(),</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span><span class=n>HMAC_Update</span><span class=p>(</span><span class=n>hmac</span><span class=p>,</span> <span class=p>(</span> <span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=p>)</span><span class=n>message</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>message</span><span class=p>.</span><span class=n>length</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=o>||</span><span class=n>HMAC_Final</span><span class=p>(</span><span class=n>hmac</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>signature_buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>signature_len</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>final_sig</span><span class=p>(</span><span class=n>signature_buf</span><span class=p>,</span> <span class=n>signature_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>signature</span> <span class=o>=</span> <span class=n>final_sig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>HMAC_CTX_free</span><span class=p>(</span><span class=n>hmac</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SignAlgorithm</span><span class=o>::</span><span class=n>hmac_sha256_verify_openssl</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>signature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>compute_signature</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hmac_sha256_sign_openssl</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>compute_signature</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>compute_signature</span><span class=p>.</span><span class=n>compare</span><span class=p>(</span><span class=n>signature</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">6 log库<div id=6--log%E5%BA%93 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6--log%E5%BA%93 aria-label=锚点>#</a></span></h2><h3 class="relative group">6.1 boost log使用版本<div id=61-boost-log%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#61-boost-log%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC aria-label=锚点>#</a></span></h3><p>使用boost的log实现的方法，简单来说基本不需要做什么操作，就是初始化完成就可以调用记录日志的函数了。需要注意的是这个是同步的sink</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/* .h文件 */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef __BOOST_BASE_LOG__
</span></span></span><span class=line><span class=cl><span class=cp>#define __BOOST_BASE_LOG__
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/core.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/trivial.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/expressions.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/sinks/text_file_backend.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/utility/setup/file.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/utility/setup/common_attributes.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/sources/severity_logger.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;boost/log/sources/record_ostream.hpp&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>init_boost_base_log</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* .cpp文件 */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;boost_base_log.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>init_boost_base_log</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>add_file_log</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 具体记录日志的名称 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>keywords</span><span class=o>::</span><span class=n>file_name</span> <span class=o>=</span> <span class=s>&#34;sample_%N.log&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 文件10MB的时候rotate一次 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>keywords</span><span class=o>::</span><span class=n>rotation_size</span> <span class=o>=</span> <span class=mi>10</span> <span class=o>*</span> <span class=mi>1024</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 或者每天午夜的时候rotate一次 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>keywords</span><span class=o>::</span><span class=n>time_based_rotation</span> <span class=o>=</span> <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>sinks</span><span class=o>::</span><span class=n>file</span><span class=o>::</span><span class=n>rotation_at_time_point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 消息格式 */</span>
</span></span><span class=line><span class=cl>        <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>keywords</span><span class=o>::</span><span class=n>format</span> <span class=o>=</span> <span class=s>&#34;[%TimeStamp%]: %Message%&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 添加附加属性比方说时间戳，行号，线程号等 */</span>
</span></span><span class=line><span class=cl>    <span class=n>boost</span><span class=o>::</span><span class=n>log</span><span class=o>::</span><span class=n>add_common_attributes</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 具体用法 */</span>
</span></span><span class=line><span class=cl><span class=n>BOOST_LOG_TRIVIAL</span><span class=p>(</span><span class=n>trace</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;log message&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>BOOST_LOG_TRIVIAL</span><span class=p>(</span><span class=n>debug</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;log message&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>BOOST_LOG_TRIVIAL</span><span class=p>(</span><span class=n>info</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;log message&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>BOOST_LOG_TRIVIAL</span><span class=p>(</span><span class=n>warning</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;log message&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>BOOST_LOG_TRIVIAL</span><span class=p>(</span><span class=n>error</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;log message&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>BOOST_LOG_TRIVIAL</span><span class=p>(</span><span class=n>fatal</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;log message&#34;</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 编译链接的命令 
</span></span></span><span class=line><span class=cl><span class=cm> * 如果使用cmake，需要加一条add_definitions(-DBOOST_LOG_DYN_LINK)
</span></span></span><span class=line><span class=cl><span class=cm> * 然后链接的命令为
</span></span></span><span class=line><span class=cl><span class=cm> * target_link_libraries(boost_log_test -lboost_log-mt -lboost_log_setup-mt -lboost_thread-mt)
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><h3 class="relative group">6.2 spdlog<div id=62-spdlog class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#62-spdlog aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;spdlog/spdlog.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;spdlog/sinks/rotating_file_sink.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;spdlog/sinks/daily_file_sink.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;spdlog/sinks/stdout_color_sinks.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#if 0</span><span class=c>
</span></span></span><span class=line><span class=cl><span class=c>#define LOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::default_logger_raw(), __VA_ARGS__);SPDLOG_LOGGER_DEBUG(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=c>#define LOG_INFO(...) SPDLOG_LOGGER_INFO(spdlog::default_logger_raw(), __VA_ARGS__);SPDLOG_LOGGER_INFO(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=c>#define LOG_WARN(...) SPDLOG_LOGGER_WARN(spdlog::default_logger_raw(), __VA_ARGS__);SPDLOG_LOGGER_WARN(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=c>#define LOG_ERROR(...) SPDLOG_LOGGER_ERROR(spdlog::default_logger_raw(), __VA_ARGS__);SPDLOG_LOGGER_ERROR(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_INFO(...) SPDLOG_LOGGER_INFO(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_WARN(...) SPDLOG_LOGGER_WARN(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_ERROR(...) SPDLOG_LOGGER_ERROR(spdlog::get(&#34;file_log&#34;), __VA_ARGS__)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>spdlog</span><span class=o>::</span><span class=n>logger</span><span class=o>&gt;</span> <span class=n>file_logger</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>init_log</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>file_logger</span> <span class=o>=</span> <span class=n>spdlog</span><span class=o>::</span><span class=n>rotating_logger_mt</span><span class=p>(</span><span class=s>&#34;file_log&#34;</span><span class=p>,</span> <span class=s>&#34;log&#34;</span><span class=p>,</span> <span class=mi>1024</span> <span class=o>*</span> <span class=mi>1024</span> <span class=o>*</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//auto logger = spdlog::daily_logger_mt(&#34;daily_logger&#34;, &#34;logs/daily.txt&#34;, 2, 30);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 遇到warn，冲洗一次*/</span>
</span></span><span class=line><span class=cl>    <span class=c1>//file_logger-&gt;flush_on(spdlog::level::warn);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 三秒冲洗一次数据 */</span>
</span></span><span class=line><span class=cl>    <span class=n>spdlog</span><span class=o>::</span><span class=n>flush_every</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>seconds</span><span class=p>(</span><span class=mi>3</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>spdlog</span><span class=o>::</span><span class=n>set_pattern</span><span class=p>(</span><span class=s>&#34;%Y-%m-%d %H:%M:%S [%l] [%t] - &lt;%s&gt;|&lt;%#&gt;|&lt;%!&gt;,%v&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>stop_log</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>spdlog</span><span class=o>::</span><span class=n>drop_all</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">7 varint编解码<div id=7-varint%E7%BC%96%E8%A7%A3%E7%A0%81 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#7-varint%E7%BC%96%E8%A7%A3%E7%A0%81 aria-label=锚点>#</a></span></h3><p>在实现内部工程的时候遇到一个问题，就是varint编解码的实现，借鉴了网上开源代码，并修复了原本代码只适合unsigned int类型数据bug，并且添加了一个解码时获得varint长度的函数。但是需要注意一点，就是varint解码时，具体解码的对象是否合法需要自己判断，检查的方法也非常简单，无非就是检查解码varint的时候是不少超过5字节，解码varlong是不是超过10字节，或者到边界了，最后一字节第一个位为1，显示还有下个字节。代码差不多就是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>varint_size</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mh>0x80</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>varint_size</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>varint_size</span> <span class=o>&gt;</span> <span class=mi>5</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 能走到这里说明没超出5的限制，但是也可能是序列到头，即最后一个字符最高位不是0，也不合法 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>varint_size</span> <span class=o>==</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>头文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef __VARINT_HPP__
</span></span></span><span class=line><span class=cl><span class=cp>#define __VARINT_HPP__
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>varintSize</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Encodes an unsigned variable-length integer using the MSB algorithm.
</span></span></span><span class=line><span class=cl><span class=cm> * This function assumes that the value is stored as little endian.
</span></span></span><span class=line><span class=cl><span class=cm> * @param value The input value. Any standard integer type is allowed.
</span></span></span><span class=line><span class=cl><span class=cm> * @param output A pointer to a piece of reserved memory. Must have a minimum size dependent on the input size (32 bit = 5 bytes, 64 bit = 10 bytes).
</span></span></span><span class=line><span class=cl><span class=cm> * @return The number of bytes used in the output memory.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>int_t</span> <span class=o>=</span> <span class=kt>uint64_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>encodeVarint</span><span class=p>(</span><span class=n>int_t</span> <span class=n>value</span><span class=p>,</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>output</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>outputSize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//While more than 7 bits of data are left, occupy the last output byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and set the next byte flag
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>value</span> <span class=o>&gt;</span> <span class=mi>127</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//|128: Set the next byte flag
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>output</span><span class=p>[</span><span class=n>outputSize</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint8_t</span><span class=p>)(</span><span class=n>value</span> <span class=o>&amp;</span> <span class=mi>127</span><span class=p>))</span> <span class=o>|</span> <span class=mi>128</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//Remove the seven bits we just wrote
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>value</span> <span class=o>&gt;&gt;=</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>outputSize</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>[</span><span class=n>outputSize</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint8_t</span><span class=p>)</span><span class=n>value</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>127</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>outputSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Decodes an unsigned variable-length integer using the MSB algorithm.
</span></span></span><span class=line><span class=cl><span class=cm> * @param value A variable-length encoded integer of arbitrary size.
</span></span></span><span class=line><span class=cl><span class=cm> * @param inputSize How many bytes are 
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>int_t</span> <span class=o>=</span> <span class=kt>uint64_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>int_t</span> <span class=n>decodeVarint</span><span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span> <span class=n>input</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>inputSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>int_t</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>inputSize</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>|=</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mi>127</span><span class=p>))</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>7</span> <span class=o>*</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//If the next-byte flag is set
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mi>128</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif 
</span></span></span></code></pre></div><p>cpp文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;varint.hpp&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>varintSize</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>value</span> <span class=o>&gt;</span> <span class=mi>127</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>/=</span> <span class=mi>128</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">8 IO 计算分离<div id=8-io-%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#8-io-%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB aria-label=锚点>#</a></span></h2><p>一般来说，针对Libevnet的IO计算分离之后的计算部分有两种解决办法</p><ul><li>IO线程的请求均等地发送到每个计算线程，计算线程有自己的待处理队列，计算线程自己处理即可</li><li>IO线程的请求发到任务池子里面，计算线程抢任务，抢一个算一个，造成忙等。</li></ul><p>实现时：</p><ul><li>第一个可以让每个IO线程和每个计算线程分别共享一个spsc的队列，然后让IO线程轮训发任务即可。这个队列使用lfbb的队列即可实现</li><li>第二个每个IO线程发请求到mpmc里面，然后多个计算线程是consumer，不断争抢，消化即可。</li></ul><p>下面的代码我们使用libevent库做IO库，使用C++实现第二个解决办法，拆分为IO worker，IO Server，Process Worker假设通信格式很简单就是网络字节序四个字节代表长度，后面是这个长度的内容。这里我们没有任何的发送行为，Process Worker只打印内容。</p><p>Io_server.h : 注册的IO worker，Process worker都挂到上面，使用MPMC来放任务供 IO Worker生产，Process Worker消费。所以MPMC需要它提前申请，然后赋值给两种Worker</p><p>io_server.h</p><pre tabindex=0><code>#ifndef IO_SERVER_H
#define IO_SERVER_H


#include &#34;io_worker.h&#34;
#include &#34;process_worker.h&#34;
#include &#34;mpmc.h&#34;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;atomic&gt;
#include &lt;event2/bufferevent.h&gt;
#include &lt;event2/event.h&gt;

constexpr size_t kMPMCLength = 65535;
constexpr int kServerPort = 8888;

// IOServer类声明
class IOServer {
public:
    // 明确地初始化，指定io worker和process worker的数量
    explicit IOServer(size_t io_worker_count, size_t process_worker_count);
    ~IOServer();
    void Start();

private:
    // 这几个都是为了配合libevent采用的函数，而不是函数对象
    static void AcceptConnection(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *arg);
    // static void ErrorCallback(struct evconnlistener *listener, void *arg);
    // 事件循环，server能够处理IO连接事件的结构体
    struct event_base *base_;
    // 记录两种worker，方便调用他们函数
    std::vector&lt;std::shared_ptr&lt;IOWorker&gt;&gt; workers_;
    std::vector&lt;std::shared_ptr&lt;ProcessWorker&gt;&gt; de_workers_;
    // mpmc，用来在两种worker传递任务
    rigtorp::MPMCQueue&lt;Task*&gt; mpmc_;
    // 用来轮训将新的连接传递给哪个io worker
    std::atomic&lt;uint64_t&gt; counter_;
    uint64_t io_worker_count_;
    uint64_t process_worker_count_;
    std::atomic&lt;int&gt; state_;
};

#endif // IO_SERVER_H
</code></pre><p>io_server.cc</p><pre tabindex=0><code>#include &#34;io_server.h&#34;

#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/event.h&gt;
#include &lt;event2/listener.h&gt;

#include &lt;iostream&gt;

// 注意这个mpmc_，这个必须在初始化的时候调用初始化列表操作，不能在构造完成之后修改
IOServer::IOServer(size_t io_worker_count, size_t process_worker_count):io_worker_count_(io_worker_count), process_worker_count_(process_worker_count), mpmc_(kMPMCLength) {
  // 显式初始化两种worker
  for (size_t i = 0; i &lt; io_worker_count; ++i) {
    auto worker = std::make_shared&lt;IOWorker&gt;(&amp;mpmc_);
    workers_.push_back(worker);
  }
  for (size_t i = 0; i &lt; process_worker_count; ++i) {
    auto de_worker = std::make_shared&lt;ProcessWorker&gt;(&amp;mpmc_);
    de_workers_.push_back(de_worker);
  }

  struct sockaddr_in sin;
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = htonl(INADDR_ANY);
  sin.sin_port = htons(kServerPort);

  // should never failed
  base_ = event_base_new();
  // 初始化监听
  struct evconnlistener *listener;
  // should never failed, if failed, just panic
  listener = evconnlistener_new_bind(base_, AcceptConnection, (void *)this,
                                     LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,
                                     -1,
                                     (struct sockaddr *)&amp;sin, sizeof(sin));

}

void IOServer::AcceptConnection(struct evconnlistener * /*listener*/, evutil_socket_t fd, struct sockaddr * /*sa*/, int /*socklen*/, void *arg) {
  IOServer *server = static_cast&lt;IOServer*&gt;(arg);
  evutil_make_socket_nonblocking(fd);

  std::cout &lt;&lt;&#34; I got connection&#34; &lt;&lt; std::endl;
  uint64_t value = ++(server-&gt;counter_);
  auto worker = server-&gt;workers_[value % server-&gt;io_worker_count_];
  // 把连接丢给io worker
  worker-&gt;AddConnection(fd);
}

IOServer::~IOServer() {
  
}
// 启动各种worker
void IOServer::Start() {
  std::cout &lt;&lt;&#34; Server start looping&#34; &lt;&lt; std::endl;
  for (auto&amp; worker : workers_) {
    worker-&gt;Start();
  }
  for (auto&amp; de_worker : de_workers_) {
    de_worker-&gt;Start();
  }
  // 这里注意，会把当前线程阻塞住，所以server必须是在主线程
  event_base_dispatch(base_);
  std::cout &lt;&lt;&#34; Server exit looping&#34; &lt;&lt; std::endl;
}
</code></pre><p>Io_worker.h ： 这个就是纯粹的打工的</p><pre tabindex=0><code>#ifndef IO_WORKER_H
#define IO_WORKER_H

#include &lt;thread&gt;

#include &lt;atomic&gt;
#include &lt;string&gt;

#include &lt;event2/bufferevent.h&gt;
#include &lt;event2/event.h&gt;

#include &#34;process_worker.h&#34;
#include &#34;mpmc.h&#34;

constexpr int kFrameMinHeader = 4;
constexpr int kFrameDecodeInvalidError = -1;
constexpr int kFrameDecodeInternalError = -2;
constexpr int kFrameNeedMore = 1;

// IOWorker类声明
class IOWorker {
public:
  IOWorker(rigtorp::MPMCQueue&lt;Task*&gt; *mpmc);
  void Start();
  void AddConnection(evutil_socket_t fd);

  void EnqueueTask(Task* task);

private:
  static void ProcessData(struct bufferevent *bev, void *arg);
  static void ProcessError(struct bufferevent *bev, short events, void *arg);

  static size_t WriteFrame(struct bufferevent *bev, const char *msg, size_t msg_len);
  static int64_t ReadFrame(struct bufferevent *bev, std::string &amp;content, int *msg_type);
  void Run();
  struct event_base *base_;
  rigtorp::MPMCQueue&lt;Task*&gt; *mpmc_;
  std::thread thread_;
  std::atomic&lt;int&gt; state_;
};

#endif // IO_WORKER_H
</code></pre><p>io_worker.cc</p><pre tabindex=0><code>#include &#34;io_worker.h&#34;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/event.h&gt;
#include &lt;event2/listener.h&gt;
#include &lt;cstring&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

IOWorker::IOWorker(rigtorp::MPMCQueue&lt;Task*&gt; *mpmc):mpmc_(mpmc) {
    // should never failed
    base_ = event_base_new();
}
// 线程启动，使用函数对象操作
void IOWorker::Start() {
  thread_ = std::thread(&amp;IOWorker::Run, this);
}

void IOWorker::Run() {
  // 这里需要注意，worker的base_可能没有关联任何事件（没有客户端建立连接），这个时候
  // event_base_dispatch就会直接返回，所以必须得拿while包起来
  std::cout &lt;&lt;&#34; Worker start looping&#34; &lt;&lt; std::endl;
  while (1) {
    // 这里是io worker线程的真正的dispatch开始，等着处理IO事件
    event_base_dispatch(base_);
  }
}

void IOWorker::AddConnection(evutil_socket_t fd) {
  struct bufferevent *bev = bufferevent_socket_new(base_, fd, BEV_OPT_CLOSE_ON_FREE);

  if (!bev) {
    close(fd);
    return;
  }

  bufferevent_setcb(bev, ProcessData, NULL, ProcessError, (void*)this);
  bufferevent_enable(bev, EV_READ | EV_WRITE);
}

void IOWorker::ProcessData(struct bufferevent *bev, void *arg) {
  IOWorker *worker = static_cast&lt;IOWorker*&gt;(arg);
  int n;
  size_t readed_len = 0;

  struct evbuffer *buf = bufferevent_get_input(bev);

  /*
   *  |   4 byte length  |  encoded protobuf message |
   */
  while (evbuffer_get_length(buf) &gt; kFrameMinHeader) {
    std::string content;
    int data_type;
    int64_t decode_result = ReadFrame(bev, content, &amp;data_type);
    if (decode_result &lt; 0) {
      if ((decode_result == kFrameDecodeInvalidError) ||
          (decode_result == kFrameDecodeInternalError)) {
        size_t buf_len = evbuffer_get_length(buf);
        evbuffer_drain(buf, buf_len);
        return;
      }
      if (decode_result == kFrameNeedMore) {
        return;
      }
    }

    evutil_socket_t fd = bufferevent_getfd(bev);
    Task *task = new Task(content, fd);
    if (task == NULL) {
      continue;
    }
    // 把Task放起来
    worker-&gt;EnqueueTask(task);
  }
}

void IOWorker::EnqueueTask(Task* task) {
  // 实际上就是往mpmc里面放数据
  mpmc_-&gt;push(task);
}

void IOWorker::ProcessError(struct bufferevent *bev, short events, void * arg) {
//   if (event &amp; BEV_EVENT_TIMEOUT) {
//     // printf(&#34;Timed out\n&#34;); //if bufferevent_set_timeouts() called
//   } else if (event &amp; BEV_EVENT_EOF) {
//     // printf(&#34;connection closed\n&#34;);
//   } else if (event &amp; BEV_EVENT_ERROR) {
//     // printf(&#34;some other error: %s\n&#34;,
//     // evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
//   }
  bufferevent_free(bev);
}

// 纯粹占个位置，实际上没啥用
size_t IOWorker::WriteFrame(struct bufferevent *bev, const char *msg, size_t msg_len) {
  size_t frame_size = kFrameMinHeader + msg_len;
  return frame_size;
}

int64_t IOWorker::ReadFrame(struct bufferevent *bev, std::string &amp;content, int *msg_type) {
  struct evbuffer *buf = bufferevent_get_input(bev);
  if (evbuffer_get_length(buf) &lt;= kFrameMinHeader) {
    return kFrameNeedMore;
  }

  uint8_t read_buf[kFrameMinHeader];
  memset(read_buf, 0, kFrameMinHeader);
  evbuffer_copyout(buf, read_buf, kFrameMinHeader);
  
  // 从四字节内容拿出来内容的长度
  uint32_t total_length = ((read_buf[0] &lt;&lt; 24) | (read_buf[1] &lt;&lt; 16) |
                           (read_buf[2] &lt;&lt; 8) | read_buf[3]) + kFrameMinHeader;
  if (evbuffer_get_length(buf) &lt; total_length ) {
    return kFrameNeedMore;
  }

  memset(read_buf, 0, kFrameMinHeader);
  evbuffer_remove(buf, read_buf, kFrameMinHeader);

  // 也没啥用，纯粹记录用
  (*msg_type) = 1;

  // msg length + 1
  uint8_t *data_buf = (uint8_t*)malloc(total_length - kFrameMinHeader);
  if (data_buf == NULL) {
    return kFrameDecodeInternalError;
  }

  memset(data_buf, 0, total_length - kFrameMinHeader);
  evbuffer_remove(buf, data_buf, total_length - kFrameMinHeader);

  // 拷贝出来读取到的内容
  content.assign((char*)data_buf, total_length - kFrameMinHeader);
  free(data_buf);
  return total_length;
}
</code></pre><p>process_worker.h</p><pre tabindex=0><code>#ifndef MOD_PROCESS_H
#define MOD_PROCESS_H

#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

#include &#34;mpmc.h&#34;

class Task {
public:
  Task(std::string content, int fd);
  std::string GetTaskContent();
private:
  std::string content_;
  int fd_;
};

class ProcessWorker {
public:
  ProcessWorker(rigtorp::MPMCQueue&lt;Task*&gt; *mpmc);
  void Start();
private:
  void Run();
  rigtorp::MPMCQueue&lt;Task*&gt; *mpmc_;
  std::thread thread_;
  std::atomic&lt;uint64_t&gt; state_;
};

#endif
</code></pre><p>process_worker.cc</p><pre tabindex=0><code>#include &#34;process_worker.h&#34;

#include &lt;iostream&gt;

Task::Task(std::string content, int fd):content_(content), fd_(fd) {}

std::string Task::GetTaskContent() {
    return content_;
}

ProcessWorker::ProcessWorker(rigtorp::MPMCQueue&lt;Task*&gt; *mpmc):mpmc_(mpmc) {

}

void ProcessWorker::Start() {
  thread_ = std::thread(&amp;ProcessWorker::Run, this); 
}

void ProcessWorker::Run() {
  std::cout &lt;&lt;&#34; Process worker start looping&#34; &lt;&lt; std::endl;
  while(true) {
    Task *task = nullptr;
    // 这里注意，加了id用于将来判断是不是process worker均等地抢任务
    std::cout&lt;&lt; &#34;Process worker &#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#34; Prepare to pop task &#34; &lt;&lt; std::endl;
    // 这里注意，mpmc没数据会卡住，pop不出来
    mpmc_-&gt;pop(task);
    std::string content = task-&gt;GetTaskContent();
    std::cout&lt;&lt; &#34;Process worker &#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#34; Pop task, Content is &#34; &lt;&lt; content &lt;&lt; std::endl;
    free(task);
  }
}
</code></pre><p>Mcmc.h</p><p>请参考https://github.com/rigtorp/MPMCQueue</p><p>最后main调用就很简单了，直接</p><pre tabindex=0><code>    size_t io_worker_count = 2;
    size_t process_worker_count = 2 ; 
    IOServer server(io_worker_count, process_worker_count); // 创建4个worker线程

    server.Start();
</code></pre><p>等看完第下面线程池的内容，我们再使用future + boost asio实现一版本modern C++版本的代码。</p><p>阅读了https://www.boost.org/doc/libs/1_87_0/doc/html/boost_asio/tutorial.html & 更复杂的例子之后，设计如下结构</p><ul><li>tcp_server绑定io_context，初始化自己的acceptor_，async_accept绑定handle_accept，handle_accept里面再次bind，避免出现io_context空run的情况</li><li>acceptor之后新的tcp_connection，绑定到io_context（新还是旧的，旧的会造成多个争抢同一个io_context的事情）分配到不同的thread上面run，然后bind async_read，每次read到足够的数据就创建带检测任务，bind函数到任务池里面（放到mpmc里面，或者放到任务池里面？），任务需要带着tcp_connection</li><li>任务池一堆线程抢任务，抢完了任务执行检测，再对tcp_connection调用async_write</li></ul><p>感觉实现还是不太好</p><h2 class="relative group">8++ IO分离<div id=8-io%E5%88%86%E7%A6%BB class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#8-io%E5%88%86%E7%A6%BB aria-label=锚点>#</a></span></h2><p>前几天说是用Boost库重新写一般现代的IO分离，开始写一个试试，首先下载安装特定的库</p><pre tabindex=0><code></code></pre><h2 class="relative group">9 C++ 环形队列<div id=9-c-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#9-c-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97 aria-label=锚点>#</a></span></h2><p>我一般使用的都是SPSC的环形队列，MPMC我使用的不多，正好记录一下，</p><h3 class="relative group">9.1 原理<div id=91-%E5%8E%9F%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#91-%E5%8E%9F%E7%90%86 aria-label=锚点>#</a></span></h3><p>这个解释是直接抄的https://zhuanlan.zhihu.com/p/455616501，</p><p>SPSC只有一个读和写指针，所以不需要多线程保护，只需要简单的挪动指针即可</p><p>MPMC有多个读和写的对象，它需要保护正在读取的对象，所以需要生产者和消费者都记录两个指针</p><ul><li>生产者指针：prod_head，prod_tail</li><li>消费者指针：cons_head，cons_tail</li></ul><p>仅以生产者指针类比，其基本原理是拿到的prod_head和局部存储的prod_head一致，才认为是真正的拿到了当前可写的位置，如果不一致就重新拿prod_head，又因为prod_head总是指向要写的对象，所以能保证多个producer不会出现写重合的操作。而结束写的操作的时候，需要等待前面先拿到prod_head的对象修改完了prod_tail再尝试修改。换言之排队修改prod_tail</p><ol><li><p>在两个CPU core上，ring-> prod_head和ring-> prod_tail都复制到<code>局部变量中</code>。prod_next局部变量指向表的下一个元素，或者在批量入队的情况下指向多个元素。如果环中没有足够的空间（通过检查cons_tail 与 prod_head 差值可以检测到）</p><pre tabindex=0><code>// local variable core 2         cons_tail              prod_head  prod_next
                                    ↓                       ↓        ↓
// local variable core 1         cons_tail              prod_head  prod_next 
                                    ↓                       ↓        ↓
|       |       |       |       |  obj1 |  obj2 |obj3   |       |       |       |
                                    ↑                       ↑    
                                 cons_head              prod_head
                                    ↑                       ↑                                     
                                 cons_tail              prod_tail
</code></pre></li><li><p>修改ring结构中的ring-> prod_head以指向与prod_next相同的位置。此操作使用“比较并交换”（CAS）指令完成，该指令自动执行以下操作：</p><ul><li><p>如果ring-> prod_head与局部变量prod_head不同，则CAS操作失败，并且代码在第一步重新启动。</p></li><li><blockquote><p>[!NOTE]</p><p>在该图中，操作在内核1上成功完成，而第一步在内核2上重新启动。之后在核心2上重试CAS操作，可以看到core2再次拿到prod_head</p><pre tabindex=0><code>                                                        // compare and swap succeseds on core1 ,failed on core2
// local variable core 2         cons_tail                         prod_head  prod_next
                                    ↓                                ↓        ↓
// local variable core 1         cons_tail              prod_head  prod_next 
                                    ↓                       ↓        ↓
|       |       |       |       |  obj1 |  obj2 |obj3   |       |       |       |
                                    ↑                                ↑    
                                 cons_head                         prod_head
                                 cons_tail              prod_tail
</code></pre></blockquote></li><li><p>否则，将ring-> prod_head设置为本地prod_next，CAS操作成功，然后继续处理。</p></li><li><blockquote><p>[!NOTE]</p><p>最终核心1更新了ring（obj4）的一个元素，核心2更新了另一个（obj5）的元素。</p><pre tabindex=0><code>                                                        // compare and swap succeseds on core2 
// local variable core 2         cons_tail                         prod_head  prod_next
                                    ↓                                ↓        ↓
// local variable core 1         cons_tail              prod_head  prod_next 
                                    ↓                       ↓        ↓
|       |       |       |       |  obj1 |  obj2 |obj3   |  obj4 |  obj5  |       |
                                    ↑                                         ↑    
                                 cons_head                                   prod_head
                                    ↑                       ↑    
                                 cons_tail              prod_tail
</code></pre></blockquote></li></ul></li><li><p>每个内核现在都想更新ring-> prod_tail。仅当ring-> prod_tail等于prod_head局部变量时，内核才能更新它。这仅在内核1上成立。操作已在内核1上完成。</p><ul><li><blockquote><p>[!NOTE]</p><pre tabindex=0><code>                                                        // core2 wait for real prod_tail = it&#39;s prod_head, core 1 compare real prod_tail to it&#39;s prod_tail, and swap real prod_tail to move forward
// local variable core 2         cons_tail                         prod_head  prod_next
                                    ↓                                ↓        ↓
// local variable core 1         cons_tail              prod_head  prod_next 
                                    ↓                       ↓        ↓
|       |       |       |       |  obj1 |  obj2 |obj3   |  obj4 |  obj5  |       |
                                    ↑                                         ↑    
                                 cons_head                                    prod_head
                                    ↑                                ↑    
                                 cons_tail                         prod_tail
</code></pre></blockquote></li></ul></li><li><p>内核1更新了ring-> prod_tail之后，内核2也可以对其进行更新。该操作也在内核2上完成。</p><ul><li><blockquote><p>[!NOTE]</p><pre tabindex=0><code>                                                        // core2 wait for real prod_tail = it&#39;s prod_head, core 1 compare real prod_tail to it&#39;s prod_tail, and swap real prod_tail to move forward
// local variable core 2         cons_tail                         prod_head  prod_next
                                    ↓                                ↓        ↓
// local variable core 1         cons_tail              prod_head  prod_next 
                                    ↓                       ↓        ↓
|       |       |       |       |  obj1 |  obj2 |obj3   |  obj4 |  obj5  |       |
                                    ↑                                         ↑    
                                 cons_head                                    prod_head
                                    ↑                                         ↑    
                                 cons_tail                                    prod_tail
</code></pre></blockquote></li></ul></li></ol><h2 class="relative group">10 线程池<div id=10-%E7%BA%BF%E7%A8%8B%E6%B1%A0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10-%E7%BA%BF%E7%A8%8B%E6%B1%A0 aria-label=锚点>#</a></span></h2><p>先来点基础知识：</p><p>C++ FUTURE提供了下面这些类型：</p><ul><li>Providers 类：std::promise, std::package_task</li><li>Futures 类：std::future, shared_future.</li><li>Providers 函数：std::async()</li><li>其他类型：std::future_error, std::future_errc, std::future_status, std::launch.</li></ul><h4 class="relative group">std::future && std::packaged_task<div id=stdfuture--stdpackaged_task class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#stdfuture--stdpackaged_task aria-label=锚点>#</a></span></h4><p>什么是std::future? std::future 可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p><p>什么是std::packaged_task? std::packaged_task 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果，std::packaged_task 与 std::function 类似，只不过 std::packaged_task 将其包装的可调用对象的执行结果通过task.get_future传递给一个 std::future 对象（该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果）。</p><p>有了问题就可以用线程池和异步执行，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;utility&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;thread_pool.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Schedule a task to the given thread pool. If thread_pool is null, run the
</span></span></span><span class=line><span class=cl><span class=c1>// task synchronously on the current thread.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Func</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ScheduleFuture</span><span class=p>(</span><span class=n>ThreadPool</span><span class=o>*</span> <span class=n>thread_pool</span><span class=p>,</span> <span class=n>Func</span><span class=o>&amp;&amp;</span> <span class=n>f</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>thread_pool</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Future</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>result_of</span><span class=o>&lt;</span><span class=n>Func</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>future</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>async</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>launch</span><span class=o>::</span><span class=n>deferred</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Func</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                   <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...));</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span><span class=p>.</span><span class=n>Wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>future</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>thread_pool</span><span class=o>-&gt;</span><span class=n>Schedule</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Func</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                               <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Schedule a task to the default thread pool.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Func</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ScheduleFuture</span><span class=p>(</span><span class=n>Func</span><span class=o>&amp;&amp;</span> <span class=n>f</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>ScheduleFuture</span><span class=p>(</span><span class=n>ThreadPool</span><span class=o>::</span><span class=n>DefaultPool</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Func</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                        <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Asynchronously destroy a container.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ContainerT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DestroyContainerAsync</span><span class=p>(</span><span class=n>ThreadPool</span><span class=o>*</span> <span class=n>thread_pool</span><span class=p>,</span> <span class=n>ContainerT</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ScheduleFuture</span><span class=p>(</span><span class=n>thread_pool</span><span class=p>,</span> <span class=p>[</span><span class=n>_</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>container</span><span class=p>)]()</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>unused</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Same, but use the default thread pool.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ContainerT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DestroyContainerAsync</span><span class=p>(</span><span class=n>ContainerT</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DestroyContainerAsync</span><span class=p>(</span><span class=n>ThreadPool</span><span class=o>::</span><span class=n>DisposalPool</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>container</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>WaitForFuture</span><span class=p>(</span><span class=k>const</span> <span class=n>Future</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>future</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>future</span><span class=p>.</span><span class=n>Wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>  <span class=c1>// namespace async
</span></span></span></code></pre></div><p>下面看线程池的代码，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>ThreadPool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>ThreadPool</span><span class=p>(</span><span class=kt>int</span> <span class=n>num_workers</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span><span class=o>&gt;&amp;</span> <span class=n>init_thread</span> <span class=o>=</span> <span class=p>{});</span>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>ThreadPool</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Return the default thread pool.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>ThreadPool</span><span class=o>*</span> <span class=nf>DefaultPool</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Return the disposal thread pool to destroy stuff asynchronously.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>ThreadPool</span><span class=o>*</span> <span class=nf>DisposalPool</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ThreadPool</span><span class=p>(</span><span class=k>const</span> <span class=n>ThreadPool</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ThreadPool</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>ThreadPool</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>NumWorkers</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>workers_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Func</span><span class=p>,</span> <span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>FutureType</span> <span class=o>=</span> <span class=n>Future</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>result_of</span><span class=o>&lt;</span><span class=n>Func</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Schedule a new task.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Func</span><span class=p>,</span> <span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>FutureType</span><span class=o>&lt;</span><span class=n>Func</span><span class=p>,</span> <span class=n>Args</span><span class=p>...</span><span class=o>&gt;</span> <span class=n>Schedule</span><span class=p>(</span><span class=n>Func</span><span class=o>&amp;&amp;</span> <span class=n>f</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>LOCKS_EXCLUDED</span><span class=p>(</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>absl</span><span class=o>::</span><span class=n>Mutex</span> <span class=n>mutex_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>absl</span><span class=o>::</span><span class=n>CondVar</span> <span class=n>cond_var_</span> <span class=n>GUARDED_BY</span><span class=p>(</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kr>thread</span><span class=o>&gt;</span> <span class=n>workers_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// A thread safe queue protected by condition_ and mutex_.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;&gt;</span> <span class=n>tasks_</span> <span class=n>GUARDED_BY</span><span class=p>(</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>stop_requested_</span> <span class=nf>GUARDED_BY</span><span class=p>(</span><span class=n>mutex_</span><span class=p>)</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Func</span><span class=p>,</span> <span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>ThreadPool</span><span class=o>::</span><span class=n>FutureType</span><span class=o>&lt;</span><span class=n>Func</span><span class=p>,</span> <span class=n>Args</span><span class=p>...</span><span class=o>&gt;</span> <span class=n>ThreadPool</span><span class=o>::</span><span class=n>Schedule</span><span class=p>(</span><span class=n>Func</span><span class=o>&amp;&amp;</span> <span class=n>f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                           <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>ReturnType</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>result_of</span><span class=o>&lt;</span><span class=n>Func</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=k>auto</span> <span class=n>task</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>packaged_task</span><span class=o>&lt;</span><span class=n>ReturnType</span><span class=p>()</span><span class=o>&gt;&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>bind</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Func</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...));</span>
</span></span><span class=line><span class=cl>  <span class=n>Future</span><span class=o>&lt;</span><span class=n>ReturnType</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>(</span><span class=n>task</span><span class=o>-&gt;</span><span class=n>get_future</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If there is no worker, this is an inline thread pool, and the task will be
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// immediately run on the current thread.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int64_t</span> <span class=n>tasks_size</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>workers_</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=o>*</span><span class=n>task</span><span class=p>)();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>absl</span><span class=o>::</span><span class=n>MutexLock</span> <span class=n>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// QCHECK(!stop_requested_) &lt;&lt; &#34;The thread pool has been stopped&#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>tasks_</span><span class=p>.</span><span class=n>emplace</span><span class=p>([</span><span class=n>task</span><span class=p>]()</span> <span class=p>{</span> <span class=p>(</span><span class=o>*</span><span class=n>task</span><span class=p>)();</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=n>tasks_size</span> <span class=o>=</span> <span class=n>tasks_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cond_var_</span><span class=p>.</span><span class=n>Signal</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>tasks_size</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>QCOUNTER</span><span class=p>(</span><span class=s>&#34;schedulefuture_callback_size&#34;</span><span class=p>,</span> <span class=n>tasks_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;thread_pool.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>ThreadPool</span><span class=o>::</span><span class=n>ThreadPool</span><span class=p>(</span><span class=kt>int</span> <span class=n>num_workers</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span><span class=o>&gt;&amp;</span> <span class=n>init_thread</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>num_workers</span><span class=p>;</span> <span class=o>++</span><span class=n>index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>workers_</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>([</span><span class=k>this</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>init_thread</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>init_thread</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>init_thread</span><span class=p>(</span><span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>task</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>absl</span><span class=o>::</span><span class=n>MutexLock</span> <span class=n>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stop_requested_</span> <span class=o>&amp;&amp;</span> <span class=n>tasks_</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cond_var_</span><span class=p>.</span><span class=n>Wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span><span class=n>stop_requested_</span> <span class=o>&amp;&amp;</span> <span class=n>tasks_</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=n>task</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>tasks_</span><span class=p>.</span><span class=n>front</span><span class=p>());</span>
</span></span><span class=line><span class=cl>          <span class=n>tasks_</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>task</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ThreadPool</span><span class=o>::~</span><span class=n>ThreadPool</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>absl</span><span class=o>::</span><span class=n>MutexLock</span> <span class=n>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>stop_requested_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cond_var_</span><span class=p>.</span><span class=n>SignalAll</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kr>thread</span><span class=o>&amp;</span> <span class=nl>worker</span> <span class=p>:</span> <span class=n>workers_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>worker</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// static
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ThreadPool</span><span class=o>*</span> <span class=n>ThreadPool</span><span class=o>::</span><span class=n>DefaultPool</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>ThreadPool</span><span class=o>*</span> <span class=n>default_pool</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadPool</span><span class=p>(</span><span class=n>FLAGS_default_pool_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>default_pool</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// static
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ThreadPool</span><span class=o>*</span> <span class=n>ThreadPool</span><span class=o>::</span><span class=n>DisposalPool</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>ThreadPool</span><span class=o>*</span> <span class=n>disposal_pool</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadPool</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>disposal_pool</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">11 LFBB的实现<div id=11-lfbb%E7%9A%84%E5%AE%9E%E7%8E%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-lfbb%E7%9A%84%E5%AE%9E%E7%8E%B0 aria-label=锚点>#</a></span></h2><p>这几天看到一个实现很有意思的代码，https://github.com/DNedic/lfbb</p><p>简单看一下头文件和C文件里面的核心代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对于嵌入式系统，缓存同步是手动执行的，这个可以设置为false
</span></span></span><span class=line><span class=cl><span class=c1>// 对于可能有false sharing的系统，需要设置这个为true，这个会要求将原子变量要求对cacheline size（默认64）对齐
</span></span></span><span class=line><span class=cl><span class=c1>// 对于现代CPU，如果两个不同CPU对同一个cacheline里面的两个对象操作，就会导致false sharing，所以这里需要alignas一下
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef LFBB_MULTICORE_HOSTED
</span></span></span><span class=line><span class=cl><span class=cp>#define LFBB_MULTICORE_HOSTED false
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 现代CPU体系的cacheline size，看芯片的类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef LFBB_CACHELINE_LENGTH
</span></span></span><span class=line><span class=cl><span class=cp>#define LFBB_CACHELINE_LENGTH 64U
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/*************************** TYPES ****************************/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>size</span><span class=p>;</span>        <span class=cm>/**&lt; Size of the data array */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>      <span class=cm>/**&lt; Pointer to the data array */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>write_wrapped</span><span class=p>;</span> <span class=cm>/**&lt; Write wrapped flag, used only in the producer */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>read_wrapped</span><span class=p>;</span>  <span class=cm>/**&lt; Read wrapped flag, used only in the consumer */</span>
</span></span><span class=line><span class=cl><span class=cp>#if LFBB_MULTICORE_HOSTED
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=nf>alignas</span><span class=p>(</span><span class=n>LFBB_CACHELINE_LENGTH</span><span class=p>)</span> <span class=kt>atomic_size_t</span> <span class=n>r</span><span class=p>;</span> <span class=cm>/**&lt; Read index */</span>
</span></span><span class=line><span class=cl>  <span class=nf>alignas</span><span class=p>(</span><span class=n>LFBB_CACHELINE_LENGTH</span><span class=p>)</span> <span class=kt>atomic_size_t</span> <span class=n>w</span><span class=p>;</span> <span class=cm>/**&lt; Write index */</span>
</span></span><span class=line><span class=cl>  <span class=nf>alignas</span><span class=p>(</span><span class=n>LFBB_CACHELINE_LENGTH</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=kt>atomic_size_t</span> <span class=n>i</span><span class=p>;</span> <span class=cm>/**&lt; Invalidated space index */</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>atomic_size_t</span> <span class=n>r</span><span class=p>;</span> <span class=cm>/**&lt; Read index */</span>
</span></span><span class=line><span class=cl>  <span class=kt>atomic_size_t</span> <span class=n>w</span><span class=p>;</span> <span class=cm>/**&lt; Write index */</span>
</span></span><span class=line><span class=cl>  <span class=kt>atomic_size_t</span> <span class=n>i</span><span class=p>;</span> <span class=cm>/**&lt; Invalidated space index */</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span> <span class=n>LFBB_Inst_Type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//剩下就是初始化，释放，获取之类的啥的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>LFBB_Init</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data_array</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=nf>LFBB_WriteAcquire</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>free_required</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>LFBB_WriteRelease</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>written</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=nf>LFBB_ReadAcquire</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>available</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>LFBB_ReadRelease</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>read</span><span class=p>);</span>
</span></span></code></pre></div><p>看一下.c文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// lfbb是单写单读，所以w只有writer自己操作，但是r是另外一个线程能够操作的
</span></span></span><span class=line><span class=cl><span class=c1>// 所以
</span></span></span><span class=line><span class=cl><span class=c1>// 先是memory_order_relaxed获取w，memory_order_acquire获取r（因为w是自己会改，而r是别人会改，所以必须acquire方式获取）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=o>*</span><span class=nf>LFBB_WriteAcquire</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=k>const</span> <span class=kt>size_t</span> <span class=n>free_required</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Preload variables with adequate memory ordering */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>w</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>w</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>r</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>r</span><span class=p>,</span> <span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>free</span> <span class=o>=</span> <span class=nf>CalcFree</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>linear_space</span> <span class=o>=</span> <span class=n>size</span> <span class=o>-</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>linear_free</span> <span class=o>=</span> <span class=nf>MIN</span><span class=p>(</span><span class=n>free</span><span class=p>,</span> <span class=n>linear_space</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Try to find enough linear space until the end of the buffer */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>free_required</span> <span class=o>&lt;=</span> <span class=n>linear_free</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=n>w</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* If that doesn&#39;t work try from the beginning of the buffer */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>free_required</span> <span class=o>&lt;=</span> <span class=n>free</span> <span class=o>-</span> <span class=n>linear_free</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>inst</span><span class=o>-&gt;</span><span class=n>write_wrapped</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Could not find free linear space with required size */</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// lfbb是单写单读，所以w只有writer自己操作，但是w的修改是需要让另外一个线程能够读取到的
</span></span></span><span class=line><span class=cl><span class=c1>// 所以
</span></span></span><span class=line><span class=cl><span class=c1>// 先是memory_order_relaxed获取w，memory_order_release写入w（因为w是自己会改，但必须让别人知道，所以必须release方式写入）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>LFBB_WriteRelease</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=k>const</span> <span class=kt>size_t</span> <span class=n>written</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>w</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>w</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* If the write wrapped set the invalidate index and reset write index*/</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>write_wrapped</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>inst</span><span class=o>-&gt;</span><span class=n>write_wrapped</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>i</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Increment the write index */</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>w</span> <span class=o>+</span> <span class=n>written</span> <span class=o>&lt;=</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>w</span> <span class=o>+=</span> <span class=n>written</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* If we wrote over invalidated parts of the buffer move the invalidate
</span></span></span><span class=line><span class=cl><span class=cm>   * index
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>w</span> <span class=o>&gt;</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Wrap the write index if we reached the end of the buffer */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>w</span> <span class=o>==</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Store the indexes with adequate memory ordering */</span>
</span></span><span class=line><span class=cl>  <span class=nf>atomic_store_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>atomic_store_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>w</span><span class=p>,</span> <span class=n>w</span><span class=p>,</span> <span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=nf>LFBB_ReadAcquire</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=kt>size_t</span> <span class=o>*</span><span class=n>available</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>available</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Preload variables with adequate memory ordering */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>r</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>r</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>w</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>w</span><span class=p>,</span> <span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* When read and write indexes are equal, the buffer is empty */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=n>w</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>available</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Simplest case, read index is behind the write index */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&lt;</span> <span class=n>w</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>available</span> <span class=o>=</span> <span class=n>w</span> <span class=o>-</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=n>r</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Read index reached the invalidate index, make the read wrap */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>i</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>inst</span><span class=o>-&gt;</span><span class=n>read_wrapped</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>available</span> <span class=o>=</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* There is some data until the invalidate index */</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>available</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=n>r</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>LFBB_ReadRelease</span><span class=p>(</span><span class=n>LFBB_Inst_Type</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=k>const</span> <span class=kt>size_t</span> <span class=n>read</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* If the read wrapped, overflow the read index */</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>read_wrapped</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>inst</span><span class=o>-&gt;</span><span class=n>read_wrapped</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=nf>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>r</span><span class=p>,</span> <span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Increment the read index and wrap to 0 if needed */</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span> <span class=o>+=</span> <span class=n>read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Store the indexes with adequate memory ordering */</span>
</span></span><span class=line><span class=cl>  <span class=nf>atomic_store_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>r</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">12 MPMC & SPSC<div id=12-mpmc--spsc class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#12-mpmc--spsc aria-label=锚点>#</a></span></h2><p>这两天在优化一个混杂了计算和通信的复杂模型，要求在一瞬间有任务冲击的情况下，满足实行性要求，所以在修改网络模型和计算模型，这里面涉及到一个怎么把计算任务 <strong>平均 & 高效</strong>地分发到每个计算任务</p><p>设计两种模式</p><ul><li>使用SPSC：假设两个IO，两个计算，那么每个IO内置两个SPSC分别指向两个计算，每次来了任务将任务轮训调度到自己的两个队列</li><li>使用MPMC：假设多个IO，多个计算，IO和计算之间共享MPMC</li></ul><p>希望达到的效果是：</p><ul><li>能够高效的Enqueue和Dequeue</li><li>能够保证待Dequeue的任务在最惨的情况 & under heavy contention 下不会等待过久的时间。</li></ul><p>因此参考了上面的设计模式，对比了下面的几种情况</p><ul><li><p>使用SPSC：</p><ul><li><a href=https://github.com/DNedic/lfbb target=_blank>https://github.com/DNedic/lfbb</a></li></ul></li><li><p>使用MPMC</p><ul><li><p><a href=https://github.com/rigtorp/MPMCQueue target=_blank>https://github.com/rigtorp/MPMCQueue</a></p></li><li><p><a href=https://github.com/facebook/folly/blob/main/folly/MPMCQueue.h target=_blank>https://github.com/facebook/folly/blob/main/folly/MPMCQueue.h</a></p></li><li><p><a href=https://github.com/cameron314/concurrentqueue target=_blank>https://github.com/cameron314/concurrentqueue</a></p></li></ul></li></ul><p>测试方案设计如下：</p><ul><li><p>客户端</p><ul><li><p>使用Asio写了一个纯异步的客户端，有一个QPS记录器，尽量快速地增加QPS，（请注意这里我们不是令牌桶，要的就不是均匀的请求分发）如果超过了QPS限制也不能阻塞转而去处理收包事件，等待QPS恢复。</p></li><li><p>具体指标200个连接，32个发送连接， 3000的QPS， 持续60S</p></li></ul></li><li><p>服务端</p><ul><li>设计等同于CPU核心数量的计算和等同于CPU核心数量*2的IO，每个计算的Dequeue都让CPU处于一直自旋的状态，假设每个任务计算需要花费2～5ms。要求不能超时超过一个特定的标准值，这个参考值会最终决定我们的选择，一会再单独说。需要测试两种情况<ul><li>服务端需要同时完成很慢的计算任务处理，Dequeue的效率</li><li>服务端无需完成很慢的计算任务，就是单纯较轻松的空转，Dequeue的效率</li></ul></li></ul></li></ul><p>使用CDF散点图让我们直观看一下效率</p><ul><li>第一张图为服务端需要同时完成很慢的计算任务处理，<strong>单位为ms</strong></li><li>第二张图为服务端就是较轻松的空转，<strong>单位为us</strong></li></ul><p>分别针对服务端需要参与大量计算，和服务端没有计算，就是快速响应的情况，分析可知</p><ul><li><p>服务端有较重的计算任务时</p><ul><li><p>追求快速响应，那么moodycamel::ConcurrentQueue & moodycamel::BlockingConcurrentQueue 的效果会很好，3.7ms内91.9%的请求被Dequeue，但有长尾效应，有5%的请求慢于223ms才dequeue。如果超时时间的值小于5ms，可以选择这种。LFBB & Rigotorp可以直接排除</p></li><li><p>Rigotorp最稳定，15ms 99.5%的请求都Dequeue，如果超时时间大于15ms，并且能给任务处理流出足够的响应的时间，Rigotop最合适。这里稍微多说一句，<strong>这个Dequeue不是说Rigotorp Dequeue的效率，它实际上是算上了本身计算任务所花费的时延，这就是为什么看起来同时来的一堆任务，这个从任务创建到Dequeue的时间时不断增加的，因为这些增加的时间里面，在处理计算任务</strong></p></li><li><p>LFBB，中规中矩。</p></li></ul></li><li><p>服务端较轻松的空转时(注意这里我没再测试moodycamel::BlockingConcurrentQueue)</p><ul><li><p>追求快速响应，那么moodycamel::ConcurrentQueue的效果会很好，0.6ms内95%的请求被Dequeue，但有长尾效应，有3%的请求慢于1ms才dequeue(这个1ms的结果我没截）。</p></li><li><p>Rigotorp最稳定，0.8ms 99.5%的请求都Dequeue。</p></li><li><p>LFBB，中规中矩。</p></li></ul></li></ul><p>因此可以得出结论：</p><ul><li>Rigotorp属于性能最稳定，其吞吐量最优，能保证最糟的情况下，也能把任务拿到，不会有长尾效应</li><li>追求快速响应，那么moodycamel::ConcurrentQueue的效果会很好，0.6ms内95%的请求被Dequeue，但有长尾效应，有3%的请求慢于1ms才dequeue(这个1ms的结果我没截）</li></ul><p><figure><img class="my-0 rounded-md" loading=lazy src=imgs/cdf.png alt=计算任务重></figure></p><p><figure><img class="my-0 rounded-md" loading=lazy src=imgs/light_cdf.png alt=空转></figure></p><p>所以接下来看一下Rogtorp的MPMC怎么实现的，参考论文https://dl.acm.org/doi/pdf/10.1145/2086696.2086728，感觉确实做的很牛！</p><p>传统的队列算法有一种或另一种变体试图通过主入口（通常是头指针），这种操作需要CAS来判断是否能够对头部操作。</p><p>Rigtorp的解决方案背后的直觉可以用火车站和队列算法的类比来解释：排队过程类似于乘客登上火车，乘客（处理器）可以获得车票（整数），然后登上（排队）火车（队列）直接并行到他们的座位（阵列位置）。换言之，不需要CAS等待某个指针操作完成，而是直接拿到车票，等着座位可以坐。</p><p>那么为什么Rigtorp的效率更高呢，这里结合伪代码来分析下</p><ul><li>其他使用“inquire-then-update”方法的算法（例如 MS-Queue 算法或自旋锁实现）进行一次队列操作至少需要两次完整的内存往返。<ul><li>针对获取SpinLock的方法，过程为（1）获取锁，（2）读取队列指针，（3）更新队列结构，（4）释放锁。最好的情况下，获取锁需要1个RTT，对当前指针执行获取并写入需要一个RTT，释放只花费0.5RTT。所以一次操作花费1/2.5RTT。但是可能对一个锁的频繁占用造成等待。</li><li>针对非常经典的DPDK 多生产多消费环形队列</li></ul></li><li>而Rigtorp的MPMC遵循另一种途径：如果可能的话，每一个单独的内存操作都应该保证成功。其实现的核心在很大程度上依赖于Fetch and Add”操作，这个操作总是能够通过一次内存操作成功地改变队列的状态。<ul><li>Rigtorp的（写，这里读写都可以，只说写）过程可以模拟为：（1）获取Ticket ，（2）读取Turn判断是否到自己的“回合”可以操作。最好的情况下，FetchAndAdd获取Ticket，一个原子变量RTT，读取Turn花费一个原子变量RTT。所以一个操作花费1/2RTT，最好情况下两个读写两个顺序执行，所以直接写入，效率乘二。多CPU争用的情况很少</li></ul></li></ul><p>分析一下效率</p><ul><li>其它方法，比方说</li><li>Rigtorp的效率<ul><li>假设读写者的效率都极高</li><li>假设读写者的效率并不高</li></ul></li></ul><p>这里再看一下Rigtorp的代码，pop & push的代码都非常简单，就和参考文献写的一致，主要看try_pop: try_pop的逻辑会稍微复杂一点点，我画了一个流程图</p><pre tabindex=0><code>
void pop(T &amp;v) noexcept {
  auto const tail = tail_.fetch_add(1);
  auto &amp;slot = slots_[idx(tail)];
  while (turn(tail) * 2 + 1 != slot.turn.load(std::memory_order_acquire))
    ;
  v = slot.move();
  slot.destroy();
  slot.turn.store(turn(tail) * 2 + 2, std::memory_order_release);
}
// push 包着这个emplace
template &lt;typename... Args&gt; void emplace(Args &amp;&amp;...args) noexcept {
  static_assert(std::is_nothrow_constructible&lt;T, Args &amp;&amp;...&gt;::value,
                &#34;T must be nothrow constructible with Args&amp;&amp;...&#34;);
  auto const head = head_.fetch_add(1);
  auto &amp;slot = slots_[idx(head)];
  while (turn(head) * 2 != slot.turn.load(std::memory_order_acquire))
    ;
  slot.construct(std::forward&lt;Args&gt;(args)...);
  slot.turn.store(turn(head) * 2 + 1, std::memory_order_release);
}


bool try_pop(T &amp;v) noexcept {
  auto tail = tail_.load(std::memory_order_acquire);
  for (;;) {
    auto &amp;slot = slots_[idx(tail)];
    if (turn(tail) * 2 + 1 == slot.turn.load(std::memory_order_acquire)) {
      if (tail_.compare_exchange_strong(tail, tail + 1)) {
        v = slot.move();
        slot.destroy();
        slot.turn.store(turn(tail) * 2 + 2, std::memory_order_release);
        return true;
      }
    } else {
      auto const prevTail = tail;
      tail = tail_.load(std::memory_order_acquire);
      if (tail == prevTail) {
        return false;
      }
    }
  }
}
</code></pre><p><figure><img class="my-0 rounded-md" loading=lazy src=imgs/try_pop_analysis.png alt=try_pop_analysis></figure></p><p>这里再看下moodycamel::ConcurrentQueue的实现方法，考虑下为什么moodycamel::ConcurrentQueue的最差情况不比rigtorp好，但是它最快的情况下更好</p><h2 class="relative group">13 Token Bucket<div id=13-token-bucket class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-token-bucket aria-label=锚点>#</a></span></h2><p>这两天测试数据，看到了一个一个令牌桶，写的很有意思，还是Rigtorp大佬的代码库，看了一下使用的实际上是时间戳+原子变量实现。仔细看了一下，发现实现的很简单也很好玩。具体的代码解释和源代码一起写到了下面的注释</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// © 2023 Erik Rigtorp &lt;erik@rigtorp.se&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// SPDX-License-Identifier: MIT
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;chrono&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 默认时钟用chrono 的steady_clock
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Clock</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>steady_clock</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>TokenBucket</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>TokenBucket</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// timePerToken_ 实际上是多久产生一个token，这里的rate理解为qps的话，那么timePerToken_就是1/qps
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// burstSize 对应于https://en.wikipedia.org/wiki/Token_bucket里面的burstsize，指的是一下子最多拿走多少，可以理解为当前桶的容量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>TokenBucket</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>rate</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>burstSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>timePerToken_</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>nanoseconds</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>seconds</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span> <span class=o>/</span> <span class=n>rate</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>timePerBurst_</span><span class=p>(</span><span class=n>burstSize</span> <span class=o>*</span> <span class=n>timePerToken_</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 这里就是真正的判断是否可以获取的地方
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=nf>consume</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>tokens</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 先拿到当前时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=n>now</span> <span class=o>=</span> <span class=n>Clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 看看获得对应数量的tokens需要多少时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=n>timeNeeded</span> <span class=o>=</span> <span class=n>tokens</span> <span class=o>*</span> <span class=n>timePerToken_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>minTime</span> <span class=o>=</span> <span class=n>now</span> <span class=o>-</span> <span class=n>timePerBurst_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取上次拿的时间，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>oldTime</span> <span class=o>=</span> <span class=n>time_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>newTime</span> <span class=o>=</span> <span class=n>oldTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>minTime</span> <span class=o>&gt;</span> <span class=n>newTime</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>newTime</span> <span class=o>=</span> <span class=n>minTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 上次拿的时候到多久才能拿到想要的tokens的个数，计算出来这个时间是多少。
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 如果这个时间比现在还大，那是绝对不能满足的，所以直接返回失败即可
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 这里有个点，如果oldTime被其它的线程抢走了，那下面的if时必然失败的，所以同样需要放弃
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>newTime</span> <span class=o>+=</span> <span class=n>timeNeeded</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>newTime</span> <span class=o>&gt;</span> <span class=n>now</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 前面是判断能不能拿，这次就是要挪动time的浮标，来判断是不是真正可以拿走了
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 如果和oldTime一样，说明没有其它的token消费者动它，直接拿了就走返回了
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 如果和oldTime不一样，就说明被其它的token获取者拿走了，此时compare_exchange_weak会把time_的新的值给到oldTime，
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 换言之重新执行了，auto oldTime = time_.load(std::memory_order_relaxed);，然后再次进入for循环，直到下一次能拿到
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 但是如果发现token一致不够，或者说要是拿token比当前时间晚才能拿到，那就放弃，就在上面的if里面return false了
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>time_</span><span class=p>.</span><span class=n>compare_exchange_weak</span><span class=p>(</span><span class=n>oldTime</span><span class=p>,</span> <span class=n>newTime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 这个可以理解为一个单调递增的time
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Clock</span><span class=o>::</span><span class=n>time_point</span><span class=o>&gt;</span> <span class=n>time_</span> <span class=o>=</span> <span class=p>{</span><span class=n>Clock</span><span class=o>::</span><span class=n>time_point</span><span class=o>::</span><span class=n>min</span><span class=p>()};</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 问题，为什么需要这两个变量？很简单，这个东西是衡量需要多少时间的基本单位
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>nanoseconds</span> <span class=n>timePerToken_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>nanoseconds</span> <span class=n>timePerBurst_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 class="relative group">结尾<div id=%E7%BB%93%E5%B0%BE class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BB%93%E5%B0%BE aria-label=锚点>#</a></span></h2><p>唉，尴尬</p><p><figure><img class="my-0 rounded-md" loading=lazy src=https://i.loli.net/2020/08/27/BFHNyfpx3EsIDUG.jpg alt=狗头的赞赏码.jpg></figure></p></div></div><script>var oid="views_posts\\2021-07-21-C++开发工具库\\index.md",oid_likes="likes_posts\\2021-07-21-C++开发工具库\\index.md"</script><script type=text/javascript src=/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q+oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/2021-06-01-hpke%E7%AC%94%E8%AE%B0/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">HPKE笔记</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2021-06-01T00:00:00+00:00>2021 年 6 月 1 日</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/posts/2021-08-09-llvm%E5%AD%A6%E4%B9%A0/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">llvm学习</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2021-08-09T00:00:00+00:00>2021 年 8 月 9 日</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">© 2025 - 2025 菜狗 All Rights Reserved.</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://hxndg.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>