<!DOCTYPE html>
<html lang="cn" dir="ltr" class="scroll-smooth" data-default-appearance="light"
  data-auto-appearance="true"><head>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="zh-cn" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>2024-06-02-bazel从入门到中级 &middot; 菜狗的blog</title>
  <meta name="title" content="2024-06-02-bazel从入门到中级 &middot; 菜狗的blog" />
  
  <meta name="description" content="菜狗&#39;s website" />
  <meta name="keywords" content="bazel, ci, " />
  
  
  <link rel="canonical" href="https://hxndg.github.io/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.36c3cd7950e4533fa7da3150d972e3edf34d07f83c0264ff04cad0969dfdb3b8a7065b0ed6c730c6d34a7bad516cfc6f6a5917ab1fdb10b25f481f8a17b54c16.css"
    integrity="" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.b6411b5d4cd56c0068d34c4acbce043846adad56b824e3d486a06d3459aed2eb7f7413874b7871cc2c822c8c8834cbed944022918bcc8cca710a962167c36d32.js"
    integrity="sha512-tkEbXUzVbABo00xKy84EOEatrVa4JOPUhqBtNFmu0ut/dBOHS3hxzCyCLIyINMvtlEAikYvMjMpxCpYhZ8NtMg==" data-copy="复制" data-copied="已复制"></script>
  
  
  
  <script src="/lib/zoom/zoom.min.f592a181a15d2a5b042daa7f746c3721acf9063f8b6acd175d989129865a37d400ae0e85b640f9ad42cd98d1f8ad30931718cf8811abdcc5fcb264400d1a2b0c.js" integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj&#43;Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="https://hxndg.github.io/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/">
  <meta property="og:site_name" content="菜狗的blog">
  <meta property="og:title" content="2024-06-02-bazel从入门到中级">
  <meta property="og:description" content="菜狗&#39;s website">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-05-10T00:00:00+00:00">
    <meta property="article:tag" content="Bazel">
    <meta property="article:tag" content="Ci">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="2024-06-02-bazel从入门到中级">
  <meta name="twitter:description" content="菜狗&#39;s website">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "2024-06-02-bazel从入门到中级",
    "headline": "2024-06-02-bazel从入门到中级",
    
    
    "inLanguage": "zh-cn",
    "url" : "https:\/\/hxndg.github.io\/posts\/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7\/",
    "author" : {
      "@type": "Person",
      "name": "菜狗"
    },
    "copyrightYear": "2024",
    "dateCreated": "2024-05-10T00:00:00\u002b00:00",
    "datePublished": "2024-05-10T00:00:00\u002b00:00",
    
    "dateModified": "2024-05-10T00:00:00\u002b00:00",
    
    "keywords": ["bazel","ci"],
    
    "mainEntityOfPage": "true",
    "wordCount": "43709"
  }]
  </script>


  
  
  <meta name="author" content="菜狗" />
  
  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>






















  
  

<script async src="https://www.googletagmanager.com/gtag/js?id=G-6X9LWNJ427"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6X9LWNJ427');
</script>



  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">菜狗的blog</a>
            

        </nav>
        <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">

            
            
            
  <a href="/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="菜狗的blog">
        Home
    </p>
</a>



            
            
  <a href="/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Posts">
        Posts
    </p>
</a>



            
            
  <a href="/tags/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Tags">
        Tags
    </p>
</a>



            
            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class=" flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 md:hidden">

        <label id="menu-button" class="block">
            
            <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
                

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>

  </span>


            </div>
            <div id="menu-wrapper" style="padding-top:5px;"
                class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50">
                <ul
                    class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl">

                    <li id="menu-close-button">
                        <span
                            class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>

</span>
                    </li>

                    

                    
  <li class="mt-1">
    <a href="/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="菜狗的blog">
            Home
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Posts">
            Posts
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/tags/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Tags">
            Tags
        </p>
    </a>
</li>




                    

                </ul>
                
                

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  
  
  
  
  
  
 



  
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      2024-06-02-bazel从入门到中级
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  













<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2024-05-10T00:00:00&#43;00:00">2024 年 5 月 10 日</time><span class="px-2 text-primary-500">&middot;</span><span>43709 字</span><span class="px-2 text-primary-500">&middot;</span><span title="预计阅读">88 分钟</span>
  

  
  
</div>








    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
  <div class="place-self-center">
    
    <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
      作者
    </div>
    <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
      菜狗
    </div>
    
    
    <div class="text-sm text-neutral-700 dark:text-neutral-400">Focus</div>
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
     <div
      class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8">
      <div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10">

         <details open id="TOCView"
  class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    目录
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么使用bazel">为什么使用Bazel</a>
      <ul>
        <li><a href="#why-bazel">Why Bazel</a></li>
      </ul>
    </li>
    <li><a href="#基础篇">基础篇</a>
      <ul>
        <li><a href="#1-bazel基础概念通识">1 Bazel基础概念通识</a>
          <ul>
            <li><a href="#action">Action</a></li>
            <li><a href="#action-cache">Action cache</a></li>
            <li><a href="#action-graph">Action graph</a></li>
            <li><a href="#action-graph-query-aquery">Action graph query (aquery)</a></li>
            <li><a href="#action-key">Action key</a></li>
            <li><a href="#analysis-phase">Analysis phase</a></li>
            <li><a href="#artifact">Artifact</a></li>
            <li><a href="#aspect">Aspect</a></li>
            <li><a href="#aspect-on-aspect">Aspect-on-aspect</a></li>
            <li><a href="#attribute">Attribute</a></li>
            <li><a href="#bazelrc">.bazelrc</a></li>
            <li><a href="#blaze">Blaze</a></li>
            <li><a href="#build-file">BUILD File</a></li>
            <li><a href="#buildbazel-file">BUILD.bazel File</a></li>
            <li><a href="#bzl-file">.bzl File</a></li>
            <li><a href="#build-graph">Build graph</a></li>
            <li><a href="#build-setting">Build setting</a></li>
            <li><a href="#clean-build">Clean build</a></li>
            <li><a href="#client-server-model">Client-server model</a></li>
            <li><a href="#command">Command</a></li>
            <li><a href="#command-flags">Command flags</a></li>
            <li><a href="#configuration">Configuration</a></li>
            <li><a href="#configuration-trimming">Configuration trimming</a></li>
            <li><a href="#configured-query-cquery">Configured query (cquery)</a></li>
            <li><a href="#configured-target">Configured target</a></li>
            <li><a href="#correctness">Correctness</a></li>
            <li><a href="#dependency">Dependency</a></li>
            <li><a href="#depset">Depset</a></li>
            <li><a href="#disk-cache">Disk cache</a></li>
            <li><a href="#distdir">Distdir</a></li>
            <li><a href="#dynamic-execution">Dynamic execution</a></li>
            <li><a href="#execution-phase">Execution phase</a></li>
            <li><a href="#execution-root">Execution root</a></li>
            <li><a href="#file">File</a></li>
            <li><a href="#hermeticity">Hermeticity</a></li>
            <li><a href="#incremental-build">Incremental build</a></li>
            <li><a href="#label">Label</a></li>
            <li><a href="#loading-phase">Loading phase</a></li>
            <li><a href="#macro">Macro</a></li>
            <li><a href="#mnemonic">Mnemonic</a></li>
            <li><a href="#native-rules">Native rules</a></li>
            <li><a href="#output-base">Output base</a></li>
            <li><a href="#output-groups">Output groups</a></li>
            <li><a href="#output-user-root">Output user root</a></li>
            <li><a href="#package">Package</a></li>
            <li><a href="#package-group">Package group</a></li>
            <li><a href="#platform">Platform</a></li>
            <li><a href="#provider">Provider</a></li>
            <li><a href="#query-concept">Query (concept)</a></li>
            <li><a href="#repository-cache">Repository cache</a></li>
            <li><a href="#reproducibility">Reproducibility</a></li>
            <li><a href="#rule">Rule</a></li>
            <li><a href="#runfiles">Runfiles</a></li>
            <li><a href="#sandboxing">Sandboxing</a></li>
            <li><a href="#skyframe">Skyframe</a></li>
            <li><a href="#starlark">Starlark</a></li>
            <li><a href="#startup-flags">Startup flags</a></li>
            <li><a href="#target">Target</a></li>
            <li><a href="#target-graph">Target graph</a></li>
            <li><a href="#target-pattern">Target pattern</a></li>
            <li><a href="#tests">Tests</a></li>
            <li><a href="#toolchain">Toolchain</a></li>
            <li><a href="#transition">Transition</a></li>
            <li><a href="#tree-artifact">Tree artifact</a></li>
            <li><a href="#visibility">Visibility</a></li>
            <li><a href="#workspace">Workspace</a></li>
            <li><a href="#workspace-file">WORKSPACE file</a></li>
          </ul>
        </li>
        <li><a href="#2-核心基础概念">2 核心基础概念</a></li>
        <li><a href="#核心基础术语">核心基础术语</a>
          <ul>
            <li><a href="#label-1">LABEL</a></li>
            <li><a href="#build-文件">BUILD 文件</a></li>
            <li><a href="#dependencies">Dependencies</a></li>
            <li><a href="#visibility-1">Visibility</a></li>
            <li><a href="#sandbox">sandbox</a></li>
          </ul>
        </li>
        <li><a href="#3-实践-快速浏览bazel配置">3 实践 快速浏览Bazel配置</a></li>
        <li><a href="#4-bazel的输出布局">4 Bazel的输出布局</a></li>
        <li><a href="#输出布局">输出布局</a></li>
        <li><a href="#5-实践-grpc的bazel集成">5 实践 GRPC的Bazel集成</a>
          <ul>
            <li><a href="#创建workspace文件">创建WORKSPACE文件</a></li>
            <li><a href="#编写build文件和代码">编写BUILD文件和代码</a></li>
            <li><a href="#运行">运行</a></li>
          </ul>
        </li>
        <li><a href="#6-使用bazel管理c">6 使用Bazel管理C++</a>
          <ul>
            <li><a href="#c基础规则">C++基础规则</a></li>
            <li><a href="#c-集成入门">C++ 集成入门</a></li>
            <li></li>
            <li><a href="#c如何引用外部库">C++如何引用外部库</a></li>
          </ul>
        </li>
        <li><a href="#7-使用bazel管理python">7 使用Bazel管理Python</a>
          <ul>
            <li><a href="#python基础规则">Python基础规则</a></li>
          </ul>
        </li>
        <li><a href="#8-使用bazel管理go">8 使用Bazel管理Go</a>
          <ul>
            <li><a href="#golang规则简介">Golang规则简介</a></li>
            <li><a href="#实践bazel管理golang">实践：Bazel管理Golang</a></li>
          </ul>
        </li>
        <li><a href="#9-使用bazel管理shell">9 使用Bazel管理Shell</a></li>
        <li><a href="#10-引入第三方库">10 引入第三方库</a>
          <ul>
            <li><a href="#传统方法">传统方法</a></li>
            <li><a href="#bzlmod方法">bzlmod方法</a></li>
          </ul>
        </li>
        <li><a href="#原理分析">原理分析</a></li>
        <li><a href="#11-bazel代码管理最佳实践">11 Bazel代码管理最佳实践</a>
          <ul>
            <li><a href="#开放用户自定配置">开放用户自定配置</a></li>
            <li><a href="#尽量使用源码编译">尽量使用源码编译</a></li>
            <li><a href="#整个源码库可构建">整个源码库可构建</a></li>
            <li><a href="#尽量明确依赖而不是混杂依赖">尽量明确依赖而不是混杂依赖</a></li>
            <li><a href="#build文件不要跨级">BUILD文件不要跨级</a></li>
            <li><a href="#常用选项">常用选项</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#中级">中级</a>
      <ul>
        <li><a href="#12-bazel-platform与可配置项">12 Bazel Platform与可配置项</a>
          <ul>
            <li><a href="#可配置选项与select">可配置选项与select</a></li>
            <li><a href="#select的细节语法">select的细节语法</a></li>
          </ul>
        </li>
        <li>
          <ul>
            <li><a href="#platforms">Platforms</a></li>
            <li><a href="#bazel的platforms">Bazel的Platforms</a></li>
          </ul>
        </li>
        <li><a href="#13-bazel-query和aquery">13 Bazel Query和Aquery</a></li>
        <li><a href="#14-bazel集成clang-tidy">14 Bazel集成Clang-Tidy</a>
          <ul>
            <li><a href="#使用方法">使用方法</a></li>
          </ul>
        </li>
        <li><a href="#15-bazel集成lint">15 Bazel集成Lint</a></li>
        <li><a href="#16-bazel生成compile-database">16 Bazel生成Compile Database</a></li>
        <li></li>
        <li><a href="#17-bazel管理docker">17 Bazel管理Docker</a>
          <ul>
            <li><a href="#container_import">container_import</a></li>
            <li><a href="#编译deterministic的镜像">编译deterministic的镜像</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#高级篇">高级篇</a>
      <ul>
        <li><a href="#18-原理解释">18 原理解释</a>
          <ul>
            <li><a href="#概念解释">概念解释</a></li>
          </ul>
        </li>
        <li></li>
        <li><a href="#19-bazel自定义规则">19 Bazel自定义规则</a></li>
        <li><a href="#20-bazel工具链配置和使用">20 Bazel工具链配置和使用</a></li>
        <li><a href="#21-性能诊断">21 性能诊断</a>
          <ul>
            <li><a href="#默认profile文件">默认profile文件</a></li>
          </ul>
        </li>
        <li>
          <ul>
            <li><a href="#如何阅读profile文件">如何阅读profile文件</a></li>
            <li><a href="#阅读profile文件的关键指标">阅读Profile文件的关键指标</a></li>
            <li><a href="#怎么看profile文件">怎么看profile文件</a></li>
            <li><a href="#显示网络的使用情况">显示网络的使用情况</a></li>
          </ul>
        </li>
        <li><a href="#常见的profile问题点">常见的profile问题点</a></li>
        <li><a href="#阅读profile做文件诊断的例子">阅读profile做文件诊断的例子</a></li>
        <li></li>
        <li><a href="#22-性能优化">22 性能优化</a>
          <ul>
            <li><a href="#remote-execution">Remote Execution</a></li>
            <li><a href="#buildfarm配置">Buildfarm配置</a></li>
            <li><a href="#buildfarm生产用排雷">Buildfarm生产用排雷</a></li>
            <li><a href="#remote-cache">Remote Cache</a></li>
            <li><a href="#优化内存">优化内存</a></li>
          </ul>
        </li>
        <li><a href="#23-bazel集成code-coverage">23 Bazel集成Code Coverage</a></li>
      </ul>
    </li>
    <li><a href="#结尾">结尾</a></li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    目录
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么使用bazel">为什么使用Bazel</a>
      <ul>
        <li><a href="#why-bazel">Why Bazel</a></li>
      </ul>
    </li>
    <li><a href="#基础篇">基础篇</a>
      <ul>
        <li><a href="#1-bazel基础概念通识">1 Bazel基础概念通识</a>
          <ul>
            <li><a href="#action">Action</a></li>
            <li><a href="#action-cache">Action cache</a></li>
            <li><a href="#action-graph">Action graph</a></li>
            <li><a href="#action-graph-query-aquery">Action graph query (aquery)</a></li>
            <li><a href="#action-key">Action key</a></li>
            <li><a href="#analysis-phase">Analysis phase</a></li>
            <li><a href="#artifact">Artifact</a></li>
            <li><a href="#aspect">Aspect</a></li>
            <li><a href="#aspect-on-aspect">Aspect-on-aspect</a></li>
            <li><a href="#attribute">Attribute</a></li>
            <li><a href="#bazelrc">.bazelrc</a></li>
            <li><a href="#blaze">Blaze</a></li>
            <li><a href="#build-file">BUILD File</a></li>
            <li><a href="#buildbazel-file">BUILD.bazel File</a></li>
            <li><a href="#bzl-file">.bzl File</a></li>
            <li><a href="#build-graph">Build graph</a></li>
            <li><a href="#build-setting">Build setting</a></li>
            <li><a href="#clean-build">Clean build</a></li>
            <li><a href="#client-server-model">Client-server model</a></li>
            <li><a href="#command">Command</a></li>
            <li><a href="#command-flags">Command flags</a></li>
            <li><a href="#configuration">Configuration</a></li>
            <li><a href="#configuration-trimming">Configuration trimming</a></li>
            <li><a href="#configured-query-cquery">Configured query (cquery)</a></li>
            <li><a href="#configured-target">Configured target</a></li>
            <li><a href="#correctness">Correctness</a></li>
            <li><a href="#dependency">Dependency</a></li>
            <li><a href="#depset">Depset</a></li>
            <li><a href="#disk-cache">Disk cache</a></li>
            <li><a href="#distdir">Distdir</a></li>
            <li><a href="#dynamic-execution">Dynamic execution</a></li>
            <li><a href="#execution-phase">Execution phase</a></li>
            <li><a href="#execution-root">Execution root</a></li>
            <li><a href="#file">File</a></li>
            <li><a href="#hermeticity">Hermeticity</a></li>
            <li><a href="#incremental-build">Incremental build</a></li>
            <li><a href="#label">Label</a></li>
            <li><a href="#loading-phase">Loading phase</a></li>
            <li><a href="#macro">Macro</a></li>
            <li><a href="#mnemonic">Mnemonic</a></li>
            <li><a href="#native-rules">Native rules</a></li>
            <li><a href="#output-base">Output base</a></li>
            <li><a href="#output-groups">Output groups</a></li>
            <li><a href="#output-user-root">Output user root</a></li>
            <li><a href="#package">Package</a></li>
            <li><a href="#package-group">Package group</a></li>
            <li><a href="#platform">Platform</a></li>
            <li><a href="#provider">Provider</a></li>
            <li><a href="#query-concept">Query (concept)</a></li>
            <li><a href="#repository-cache">Repository cache</a></li>
            <li><a href="#reproducibility">Reproducibility</a></li>
            <li><a href="#rule">Rule</a></li>
            <li><a href="#runfiles">Runfiles</a></li>
            <li><a href="#sandboxing">Sandboxing</a></li>
            <li><a href="#skyframe">Skyframe</a></li>
            <li><a href="#starlark">Starlark</a></li>
            <li><a href="#startup-flags">Startup flags</a></li>
            <li><a href="#target">Target</a></li>
            <li><a href="#target-graph">Target graph</a></li>
            <li><a href="#target-pattern">Target pattern</a></li>
            <li><a href="#tests">Tests</a></li>
            <li><a href="#toolchain">Toolchain</a></li>
            <li><a href="#transition">Transition</a></li>
            <li><a href="#tree-artifact">Tree artifact</a></li>
            <li><a href="#visibility">Visibility</a></li>
            <li><a href="#workspace">Workspace</a></li>
            <li><a href="#workspace-file">WORKSPACE file</a></li>
          </ul>
        </li>
        <li><a href="#2-核心基础概念">2 核心基础概念</a></li>
        <li><a href="#核心基础术语">核心基础术语</a>
          <ul>
            <li><a href="#label-1">LABEL</a></li>
            <li><a href="#build-文件">BUILD 文件</a></li>
            <li><a href="#dependencies">Dependencies</a></li>
            <li><a href="#visibility-1">Visibility</a></li>
            <li><a href="#sandbox">sandbox</a></li>
          </ul>
        </li>
        <li><a href="#3-实践-快速浏览bazel配置">3 实践 快速浏览Bazel配置</a></li>
        <li><a href="#4-bazel的输出布局">4 Bazel的输出布局</a></li>
        <li><a href="#输出布局">输出布局</a></li>
        <li><a href="#5-实践-grpc的bazel集成">5 实践 GRPC的Bazel集成</a>
          <ul>
            <li><a href="#创建workspace文件">创建WORKSPACE文件</a></li>
            <li><a href="#编写build文件和代码">编写BUILD文件和代码</a></li>
            <li><a href="#运行">运行</a></li>
          </ul>
        </li>
        <li><a href="#6-使用bazel管理c">6 使用Bazel管理C++</a>
          <ul>
            <li><a href="#c基础规则">C++基础规则</a></li>
            <li><a href="#c-集成入门">C++ 集成入门</a></li>
            <li></li>
            <li><a href="#c如何引用外部库">C++如何引用外部库</a></li>
          </ul>
        </li>
        <li><a href="#7-使用bazel管理python">7 使用Bazel管理Python</a>
          <ul>
            <li><a href="#python基础规则">Python基础规则</a></li>
          </ul>
        </li>
        <li><a href="#8-使用bazel管理go">8 使用Bazel管理Go</a>
          <ul>
            <li><a href="#golang规则简介">Golang规则简介</a></li>
            <li><a href="#实践bazel管理golang">实践：Bazel管理Golang</a></li>
          </ul>
        </li>
        <li><a href="#9-使用bazel管理shell">9 使用Bazel管理Shell</a></li>
        <li><a href="#10-引入第三方库">10 引入第三方库</a>
          <ul>
            <li><a href="#传统方法">传统方法</a></li>
            <li><a href="#bzlmod方法">bzlmod方法</a></li>
          </ul>
        </li>
        <li><a href="#原理分析">原理分析</a></li>
        <li><a href="#11-bazel代码管理最佳实践">11 Bazel代码管理最佳实践</a>
          <ul>
            <li><a href="#开放用户自定配置">开放用户自定配置</a></li>
            <li><a href="#尽量使用源码编译">尽量使用源码编译</a></li>
            <li><a href="#整个源码库可构建">整个源码库可构建</a></li>
            <li><a href="#尽量明确依赖而不是混杂依赖">尽量明确依赖而不是混杂依赖</a></li>
            <li><a href="#build文件不要跨级">BUILD文件不要跨级</a></li>
            <li><a href="#常用选项">常用选项</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#中级">中级</a>
      <ul>
        <li><a href="#12-bazel-platform与可配置项">12 Bazel Platform与可配置项</a>
          <ul>
            <li><a href="#可配置选项与select">可配置选项与select</a></li>
            <li><a href="#select的细节语法">select的细节语法</a></li>
          </ul>
        </li>
        <li>
          <ul>
            <li><a href="#platforms">Platforms</a></li>
            <li><a href="#bazel的platforms">Bazel的Platforms</a></li>
          </ul>
        </li>
        <li><a href="#13-bazel-query和aquery">13 Bazel Query和Aquery</a></li>
        <li><a href="#14-bazel集成clang-tidy">14 Bazel集成Clang-Tidy</a>
          <ul>
            <li><a href="#使用方法">使用方法</a></li>
          </ul>
        </li>
        <li><a href="#15-bazel集成lint">15 Bazel集成Lint</a></li>
        <li><a href="#16-bazel生成compile-database">16 Bazel生成Compile Database</a></li>
        <li></li>
        <li><a href="#17-bazel管理docker">17 Bazel管理Docker</a>
          <ul>
            <li><a href="#container_import">container_import</a></li>
            <li><a href="#编译deterministic的镜像">编译deterministic的镜像</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#高级篇">高级篇</a>
      <ul>
        <li><a href="#18-原理解释">18 原理解释</a>
          <ul>
            <li><a href="#概念解释">概念解释</a></li>
          </ul>
        </li>
        <li></li>
        <li><a href="#19-bazel自定义规则">19 Bazel自定义规则</a></li>
        <li><a href="#20-bazel工具链配置和使用">20 Bazel工具链配置和使用</a></li>
        <li><a href="#21-性能诊断">21 性能诊断</a>
          <ul>
            <li><a href="#默认profile文件">默认profile文件</a></li>
          </ul>
        </li>
        <li>
          <ul>
            <li><a href="#如何阅读profile文件">如何阅读profile文件</a></li>
            <li><a href="#阅读profile文件的关键指标">阅读Profile文件的关键指标</a></li>
            <li><a href="#怎么看profile文件">怎么看profile文件</a></li>
            <li><a href="#显示网络的使用情况">显示网络的使用情况</a></li>
          </ul>
        </li>
        <li><a href="#常见的profile问题点">常见的profile问题点</a></li>
        <li><a href="#阅读profile做文件诊断的例子">阅读profile做文件诊断的例子</a></li>
        <li></li>
        <li><a href="#22-性能优化">22 性能优化</a>
          <ul>
            <li><a href="#remote-execution">Remote Execution</a></li>
            <li><a href="#buildfarm配置">Buildfarm配置</a></li>
            <li><a href="#buildfarm生产用排雷">Buildfarm生产用排雷</a></li>
            <li><a href="#remote-cache">Remote Cache</a></li>
            <li><a href="#优化内存">优化内存</a></li>
          </ul>
        </li>
        <li><a href="#23-bazel集成code-coverage">23 Bazel集成Code Coverage</a></li>
      </ul>
    </li>
    <li><a href="#结尾">结尾</a></li>
  </ul>
</nav>
  </div>
</details>

<script>

  var margin = 200;
  var marginError = 50;

  (function () {
    var $window = $(window);
    var $toc = $('#TOCView');
    var tocHeight = $toc.height();

    function onResize() {
      var windowAndMarginHeight = $window.height() - margin;
      if(tocHeight >= windowAndMarginHeight) {
        $toc.css("overflow-y", "scroll")
        $toc.css("max-height", (windowAndMarginHeight + marginError) + "px")
      } else {
        $toc.css("overflow-y", "hidden")
        $toc.css("max-height", "9999999px")
      }
    }

    $window.on('resize', onResize);
    $(document).ready(onResize);
  })();



</script>
   </div>
      </div>
      

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          

<h1 class="relative group">bazel从入门到中级 
    <div id="bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7" aria-label="锚点">#</a>
    </span>        
    
</h1>
<p>这个本来是写在gitbook上的内容，发现编辑起来很费劲，就写到了博客。因为历史比较久，所以可能有一些地方有些陈旧，我会后面逐渐更新。</p>
<p>另外，一些具体名词我不会翻译为中文，因为英文更明确，避免二义性。但是其意义我会用中文表达，从而方便理解。下面的内容可能有点多，可以先大致浏览理解概念，以后再回来细看。</p>


<h2 class="relative group">为什么使用Bazel 
    <div id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8bazel" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8bazel" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>有些人喜欢争辩Cmake比Bazel如何如何好，如何如何兼容，我承认Cmake的历史更久远，用的人更多，但是Bazel的设计理念个人认为是更先进或者说更明确化：让专业的人做专业的事情，拆分代码编写工程师和鸡架工程师（哈）。</p>
<p>因此，使用Bazel的人，我建议先阅读https://bazel.build/basics中的这篇文章https://bazel.build/basics/artifact-based-builds，展示了bazel背后的设计理念，理解了bazel背后的设计理念，对于增量编译，可复现性等概念就会有本质的理解。</p>
<p>如果偷懒的话，可以不看原本内容，直接看下面我总结的对比</p>


<h3 class="relative group">Why Bazel 
    <div id="why-bazel" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#why-bazel" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>Bazel是一种比较先进的构建平台，提供了多种便利:</p>
<ul>
<li><strong>支持高级构建语言</strong>. Bazel自身使用一种抽象的、易读的语言，在高语义级别上描述项目的构建属性。与其他工具不同，Bazel基于库、二进制文件、脚本和数据集的概念进行操作，使您免于编写诸如编译器和链接器等工具的单独调用的复杂性。</li>
<li><strong>bazel高效且可靠.</strong> Bazel缓存了所有先前完成的工作，并跟踪文件内容和构建命令的更改。这样，Bazel就知道何时需要重新构建，并仅重新构建需要的部分。可以设置项目以高度并行和增量的方式构建，从而进一步加快构建速度</li>
<li><strong>bazel本身支持多平台</strong>. Bazel可以在Linux、macOS和Windows上运行。Bazel可以为多个平台构建二进制文件和可部署包，包括桌面、服务器和移动设备，而这些构建可以来自同一个项目。</li>
<li><strong>bazel可以应对不同的构建规模.</strong> 无论是针对多个代码仓库还是处理成千上万个用户基础，Bazel都能够应对，并保持其灵活性和高效性。它通过并行化和增量构建的策略来实现高效的构建过程，并且能够有效地管理大型项目的构建需求。</li>
<li><strong>bazel是可拓展的.</strong> 它支持许多编程语言，并且您可以扩展Bazel以支持任何其他语言或框架。</li>
</ul>
<p>一部分人认为，相比bazel，Cmake不是更成熟吗？恰恰相反，我个人认为，成熟，只是随大流的一种说法而言，Cmake实际上是在没有工具使用，只能找一种解决问题的方法的情况下选择的工具。它为了解决一个问题，而引入了更多的问题，最终把自己复杂化，有点类似早期的python。</p>
<p>而Bazel设计明确，理念清楚，这种为了解决特定的问题而做的实践，总是比乱七八糟的凑到一起解决某些不确定的问题要方便很多，其开发愿景就是为了</p>
<ul>
<li>**保证工程师聚焦于代码开发。**软件开发人员可以专注于编写代码的创造性过程，因为构建和测试的过程已经native 支持，即使是想编辑语言相关的工具链，也有相对应一整套机制方便拓展</li>
<li><strong>工程师可以无视本地环境的影响</strong>。环境是“可移动”的，简单来说工程师不用再被一堆莫名其妙的环境配置工作所耽误。</li>
<li><strong>项目可以扩展到任何规模的代码库、任何规模的团队</strong>。bazel原生支持的增量测试使团队能够在提交之前充分验证每个更改。无论是增加多语言支持，异或跨平台编译，或者引入更多的代码数量，都不会造成breaking级别的编译灾难（当然，不能有效控制代码的量级，这也是工程人员的失误）</li>
</ul>
<p>综上，对于软件工程而言，保证开发效率并不是只是说“研发想怎么写，就瞎tm怎么写”，而是如何降低在多人参与开发，且能力不同的情况下所带来的复杂度和依赖复杂度。相比于Cmake的拓展支持，Bazel的原生支持，提供了一种有效的切入点。</p>
<p>综上，我认为bazel是一种目前比较先进的编译方向，当然除了bazel还有please build之类的东西，只不过，我实践bazel比较久。。。
末尾是Bazel和Cmake的优势对比。</p>
<table>
  <thead>
      <tr>
          <th>Bazel</th>
          <th>Cmake</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Remote Cache/Execution</td>
          <td>CMake没有内置支持增量编译和分布式编译，但是CMake对增量编译工具ccache/sccache和分布式编译工具distcc/icecc支持良好</td>
      </tr>
      <tr>
          <td>Deterministic build</td>
          <td>灵活性更高，用户可在CMakeLists中调用其他command(shell, built-in commands等)实现自定义功能。</td>
      </tr>
      <tr>
          <td>使用较难，但是依赖分析，使用方式非常清楚</td>
          <td>简单，易于修改和维护</td>
      </tr>
  </tbody>
</table>
<p>如果想了解更多，阅读https://bazel.build/basics</p>


<h2 class="relative group">基础篇 
    <div id="%E5%9F%BA%E7%A1%80%E7%AF%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E7%A1%80%E7%AF%87" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>这一部分主要面向bazel体系的用户。希望读者能够明白</p>
<ul>
<li>
<p>Bazel是构建平台，不能简单地理解为编译平台，错误理解这一点会导致无法快速找到对应的解决方案。有个用户曾经抱怨：bazel编译报错，而g++编译同样代码不报错，仔细一看报错如下图，这个是非常明显的bazel的工具链启用-Werror和-Wuninitialized选项导致的结果，如果g++启用同样的选项，也会报错。</p>
<p>
    <figure>
      <img
        class="my-0 rounded-md"
        loading="lazy"
        srcset="
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/bazel_warning_as_error_hu_8e796b6c8c25d17a.png 330w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/bazel_warning_as_error_hu_3778f67bed760bfd.png 660w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/bazel_warning_as_error_hu_9d3a34b1f167bb69.png 1024w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/bazel_warning_as_error_hu_a92401e4c78d00d6.png 2x"
        data-zoom-src="/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/bazel_warning_as_error_hu_a92401e4c78d00d6.png"
        src="/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/bazel_warning_as_error_hu_3778f67bed760bfd.png"
        alt="image-20240603160009244"
      />
      
    </figure>
</p>
</li>
<li>
<p>Bazel提供的是一种抽象的package，target，库依赖的关系，具体如何构建这些target和package，是对应的bazel rule的实现范畴。具体构建的细节，麻烦用户自己去看工具链的配置。</p>
</li>
<li>
<p>Bazel的执行模式有多种：sandbox模式，本地模式等。因此使用sandbox模式的时候，本地临时文件如果不明确地指定到BUILD文件中，就无法在构建过程中看到（调用到）</p>
</li>
</ul>
<p>这部分我建议读者先把C++那部分的例子看了，再根据需求选择使用的语言，选择对应的阅读章节。</p>


<h3 class="relative group">1 Bazel基础概念通识 
    <div id="1-bazel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E9%80%9A%E8%AF%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1-bazel%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E9%80%9A%E8%AF%86" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>这部分会给出Bazel的设计理念，基础概念和输出布局。Bazel体系的用户在交流的时候需要有明确的名词来统一上下文，我看到很多次研发在别人给出具体的开发建议的时候，不知道怎么写BUILD的情况。因此，确定基础术语的概念会很有用。我建议阅读者重点看这部分，这部分搞明白，bazel的基本用法就不会有问题了。</p>
<p>在执行构建或者test任务的时候，bazel可以拆分为一下几个流程:</p>
<ol>
<li><strong>Loads</strong> 加载BUILD文件，并且将外部依赖</li>
<li><strong>Analyzes</strong> 分析输入和输出的依赖，在内存中生成对应的action图.</li>
<li><strong>Executes</strong> 执行真正的构建操作并输出相应的文件和日志</li>
</ol>
<p>下面给出一些术语，方便统一上下文：</p>


<h4 class="relative group">Action 
    <div id="action" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#action" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>执行构建过程的命令，比方说将一个完整的调用过程，改过程将其它Action的产物作为输入，并产生对应的其它编译产物。需要包含包括命令行参数、action索引（action key）、环境变量和在BUILD中声明的输入/输出工件等元数据</p>
<p><strong>参考</strong> <a href="https://bazel.build/extending/rules#actions" target="_blank">Rules documentation</a></p>


<h4 class="relative group">Action cache 
    <div id="action-cache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#action-cache" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>磁盘上的缓存，存储执行的<a href="https://bazel.build/reference/glossary#action" target="_blank">操作</a>到它们创建的输出的映射。缓存键称为action索引(action key)。Bazel 增量模型的核心组件。缓存存储在输出根目录（output base directory）中，因为是文件形式存储，所以在 Bazel 服务器重新启动后仍然存在。</p>


<h4 class="relative group">Action graph 
    <div id="action-graph" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#action-graph" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>内存中的action关系图，表明action和具体的action读取和生成的产物<a href="https://bazel.build/reference/glossary#artifact" target="_blank">。</a>该图读取<code>BUILD</code>。生成，从本质来说是一种依赖/生成关系的具象化。该图<a href="https://bazel.build/reference/glossary#analysis-phase" target="_blank">在分析阶段</a>产生并在<a href="https://bazel.build/reference/glossary#execution-phase" target="_blank">执行阶段</a>使用。目前还不需要了解分析阶段，执行阶段的作用是什么</p>


<h4 class="relative group">Action graph query (aquery) 
    <div id="action-graph-query-aquery" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#action-graph-query-aquery" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一个<a href="https://bazel.build/reference/glossary#query-concept" target="_blank">查询</a>工具，可以查询action的依赖关系等。用户就可以了解从具体的规则，到转化为实际构建工作的过程是如何的。</p>


<h4 class="relative group">Action key 
    <div id="action-key" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#action-key" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>action的缓存索引。根据action元数据计算得出，其中可能包括要在操作中执行的命令、编译器标志、库位置或系统头文件，具体取决于action的实现。从而使 Bazel 能够确定性地缓存或使单个action无效。</p>


<h4 class="relative group">Analysis phase 
    <div id="analysis-phase" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#analysis-phase" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>构建的第二阶段。处理BUILD<a href="https://bazel.build/reference/glossary#build-file" target="_blank">文件</a> 中指定的target之间的关系，并根据该<a href="https://bazel.build/reference/glossary#target-graph" target="_blank">目标图</a>以生成内存中action graph。当前阶段是规则的实现被真正的解析的阶段。</p>


<h4 class="relative group">Artifact 
    <div id="artifact" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#artifact" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>成品，指的是源文件或者代指生成的文件。也可以是文件目录，称为 <a href="https://bazel.build/reference/glossary#tree-artifact" target="_blank">tree artifacts</a></p>
<p>成品可以作为多个action的输入，参与到构建中，但最多只能由一个操作生成。</p>
<p>与<a href="https://bazel.build/reference/glossary#target" target="_blank">文件目标</a>相对应的成品可以通过label来寻址。</p>


<h4 class="relative group">Aspect 
    <div id="aspect" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#aspect" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一种在现有rule的基础上拓展以执行更多action的机制，这种机制会传递到具体规则的依赖上，对于初级用户用不到，不过bazel-clang-tidy是用这个实现的。如果目标 A 依赖于 B，则可以在 A 上应用一个aspect，该aspect向上遍历到B中，并在 B 中运行其他action来生成和收集其他输出文件。这些附加操作同样被缓存并在重用。</p>
<p>参考**:** <a href="https://bazel.build/extending/aspects" target="_blank">Aspects documentation</a></p>


<h4 class="relative group">Aspect-on-aspect 
    <div id="aspect-on-aspect" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#aspect-on-aspect" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>A composition mechanism whereby aspects can be applied to the results of other aspects. For example, an aspect that generates information for use by IDEs can be applied on top of an aspect that generates <code>.java</code> files from a proto.</p>
<p>For an aspect <code>A</code> to apply on top of aspect <code>B</code>, the <a href="https://bazel.build/reference/glossary#provider" target="_blank">providers</a> that <code>B</code> advertises in its <a href="https://bazel.build/rules/lib/globals#aspect.provides" target="_blank"><code>provides</code></a> attribute must match what <code>A</code> declares it wants in its <a href="https://bazel.build/rules/lib/globals#aspect.required_aspect_providers" target="_blank"><code>required_aspect_providers</code></a> attribute.</p>


<h4 class="relative group">Attribute 
    <div id="attribute" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#attribute" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p><a href="https://bazel.build/reference/glossary#rule" target="_blank">rule</a>的属性，用于表达每个目标的构建信息。例如，srcs（源文件）、deps（依赖项）和copts（自定义编译选项）分别声明了目标的源文件、依赖项和自定义编译选项。对于特定目标而言，可用的属性取决于其规则类型。</p>


<h4 class="relative group">.bazelrc 
    <div id="bazelrc" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bazelrc" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>Bazel的配置文件用于更改启动标志和命令标志的默认值，并定义常见选项组，可以使用&ndash;config标志在Bazel命令行上一起设置。Bazel可以从多个bazelrc文件（系统范围、工作空间范围、用户范围或自定义位置）中组合设置，而bazelrc文件也可以从其他bazelrc文件导入设置。</p>


<h4 class="relative group">Blaze 
    <div id="blaze" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#blaze" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>google内部的编译构建系统，说实在的，google的infra真是令人羡慕呀</p>


<h4 class="relative group">BUILD File 
    <div id="build-file" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#build-file" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>BUILD文件是Bazel的主要配置文件，用于告诉Bazel要构建哪些软件输出，它们的依赖关系是什么，以及如何构建它们。Bazel将BUILD文件作为输入，并使用该文件创建依赖图，并推导出构建中间和最终软件输出所必须完成的操作。BUILD文件将目录以及不包含BUILD文件的任何子目录标记为一个包（package），并且可以包含由规则创建的目标（targets）。该文件也可以被命名为BUILD.bazel。</p>


<h4 class="relative group">BUILD.bazel File 
    <div id="buildbazel-file" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#buildbazel-file" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>参考 <a href="https://bazel.build/reference/glossary#build-file" target="_blank"><code>BUILD</code> File</a>.优先级高于同目录的BUILD</p>


<h4 class="relative group">.bzl File 
    <div id="bzl-file" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bzl-file" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一个文件，用Starlark语言编写，用于定义规则（rules）、宏（macros）和常量（constants）。然后可以使用load()函数将其导入到BUILD文件中。实际上后面看什么bazel管理C++，bazel管理GO就能看到类似的load使用方法。</p>


<h4 class="relative group">Build graph 
    <div id="build-graph" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#build-graph" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>Bazel构建过程中构建和遍历的依赖图。包括目标（targets）、配置后的目标（configured targets）、操作（actions）和构件（artifacts）等节点。当所有被请求的目标所依赖的构件都被验证为最新时，构建被视为完成。</p>


<h4 class="relative group">Build setting 
    <div id="build-setting" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#build-setting" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一个由Starlark定义的部分配置。transitions（配置传递）可以设置构建设置以更改子图的配置。对用户而言，这个可以理解为一种编译配置，比方说&ndash;config=cpu</p>


<h4 class="relative group">Clean build 
    <div id="clean-build" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#clean-build" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一个不使用之前构建结果的构建过程。这通常比增量构建更慢，但通常被认为更正确。保证无论是清理构建（clean build）还是增量构建（incremental build），都始终是正确的是Bazel的功能，不过确定性这点bazel在极低情况下确实会出问题，我明确遇到过在aliyun的内部pod下载的外部依赖版本不正确的问题，最后是通过指定url的下载地址避免这个问题。</p>


<h4 class="relative group">Client-server model 
    <div id="client-server-model" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#client-server-model" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>bazel会自动在本地机器上启动一个后台服务器来执行Bazel命令。该服务器在命令之间保持持续存在，但在一段时间的无活动后（或通过bazel shutdown显式停止）会自动关闭。将Bazel拆分为服务器和客户端有助于分摊JVM启动时间，并支持更快的增量构建，因为操作图在命令之间保留在内存中。说白了，分离控制端和策略端</p>


<h4 class="relative group">Command 
    <div id="command" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#command" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>简单理解就是Bazel的子函数，例如bazel build、bazel test、bazel run和bazel query。</p>


<h4 class="relative group">Command flags 
    <div id="command-flags" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#command-flags" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一组影响相关命令的标志（flags）。先指定具体命令，再指定flag（例如：先bazel build，然后在&ndash;keep going啥的 ）。这些标志可以适用于一个或多个命令。例如，&ndash;configure是仅用于bazel sync命令的标志，而&ndash;keep_going适用于sync、build、test等多个命令。command flag通常用于配置目的，因此command flag的更改可能会导致Bazel内存中存储的action graph无效，并重新启动分析阶段。</p>


<h4 class="relative group">Configuration 
    <div id="configuration" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#configuration" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>配置，rule定义之外的信息，会影响rule生成action的方式。每个build都至少有一个配置，用于指定目标平台、操作环境变量和命令行选项。 <a href="https://bazel.build/reference/glossary#transition" target="_blank">Transitions</a>可能会创建额外的配置，例如用于指定主机的工具链或交叉编译。</p>
<p>参考**:** <a href="https://bazel.build/extending/rules#configurations" target="_blank">Configurations</a></p>


<h4 class="relative group">Configuration trimming 
    <div id="configuration-trimming" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#configuration-trimming" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>配置建材，简单来说就是只包含目标实际需要的配置的过程。例如，如果你使用C++依赖项//:c构建Java二进制文件//:j，在//:c的配置中包含&ndash;javacopt的值是不必要的，因为更改&ndash;javacopt会不必要地破坏C++构建的缓存性能。因此，按需配置确保每个目标仅包含其自身所需的配置信息，以避免不必要的配置冗余和影响构建缓存性能。</p>


<h4 class="relative group">Configured query (cquery) 
    <div id="configured-query-cquery" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#configured-query-cquery" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>检索启用了配置之后的 <a href="https://bazel.build/reference/glossary#configured-target" target="_blank">configured targets</a>的检索工具，<code>select()</code> and <a href="https://bazel.build/reference/glossary#command-flags" target="_blank">build flags</a> (such as <code>--platforms</code>)的选择是已经明确化了。这个在<a href="https://bazel.build/reference/glossary#analysis-phase" target="_blank">analysis phase</a>之后才执行</p>
<p>参考**:** <a href="https://bazel.build/query/cquery" target="_blank">cquery documentation</a></p>


<h4 class="relative group">Configured target 
    <div id="configured-target" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#configured-target" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>启用了某种配置的target</p>


<h4 class="relative group">Correctness 
    <div id="correctness" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#correctness" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当构建的输出忠实地反映其传递输入的状态时，构建就是正确的。为了实现正确的构建，Bazel努力做到具有隔离性、可重现性，并使构建分析和操作执行具有确定性。这意味着在构建过程中，Bazel会尽力确保每次构建都以一致的方式处理输入，从而产生可预测和可重复的结果。这样可以确保构建的正确性，并减少不确定性带来的问题。</p>
<p>不过这个概念对用户一般来说没啥用，毕竟正确性大部分永不不会涉及到，很多时候问题也不是bazel的问题。</p>


<h4 class="relative group">Dependency 
    <div id="dependency" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#dependency" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>依赖关系，一般是指两个target直接的依赖关系，就是BUILD文件里面规则的deps</p>


<h4 class="relative group">Depset 
    <div id="depset" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#depset" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一种用于收集传递依赖关系数据的数据结构。它经过优化，使得合并依赖集（depset）在时间和空间上更加高效，因为依赖集往往非常大（成千上万个文件）。为了节省空间，该数据结构被实现为可以递归引用其他依赖集。规则实现在不是构建图顶层的情况下，不应将依赖集“展开”为列表形式。展开大型依赖集会导致巨大的内存消耗。在Bazel的内部实现中，它也被称为嵌套集合（nested sets）</p>
<p><strong>参考:</strong> <a href="https://bazel.build/extending/depsets" target="_blank">Depset documentation</a></p>


<h4 class="relative group">Disk cache 
    <div id="disk-cache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#disk-cache" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>本地磁盘的Blob存储用于远程缓存功能。它可以与实际的远程Blob存储结合使用。在构建过程中，Bazel会将构建输出结果转换为Blob，并将其存储在本地磁盘的Blob存储中。这样可以提高后续构建的速度，因为它可以避免重复构建相同的输出结果。实际的远程Blob存储通常用于分布式构建环境，可以将Blob存储在远程服务器上，以便多个构建节点共享和访问这些Blob。</p>


<h4 class="relative group">Distdir 
    <div id="distdir" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#distdir" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>只读目录，包含了Bazel本来会通过代码库规则从互联网获取的文件。它使得构建可以完全离线运行，不需要依赖于网络资源。通过将这些文件预先存储在只读目录中，Bazel可以在没有网络连接的情况下执行构建过程，并使用本地文件来满足构建所需的依赖。这种方式对于处于隔离环境或无法访问互联网的构建系统非常有用。不过说起来，distdir对于我的实践过程而言，最重要的还是提供对第三方依赖的缓存</p>


<h4 class="relative group">Dynamic execution 
    <div id="dynamic-execution" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#dynamic-execution" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>动态执行策略是根据各种启发式规则，在本地和远程执行之间进行选择，并使用更快速成功的方法的执行结果。某些操作在本地执行速度更快（例如链接操作），而其他操作在远程执行速度更快（例如高度可并行化的编译操作）。动态执行策略可以提供最佳的增量构建和清理构建时间。通过动态地选择本地或远程执行，Bazel可以根据操作类型和执行环境的特点，最大程度地优化构建过程，从而获得更快的构建时间。</p>


<h4 class="relative group">Execution phase 
    <div id="execution-phase" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#execution-phase" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>构建的第三个阶段，执行在分析阶段创建的操作图中的操作。这些操作调用可执行文件（编译器、脚本）来读取和写入构件。生成策略控制这些操作的执行方式：本地执行、远程执行、动态执行、沙盒化执行、使用Docker等等。</p>
<p>注意，具体执行的环境很多时候都是用户显示指定，其中配置的传递是个很蛋疼的东西，因为很多本地的配置是不能在sandbox环境完全一致的。</p>


<h4 class="relative group">Execution root 
    <div id="execution-root" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#execution-root" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>执行根目录（Execution Root）是workspace的输出目录中的一个目录，这里的action是在在非沙盒的环境中执行。该目录的内容主要放的是各种输入产物的hard link。执行根目录还包含指向外部依赖的符号软链接作为输入，以及用于存储输出的bazel-out目录。</p>
<p>在加载阶段通过创建大量符号软链接的方式来生成该根目录。可以通过在命令行中使用&quot;bazel info execution_root&quot;来访问该目录。</p>
<p>实际上，在buildfarm里面这个execution root的概念比较常用，因为有大量的分发的执行任务。</p>


<h4 class="relative group">File 
    <div id="file" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#file" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>参考 <a href="https://bazel.build/reference/glossary#artifact" target="_blank">Artifact</a>.</p>


<h4 class="relative group">Hermeticity 
    <div id="hermeticity" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hermeticity" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>如果构建和测试操作没有外部影响，那么构建就是隔离的（hermetic），这有助于确保结果具有确定性和正确性。例如，隔离的构建通常禁止操作访问网络，限制对声明的输入的访问，使用固定的时间戳和时区，限制对环境变量的访问，并为随机数生成器使用固定的种子。</p>
<p>通过确保构建过程中没有外部的不可控因素干扰，隔离的构建可以消除构建结果的不确定性，并提高构建的可靠性和可重复性。这样可以更容易地定位和解决构建中的问题，并确保不同环境下的构建结果一致，从而提高构建的可移植性和可靠性。</p>


<h4 class="relative group">Incremental build 
    <div id="incremental-build" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#incremental-build" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>我一般叫做，增量编译。更标准应该是增量构建。增量构建是通过重复使用先前构建的结果来减少构建时间和资源使用的一种方式。依赖检查和缓存旨在为此类型的构建生成正确的结果。增量构建是清理构建的反义词。</p>
<p>在增量构建中，Bazel会检查先前构建生成的构件，并根据构建过程中的依赖关系来确定哪些构件是最新的和有效的。只有在需要更新的构件上才会执行必要的操作，从而避免不必要的重新构建。这种方式可以显著减少构建时间，提高开发效率，并降低资源消耗。</p>


<h4 class="relative group">Label 
    <div id="label" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#label" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>标签（label）是用于唯一标识Bazel构建系统中的目标的方式。通过标签，可以准确定位和引用构建过程中所涉及的不同目标。标签的结构使得能够精确指定目标所在的位置，并指定目标的名称。这种标识符的使用使得Bazel可以在构建和依赖管理过程中准确地追踪和处理不同的目标</p>
<p>完全限定的标签（fully-qualified label），例如//path/to/package:target，由以下部分组成：//用于标记工作空间的根目录，path/to/package表示包含声明该目标的BUILD文件的目录，:target表示在前述BUILD文件中声明的目标的名称。也可以在前面添加@my_repository//&lt;..&gt;，表示该目标在名为my_repository的外部依赖代码库中声明。</p>


<h4 class="relative group">Loading phase 
    <div id="loading-phase" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#loading-phase" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>构建的第一阶段，Bazel在此阶段解析WORKSPACE、BUILD和.bzl文件，创建包（packages）。在此阶段，还会评估宏（macros）和某些函数，如glob()。该阶段与构建的第二阶段，即分析阶段，交替进行，以建立目标图（target graph）。</p>
<p>在加载阶段，Bazel会解析工作空间（WORKSPACE）文件，确定项目的配置和依赖关系。同时，它会解析BUILD文件和.bzl文件，创建和配置目标（targets）。宏和函数的评估也在此阶段进行，这有助于在构建过程中执行各种动态操作。加载阶段与分析阶段交替进行，以逐步构建目标图，为后续的构建阶段做好准备。</p>


<h4 class="relative group">Macro 
    <div id="macro" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#macro" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>这个机制允许开发者将多个规则目标的声明逻辑封装在一个自定义的Starlark函数中，以提高代码的可重用性和可维护性。通过定义这样的函数，可以在多个BUILD文件中调用该函数来创建相同的规则目标，从而避免了重复编写相似的规则声明代码。在加载阶段，Bazel会将这些组合规则函数展开为实际的规则目标声明，以便后续的构建阶段使用。这种机制使得规则声明的复用变得更加方便和灵活。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/extending/macros" target="_blank">Macro documentation</a></p>


<h4 class="relative group">Mnemonic 
    <div id="mnemonic" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#mnemonic" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>通过使用助记符，规则作者可以为规则中的操作赋予具有描述性和易记性的名称，使其更容易理解和识别。助记符通常与特定的操作类型或规则相关联，帮助开发者快速了解操作的用途和功能。这种命名方式有助于提高代码的可读性和可维护性，并促进团队之间的协作和理解。</p>


<h4 class="relative group">Native rules 
    <div id="native-rules" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#native-rules" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>内置规则（Built-in rules）是Bazel中内置的、由Java实现的规则。这些规则在.bzl文件中以原生模块中的函数形式出现（例如native.cc_library或native.java_library）。而用户定义的规则（非原生规则）则是使用Starlark创建的。</p>


<h4 class="relative group">Output base 
    <div id="output-base" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#output-base" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在Bazel中，工作空间专用目录（workspace-specific directory）通常被称为&quot;bazel-out&quot;。它是一个由Bazel自动创建的目录，用于存储构建过程中生成的各种输出文件，如编译生成的二进制文件、中间文件、测试结果、日志文件等。该目录的位置位于Bazel的输出用户根目录下，用于将构建过程中产生的文件与源代码目录分离开，以保持项目结构的清晰性和可维护性。</p>


<h4 class="relative group">Output groups 
    <div id="output-groups" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#output-groups" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>输出组（Output group）是指在Bazel完成构建一个目标后，预计将生成的一组文件。规则通常会将其常规输出放在&quot;default output group&quot;中（例如，Java规则的.jar文件、C++规则目标的.a和.so文件）。默认输出组是在命令行上请求目标时构建的输出组。</p>
<p>规则可以定义更多的命名输出组，可以在BUILD文件（使用filegroup规则）或命令行（&ndash;output_groups标志）中显式指定。命名输出组允许开发者将特定类型的输出文件分组，以便在构建过程中对其进行特定的处理或操作。</p>
<p>通过输出组的概念，Bazel提供了一种灵活的机制来管理构建过程中生成的文件。开发者可以根据需要将文件分组，以便更好地组织、处理和操作构建输出。这样可以提高构建过程的灵活性和可定制性，并为构建系统的构建结果提供更好的结构和组织。</p>


<h4 class="relative group">Output user root 
    <div id="output-user-root" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#output-user-root" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>用户特定的目录，用于存储Bazel的输出。目录名称来自于用户系统的用户名。如果多个用户同时在系统上构建同一项目，这样的目录结构可以避免输出文件冲突。它包含与各个工作空间的构建输出相对应的子目录，也被称为输出基目录（output bases）。</p>


<h4 class="relative group">Package 
    <div id="package" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#package" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一个BUILD文件定义的目标集合。一个包（package）的名称是相对于工作空间根目录的BUILD文件路径。一个包可以包含子包，或者包含BUILD文件的子目录，从而形成一个包的层级结构。</p>
<p>在Bazel中，每个BUILD文件定义了一个或多个目标。这些目标可以是编译的二进制文件、库、测试等。一个包是一组相关目标的集合，用于组织和管理相关代码和资源。包的名称是BUILD文件相对于工作空间根目录的路径，通过名称可以唯一标识和引用该包。</p>
<p>一个包可以包含多个子包，这些子包可以是在包内部的子目录，每个子目录都包含一个或多个BUILD文件。这种层级结构的组织方式使得代码和资源可以按照逻辑和功能进行分组，便于项目的管理和维护。通过包的层级结构，可以在构建过程中方便地引用和操作不同级别的目标，从而形成灵活和可扩展的项目结构.</p>


<h4 class="relative group">Package group 
    <div id="package-group" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#package-group" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一个目标，代表一组包（packages）。通常在可见性属性（visibility attribute）的值中使用。</p>


<h4 class="relative group">Platform 
    <div id="platform" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#platform" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在构建过程中涉及的“机器类型”（machine type）。这包括Bazel运行的主机平台（&ldquo;host&quot;平台）、构建工具在其上执行的机器（&ldquo;exec&quot;平台）以及构建目标的目标机器（&ldquo;target&quot;平台）。</p>
<p>主机平台（host platform）指的是运行Bazel的计算机系统，它提供了构建环境和资源。</p>
<p>执行平台（exec platform）是指在构建过程中实际执行构建工具的机器。这些构建工具可以是编译器、链接器、测试运行器等。执行平台可能与主机平台不同，特别是在跨平台构建或远程构建的情况下。</p>
<p>目标平台（target platform）是指构建的目标所要运行的目标机器。它可以是不同的操作系统、处理器架构或设备。Bazel支持在不同的目标平台上构建和运行代码，这使得跨平台开发和构建成为可能。</p>
<p>通过区分主机平台、执行平台和目标平台，Bazel可以根据不同的平台要求和配置，有效地管理和执行构建过程，并生成适用于特定目标平台的构建结果。</p>


<h4 class="relative group">Provider 
    <div id="provider" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#provider" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>提供者（Provider）是一种描述在依赖关系中在规则目标之间传递的信息单元的模式。通常，它包含编译器选项、传递的源文件或输出文件以及构建元数据等信息。它通常与依赖集（depsets）结合使用，以高效地存储累积的传递数据。内置的提供者之一是DefaultInfo。</p>
<p>需要注意的是，针对特定规则目标保存具体数据的对象被称为“提供者实例”（provider instance），尽管有时它与“提供者”（provider）这个术语混淆使用。</p>
<p>提供者的概念用于在Bazel构建系统中传递和共享关于目标的相关信息。通过定义和使用提供者，不同的规则目标之间可以传递和访问彼此所需的数据和元数据。提供者实例是提供者模式的具体实现，用于为特定的规则目标提供特定的数据。这种机制使得规则目标之间可以有效地共享和传递信息，并为构建系统提供了更灵活和可扩展的方式来处理目标之间的依赖关系和数据传递。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/extending/rules#providers" target="_blank">Provider documentation</a></p>


<h4 class="relative group">Query (concept) 
    <div id="query-concept" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#query-concept" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>构建分析是指对构建图进行分析，以了解目标属性和依赖关系结构的过程。Bazel支持三种查询变体：query、cquery和aquery。</p>
<ul>
<li></li>
</ul>
<p>query：这是最常用的查询命令，用于从构建图中获取目标的属性信息、依赖关系、输出文件等。可以使用query命令来查询目标的属性值、依赖的目标以及目标的输出文件等详细信息。</p>
<ul>
<li></li>
</ul>
<p>cquery：这是一个更复杂和强大的查询命令，用于执行复杂的构建图查询操作。它支持使用复杂的查询条件和过滤器来获取目标的详细信息，并可以根据查询结果执行特定的操作。</p>
<ul>
<li></li>
</ul>
<p>aquery：这是一个用于分析构建图的高级查询命令。它可以提供有关目标之间依赖关系、构建过程和执行过程的详细信息。通过aquery命令，可以深入了解构建图的结构和执行细节，有助于进行构建性能分析和优化。</p>


<h4 class="relative group">Repository cache 
    <div id="repository-cache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#repository-cache" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>共享内容寻址缓存（Content-Addressable Cache）是Bazel为构建过程中下载的文件提供的一个共享缓存，可以跨工作空间共享。它使得在初始下载后可以进行离线构建成为可能。通常用于缓存通过repository rules（如http_archive）和repository rule APIs（如repository_ctx.download）下载的文件。只有在下载时指定了文件的SHA-256校验和，才会将文件缓存起来。</p>
<p>共享内容寻址缓存是一种通过文件内容的哈希值来寻址和存储文件的机制。在Bazel中，通过将文件的SHA-256校验和用作其唯一标识符，将文件存储在共享缓存中。当下次构建需要相同文件时，Bazel会首先检查共享缓存，如果缓存中已存在相应的文件，则可以直接使用缓存中的副本，而无需重新下载。</p>


<h4 class="relative group">Reproducibility 
    <div id="reproducibility" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#reproducibility" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>无论环境，时间或者具体调用方式的变化，结果总是确定的，且可复现的。</p>


<h4 class="relative group">Rule 
    <div id="rule" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#rule" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>规则（Rule）是用于在BUILD文件中定义规则目标（rule targets）的一种模式，例如cc_library。从BUILD文件作者的角度来看，规则由一组属性和黑盒逻辑组成。逻辑告诉规则目标如何生成输出构件并将信息传递给其他规则目标。从.bzl文件作者的角度来看，规则是扩展Bazel以支持新的编程语言和环境的主要方式。</p>
<p>在加载阶段，规则被实例化为规则目标，用于生成构建图。在分析阶段，规则目标通过提供者（providers）的形式向下游依赖传递信息，并注册描述如何生成输出构件的操作。这些操作在执行阶段运行。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/extending/rules" target="_blank">Rules documentation</a></p>


<h4 class="relative group">Runfiles 
    <div id="runfiles" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#runfiles" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>Runfiles是指测试在运行时所需的文件和目录。这些文件和目录可以是测试执行过程中需要访问的数据文件、配置文件、资源文件等。Bazel会根据构建规则中指定的运行时依赖项，将相应的Runfiles复制到与测试可执行文件并列的目录结构中。这样，在运行测试时，可执行文件就可以访问其所需的运行时数据。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/extending/rules#runfiles" target="_blank">Runfiles documentation</a></p>


<h4 class="relative group">Sandboxing 
    <div id="sandboxing" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#sandboxing" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>沙盒，这个不用介绍了</p>


<h4 class="relative group">Skyframe 
    <div id="skyframe" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#skyframe" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p><a href="https://bazel.build/reference/skyframe" target="_blank">Skyframe</a> Bazel的核心框架，用来提供并发，执行等功能</p>


<h4 class="relative group">Starlark 
    <div id="starlark" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#starlark" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>Starlark是用于编写规则和宏的扩展语言。它是Python的一个受限子集（在语法和语法上），旨在用于配置目的和提高性能。Starlark文件使用.bzl扩展名。BUILD文件使用Starlark的一个更受限制的版本（例如，不支持def函数定义），曾被称为Skylark。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/rules/language" target="_blank">Starlark language documentation</a></p>


<h4 class="relative group">Startup flags 
    <div id="startup-flags" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#startup-flags" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>The set of flags specified between <code>bazel</code> and the <a href="https://bazel.build/reference/glossary#query-command" target="_blank">command</a>, for example, bazel <code>--host_jvm_debug</code> build. These flags modify the <a href="https://bazel.build/reference/glossary#configuration" target="_blank">configuration</a> of the Bazel server, so any modification to startup flags causes a server restart. Startup flags are not specific to any command.</p>


<h4 class="relative group">Target 
    <div id="target" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#target" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>目标（Target）是在BUILD文件中定义的对象，由标签（label）标识。从最终用户的角度来看，目标代表了工作空间的可构建单元。</p>
<p>通过实例化规则而声明的目标称为规则目标（rule target）。根据规则的不同，这些目标可以是可执行的（如cc_binary）或可测试的（如cc_test）。规则目标通常通过其属性（如deps）依赖于其他目标；这些依赖关系构成了目标图的基础。</p>
<p>除了规则目标，还有文件目标和包组目标。文件目标对应于在BUILD文件中引用的构件。作为特例，任何包的BUILD文件始终被视为该包中的源文件目标。</p>
<p>在加载阶段，目标被发现和解析。在分析阶段，目标与构建配置关联起来，形成配置目标（configured target）。</p>


<h4 class="relative group">Target graph 
    <div id="target-graph" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#target-graph" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>构建图（Build graph）是一种目标及其依赖关系的内存中表示形式。它在加载阶段生成，并作为分析阶段的输入。</p>
<p>构建图是一个有向无环图（Directed Acyclic Graph，DAG），其中节点表示目标，边表示依赖关系。通过构建图，Bazel可以了解每个目标之间的依赖关系，以及构建过程中各个目标的顺序和执行逻辑</p>


<h4 class="relative group">Target pattern 
    <div id="target-pattern" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#target-pattern" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>用于指定针对哪些target的方式，常用的模式有:all（所有规则目标），:*（所有规则目标 + 文件目标），&hellip;（当前包和所有子包递归）。可以组合使用，例如，//&hellip;:*表示从工作空间根目录递归地包含所有包中的所有规则和文件目标。</p>


<h4 class="relative group">Tests 
    <div id="tests" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#tests" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>这个不用多介绍了吧，测试规则，一般要包含一个可执行对象，返回码啥的</p>


<h4 class="relative group">Toolchain 
    <div id="toolchain" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#toolchain" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>用于构建某种语言输出的一组工具。通常，工具链包括编译器、链接器、解释器或/和代码检查工具。工具链也可以根据平台的不同而有所变化，也就是说，Unix编译器工具链的组件可能与Windows的不同，尽管工具链是用于相同的语言。选择适合平台的正确工具链称为工具链解析（toolchain resolution）。</p>


<h4 class="relative group">Transition 
    <div id="transition" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#transition" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>将配置变换的过程。即使从同一个规则实例化，build graph中的目标也可以具有不同的配置，这就是转换的作用。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/extending/config#user-defined-transitions" target="_blank">User-defined transitions</a></p>


<h4 class="relative group">Tree artifact 
    <div id="tree-artifact" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#tree-artifact" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>表示一堆产物的集合。由于这些文件本身不是artifacts，因此对它们进行操作的action必须将Tree artifact明确为其输入或输出。</p>


<h4 class="relative group">Visibility 
    <div id="visibility" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#visibility" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>构建系统中防止不必要的依赖关系的两种机制之一：目标可见性用于控制一个目标是否可以被其他目标依赖；加载可见性用于控制BUILD或.bzl文件是否可以加载给定的.bzl文件。通常情况下，没有上下文的情况下，&ldquo;可见性&quot;通常指的是目标可见性。</p>
<p><strong>参考:</strong> <a href="https://bazel.build/concepts/visibility" target="_blank">Visibility documentation</a></p>


<h4 class="relative group">Workspace 
    <div id="workspace" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#workspace" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>工作区，实际上就是包含WORKSPACE文件的目录</p>


<h4 class="relative group">WORKSPACE file 
    <div id="workspace-file" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#workspace-file" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>用来定义工作区的文件，一般来说还包含一些外部信息和初始化流程</p>


<h3 class="relative group">2 核心基础概念 
    <div id="2-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>这部分实际上会针对性地重点讲一下最常用的术语，和最常见的问题。很多Bazel体系的用户经常遇到的错误都是比较&quot;简单”的错误，往往是对核心概念理解不到位导致。这里的概念很多都是剥离了语言层面，只关注通用领域。</p>
<p>建议直接看https://blog.aspect.dev/avoid-eager-fetches 获取最直接的理解。</p>


<h3 class="relative group">核心基础术语 
    <div id="%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>介绍术语之前，先看看bazel的一次执行过程，都有什么阶段？</p>
<ol>
<li>
<p><strong>Loading Phase</strong>: Bazel会加载工作目录里面的 BUILD文件，解析这些文件的内容来创建创建package和target graph。此阶段涉及评估宏、从glob到具体文件的映射关系（因为bazel支持glob，就那个什么**/*.txt的语法）和解析target之间的依赖关系。</p>
<ol>
<li>
<p>需要注意的是，如果在workspace里面写了一些外部依赖的命令，那么在LOAD阶段就会直接下载这些外部依赖，比方说下面的写在WORKSPACE里面的代码，一旦开始做构建，就会去下载对应的依赖（即使这些依赖目前并不需要），这个可能会导致bazel eager fetch的问题</p>
<pre tabindex="0"><code>load(&#34;@rules_python//python:pip.bzl&#34;, &#34;pip_parse&#34;)

pip_parse(
   name = &#34;my_deps&#34;,
   requirements_lock = &#34;//path/to:requirements_lock.txt&#34;,
)

load(&#34;@my_deps//:requirements.bzl&#34;, &#34;install_deps&#34;)
install_deps()
</code></pre></li>
</ol>
</li>
<li>
<p><strong>Analysis Phase</strong>: Bazel分析目标图，确定构建所需的操作步骤。它会检查目标的依赖项或源文件是否发生了变化，以确定是否需要重新构建。在此阶段，Bazel创建一个操作图，表示生成所需输出的构建步骤的顺序。</p>
<ol>
<li>
<p>这里依然存在bazel eager fetch的问题，因为在BUILD文件里面同样包含Load语句，看下面的例子，只要需要涉及构建到这个对应BUILD文件，或者说这个package的某个target，就会引入npm的拉取</p>
<pre tabindex="0"><code># Content of //pkg1:BUILD
load(&#34;@npm//@bazel/typescript:index.bzl&#34;, &#34;ts_project&#34;)

package(default_visibility = [&#34;//visibility:public&#34;])

ts_project(
    name = &#34;a&#34;,
    srcs = glob([&#34;*.ts&#34;]),
    declaration = True,
    tsconfig = &#34;//:tsconfig.json&#34;,
    deps = [
        &#34;@npm//@types/node&#34;,
        &#34;@npm//tslib&#34;,
    ],
)

filegroup(name = &#34;b&#34;)
</code></pre></li>
</ol>
</li>
<li>
<p><strong>Execution Phase</strong>: Bazel执行action graph中的操作（这里注意，不是target graph），以构建目标。该阶段涉及调用编译器、链接器和其他构建所需的工具。Bazel会尽可能并行执行这些操作，利用可用资源加快构建过程。</p>
</li>
<li>
<p><strong>Output Generation</strong>: 随着操作的执行，Bazel生成目标指定的输出文件。这些文件可以是二进制可执行文件、库文件、测试结果或在BUILD文件中定义的其他构建产物。</p>
</li>
<li>
<p><strong>Caching and Incremental Build</strong>: Bazel利用缓存机制来提高构建性能。它会缓存先前构建的结果，并使用它们来避免重新执行未更改的操作。这种增量构建的特性使得Bazel只需重新构建项目中必要的部分，节省时间和资源。</p>
<ol>
<li>注意，bazel的<a href="https://bazel.build/docs/build#repository-cache" target="_blank">&ldquo;repository cache&rdquo;</a> 是不会缓存外部依赖的，如果外部依赖的下载规则里面有sha256 的hash它才会缓存，否则就是很简单的cvs拉取</li>
</ol>
</li>
<li>
<p><strong>Build Success or Failure</strong>: 构建结束啦，这个时候如果是编译就是输出具体文件的路径，如果测试（成功）就是成功了，没啥别的信息</p>
</li>
</ol>
<p>下面的术语，我会把影响到的阶段也一并列出</p>


<h4 class="relative group">LABEL 
    <div id="label-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#label-1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>loading phase，analysis phase</p>
<p>所有target都属于一个包。目标的名称称为其标签。每个标签都唯一标识一个目标。一般来说推荐提供完整路径用来标识特定的target，比方说下面的例子，第一部分是仓库名字<code>@myrepo//</code>. 因为大部分代码都是同样代码库，所以可以直接写//，省略最前面的代码库。标签第二部分表示package 名字， <code>my/app/main </code>用路径来表示。我推荐用户使用完整的路径来标识target，而不是相对地方式，来避免问题</p>
<pre tabindex="0"><code>@myrepo//my/app/main:app_binary
</code></pre>

<h4 class="relative group">BUILD 文件 
    <div id="build-%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#build-%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>loading phase，analysis phase</p>
<p>一般研发平时需要写的都是BUILD文件，简单来说就是如何定义Package。Build是Bazel的主要配置文件，用于告诉Bazel要构建哪些软件输出，它们的依赖关系是什么，以及如何构建它们。</p>
<p>大多数构建规则都依托于具体的语言，比方说cc_binary、cc_library和cc_test分别是用于构建C++二进制文件、库和测试的构建规则。其他编程语言使用相同的命名方案，只是前缀不同，例如Java的规则以java_*开头。</p>
<p>bazel的规则一部分是native支持，另一部分就是拓展方式支持，因为bazel的拓展大部分命名为 <code>.bzl</code>格式，因此使用类似下面的语句来加载规则</p>
<pre tabindex="0"><code>load(&#34;//foo/bar:file.bzl&#34;, &#34;some_library&#34;)
</code></pre><p>Bazel的规则分类</p>
<ul>
<li>
<p><code>*_binary</code>规则用于构建特定语言的可执行程序。在构建完成后，可执行文件将位于构建工具的输出目录里面中，路径与规则的标签相对应。例如，//my:program将出现在二进制输出树的$(BIN_DIR)/my/program路径下，bazel会明确地输出编译出来的文件的路径，我原先测试的时候默认的BIN_DIR是bazel-bin</p>
<p>在某些语言中，这些规则还会创建一个runfiles目录，其中包含属于该规则的data属性中提到的所有文件，或者依赖项的传递闭包中的任何规则所提到的文件。这些文件集合会集中在一个位置，方便部署到生产环境中。</p>
</li>
<li>
<p><code>*_test</code>规则是_binary规则的一种特殊形式，用于自动化测试。测试只是在成功时返回零的程序，<strong>所以不要再问，为什么我的测试程序成功了，但是没看到日志呀？</strong></p>
<p>与二进制文件一样，测试也有runfiles目录，其中的文件是测试在运行时合法打开的唯一文件。例如，一个名为cc_test(name=&lsquo;x&rsquo;, data=[&rsquo;//foo:bar&rsquo;])的程序在执行过程中可以打开和读取$TEST_SRCDIR/workspace/foo/bar。（每种编程语言都有自己的实用函数用于访问$TEST_SRCDIR的值，但它们都等同于直接使用环境变量。）如果违反此规则，当在远程测试主机上执行测试时，测试将失败。<strong>runfiles目录的可见性对应于BUILD文件中明确指定的可见性</strong></p>
</li>
<li>
<p><code>*_library</code>规则用于指定在给定编程语言中单独编译的模块。库可以依赖其他库，而<code>*_binary</code>和<code>*_test</code>可以依赖库。</p>
</li>
</ul>


<h4 class="relative group">Dependencies 
    <div id="dependencies" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#dependencies" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>loading phase，analysis phase</p>
<p>在写BUILD的时候，真正要解决的问题往往是依赖关系的修正，正常情况下，如果你依赖了什么东西，你就应该直接添加到deps或者data里面。而不是让自己依赖的组件来提供这种依赖，参考下面的例子</p>
<p><code>a</code>直接依赖<code>c</code>，但忘记在构建文件中声明它时， 就会引入潜在风险。</p>
<table>
  <thead>
      <tr>
          <th><code>a / a.in</code></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>import b; <br/>        import c; <br/>        b.foo(); <br/>        c.garply();</td>
          <td></td>
      </tr>
      <tr>
          <td>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://bazel.build/static/docs/images/a_b_c.svg" alt="声明的依赖图" />
    
  </figure>
</td>
          <td>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://bazel.build/static/docs/images/a_b_c_ac.svg" alt="实际依赖图" />
    
  </figure>
</td>
      </tr>
  </tbody>
</table>
<p>声明的依赖关系不再符合实际的依赖关系。这种情况下构建可能会正常运行，因为依赖关系被闭包封锁了的，但掩盖了一个问题：<code>a</code>直接依赖<code>c</code>。如果b哪一天不依赖c了，那构建就崩了，这个问题实际上现在C++也开始治理了，禁止implicit include某个函数。</p>
<p>大多数构建规则都具有三个属性，用于指定不同类型的通用依赖项：<code>srcs</code>、<code>deps</code>和<code>data</code>。下面对此进行解释。详细的相关信息，请参阅 <a href="https://bazel.build/reference/be/common-definitions" target="_blank">所有规则通用的属性</a>。</p>
<p>这几种依赖关系提供不同的功能</p>
<ol>
<li>
<p>src依赖：构建时一个或多个规则直接使用的文件。</p>
</li>
<li>
<p>deps依赖：指向提供头文件、符号、库、数据等的单独编译模块的规则。</p>
</li>
<li>
<p>data依赖：常见情况时test或者binary需要的运行或者测试数据文件。编译单元测试执行文件时，不需要该文件，但在运行测试时确实需要它。简单来说就是在执行期间用到的工具。这种文件一般加在data里面，因为构建系统在一个隔离目录中运行测试（实际上就是沙盒），其中只有列到 <code>data</code>的文件可用。因此，如果二进制/库/测试需要运行一些文件，请在<code>data</code>.里面加这些东西。下面的代码就显示了两种情况，分别是本目录引用文件，和其它目录的test引用文件。</p>
</li>
</ol>
<pre tabindex="0"><code># I need a config file from a directory named env:
java_binary(
    name = &#34;setenv&#34;,
    ...
    data = [&#34;:env/default_env.txt&#34;],
)

# I need test data from another directory
sh_test(
    name = &#34;regtest&#34;,
    srcs = [&#34;regtest.sh&#34;],
    data = [
        &#34;//data:file1.txt&#34;,
        &#34;//data:file2.txt&#34;,
        ...
    ],
)
</code></pre><p>想引用这些文件可通过相对路径<code>path/to/data/file</code>获得。在测试中，使用拼接的最终目录或者使用相对路径来引用这些文件，例如 <code>${TEST_SRCDIR}/workspace/path/to/data/file</code>.</p>


<h4 class="relative group">Visibility 
    <div id="visibility-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#visibility-1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>loading phase，analysis phase</p>
<p>上面的提到了BUILD，提到了依赖，这里面自然而然就引出了一个问题，怎么控制我的target是否可以被别人依赖？可见性就解决这个问题：<strong>目标可见性</strong>控制谁可以依赖于具体的target，即谁可以在deps添加（例如 ）内使用对应的target。</p>
<p>这个东西，目前看起来是一种很好的规范，但是不一定能立刻推广开。感觉可能大家第一反应就是所有的都是public。。。</p>
<p>下面有一些具体的例子</p>
<ul>
<li>
<p><code>&quot;//visibility:public&quot;</code>: 所有的外部packet都能看到这个target。实际上目前的代码基本都是这种情况。</p>
</li>
<li>
<p><code>&quot;//visibility:private&quot;</code>: 只有当前package的target可以看到这个target</p>
</li>
<li>
<p><code>&quot;//foo/bar:__pkg__&quot;</code>:  <code>//foo/bar</code> 可以看到这个target(但子packages看不到).</p>
</li>
<li>
<p><code>&quot;//foo/bar:__subpackages__&quot;</code>:  <code>//foo/bar</code> 和它的间接或直接 subpackages都可以看到</p>
</li>
<li>
<p><code>&quot;//some_pkg:my_package_group&quot;</code>: Grants access to all of the packages that are part of the given <a href="https://bazel.build/reference/be/functions#package_group" target="_blank"><code>package_group</code></a>.</p>
</li>
</ul>


<h4 class="relative group">sandbox 
    <div id="sandbox" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#sandbox" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>execution phase</p>
<p>bazel使用沙盒有多种原因</p>
<ul>
<li>
<p>不使用沙盒，如果使用了未声明的输入文件（即未在BUILD的规则的deps或者data里面明确列出的文件），那么本应该构建失败但是可能成功了反而。</p>
</li>
<li>
<p>不正确地重用缓存条目会在远程缓存期间引发问题。共享缓存中的错误缓存条目会影响项目中的每个开发人员，而清除整个远程缓存不是可行的解决方案。</p>
</li>
<li>
<p>沙盒隔离模拟了远程执行的行为 - 如果使用沙盒隔离进行构建运行良好，那么它很可能也适用于远程执行。通过使远程执行上传所有必需的文件（包括本地工具）。<strong>注意啊，沙盒只是个过程，最后还是进程，在buildfarm的环境里面，我已经看到好几次本地执行命令的副作用了，比方说什么创建文件不删除的奇葩代码</strong></p>
</li>
</ul>
<p>那么，我们就需要按照情况，选择在何种模式下执行命令，简单来说就是选择用不用沙盒，用哪种沙盒</p>
<ul>
<li>
<p><code>local</code>（也叫做<code>standalone</code>）策略不会进行任何类型的沙盒隔离。它只是将操作的命令行设置为工作目录，并在工作区的execroot中执行。</p>
</li>
<li>
<p><code>processwrapper-sandbox</code>是一种不需要任何“高级”功能的沙盒策略，它应该可以在任何POSIX系统上正常工作。它会构建一个沙盒目录，其中包含指向原始源文件的符号链接，然后使用该目录代替execroot设置操作的工作目录来执行操作的命令行，然后将输出文件移出沙盒并放入execroot中，最后删除沙盒。这样可以防止操作意外使用未声明的输入文件，并避免在execroot中留下未知的输出文件。</p>
</li>
<li>
<p><code>linux-sandbox</code>更进一步，在processwrapper-sandbox的基础上进行了扩展。类似于Docker在底层所做的工作，它使用Linux命名空间（用户、挂载、PID、网络和IPC命名空间）将操作与主机隔离开来。也就是说，除了沙盒目录以外，它将整个文件系统设置为只读，因此操作不能意外修改主机文件系统上的任何内容。这样可以防止出现像是一个有错误的测试意外删除了您的$HOME目录的情况。您还可以选择<strong>禁止操作访问网络（<strong>非常棒的特征，总有一些奇怪的用户会写测试访问数据库</strong>）</strong>。</p>
</li>
<li>
<p><code>darwin-sandbox</code>与之类似，但用于macOS。它使用苹果的sandbox-exec工具实现了与Linux沙盒大致相同的功能。</p>
</li>
</ul>
<p>请注意<code>linux-sandbox</code>和<code>darwin-sandbox</code>都无法在“套娃”场景中工作，因为不推荐docker使用privileged模式，就是 <code>docker run --privileged</code>，所以如果你想在docker里面调用linux-sandbox，做不到啊。所以一般docker里面是fallback到<code>processwrapper-sandbox</code></p>


<h3 class="relative group">3 实践 快速浏览Bazel配置 
    <div id="3-%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E6%B5%8F%E8%A7%88bazel%E9%85%8D%E7%BD%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3-%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E6%B5%8F%E8%A7%88bazel%E9%85%8D%E7%BD%AE" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>现在我们来做一些实践，如何快速看配置相关的东西。</p>
<p>简单来讲，看配置的方法基本就是三步</p>
<ul>
<li>
<p>先看WORKSPACE看工具链</p>
<ul>
<li>WORKSPACE中工具链的配置可以方便理解具体的规则上下文，配置是否移动化，阅读WORKSPACE中的配置就能看出来</li>
</ul>
</li>
<li>
<p>递归地看.bazelrc里面的通用配置组</p>
<ul>
<li>
<p>配置组.bazelrc的阅读过程中，要注意try-import语句，正确的情况下会拆分为</p>
<pre tabindex="0"><code># Missing CI section
try-import %workspace%/abc.bazelrc
</code></pre></li>
</ul>
</li>
<li>
<p>递归地看BUILD文件里面load的各种语句的实现</p>
<ul>
<li>具体的各种语句，比方说rules docker的规则细节什么的，都可以直接对应到starlark语句。</li>
</ul>
</li>
</ul>
<p>简单地看一个例子</p>
<p>WORKSPACE如下，可以发现这是一个go的仓库，其初始化了GO的依赖，同时引入了rules_docker</p>
<pre tabindex="0"><code>workspace(name = &#34;debug&#34;)

load(&#34;@bazel_gazelle//:deps.bzl&#34;, &#34;gazelle_dependencies&#34;)
load(&#34;//bazel:go_deps.bzl&#34;, &#34;go_dependencies&#34;)

# gazelle:repository_macro bazel/go_deps.bzl%go_dependencies
go_dependencies()

load(&#34;@io_bazel_rules_docker//repositories:deps.bzl&#34;, rules_docker_go_deps = &#34;deps&#34;)

rules_docker_go_deps()  
</code></pre><p>.bazelrc如下，可以发现环境默认使用python3，编译的C++选项默认为C++17，且开启了fpic，release模式下，开启了thin级别的flto。</p>
<pre tabindex="0"><code>build --java_runtime_version=remotejdk_11

build --host_force_python=PY3
build --python_version=PY3

build --cxxopt=-std=c++17

build --experimental_cc_shared_library
build --experimental_link_static_libraries_once

# This is to avoid building both PIC and non-PIC versions in opt mode,
# which doubles the build time.
build --force_pic

build:release --copt=&#34;-g1&#34; --copt=&#34;-flto=thin&#34;
</code></pre>

<h3 class="relative group">4 Bazel的输出布局 
    <div id="4-bazel%E7%9A%84%E8%BE%93%E5%87%BA%E5%B8%83%E5%B1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4-bazel%E7%9A%84%E8%BE%93%E5%87%BA%E5%B8%83%E5%B1%80" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>这部分普通的研发应该遇不到，对于普通研发用户而言，输出布局一般是固定的，他们常常遇到的问题都是权限错误的问题，可以通过对输出布局的理解来定位具体是什么原因导致的问题，最常见也是最简单的解决方法就是chown。</p>
<p>对Infra研发而言，这部分就比较重要，输出布局需要根据业务需要做变化，尤其在CI环境下，比方说输出目录，CACHE在哪里。还有如何排查一些确定性的问题的时候输出布局知识就体现其重要性</p>


<h3 class="relative group">输出布局 
    <div id="%E8%BE%93%E5%87%BA%E5%B8%83%E5%B1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BE%93%E5%87%BA%E5%B8%83%E5%B1%80" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>目前Bazel的文件布局是怎么实现的呢？</p>
<ul>
<li>Bazel命令行必须在WORKSPACE文件所在的目录，或者子目录调用</li>
<li>Linux默认的<em>outputRoot</em>目录设置为<code>~/.cache/bazel</code></li>
<li>Bazel用户编译状态位于 <code>outputRoot/_bazel_$USER</code>.</li>
<li>在 <code>outputUserRoot</code> 目录有个 <code>install</code> 目录，里面放了一堆MD5的编译产物文件</li>
<li>在 <code>outputUserRoot</code> 目录, an <code>outputBase</code> 目录会根据workspace directory的MD5创建 .比方说workspace路径为 <code>/home/user/src/my-project</code> (or in a directory symlinked to that one), 就会创建<code>/home/user/.cache/bazel/_bazel_user/7ffd56a6e4cb724ea575aba15733d113</code>. 目录。</li>
<li>通过配置Bazel&rsquo;s <code>--output_base</code> 启动选项来覆盖默认的output base 目录,举个例子 <code>bazel --output_base=/tmp/bazel/output build x/y:z</code>.</li>
<li>通过配置Bazel&rsquo;s <code>--output_user_root</code> 启动选项来覆盖默认的install base 和 output base 目录，比方说<code>bazel --output_user_root=/tmp/bazel build x/y:z</code>.</li>
</ul>
<p>Copy</p>
<pre tabindex="0"><code>&lt;workspace-name&gt;/                         &lt;== workspace文件路径
  bazel-my-project =&gt; &lt;...my-project&gt;     &lt;== Symlink to execRoot
  bazel-out =&gt; &lt;...bin&gt;                   &lt;== Convenience symlink to outputPath
  bazel-bin =&gt; &lt;...bin&gt;                   &lt;== Convenience symlink to most recent written bin dir $(BINDIR)
  bazel-testlogs =&gt; &lt;...testlogs&gt;         &lt;== Convenience symlink to the test logs directory

/home/user/.cache/bazel/                  &lt;== Root for all Bazel output on a machine: outputRoot
  _bazel_$USER/                           &lt;== Top level directory for a given user depends on the user name:
                                              outputUserRoot
    install/
      fba9a2c87ee9589d72889caf082f1029/   &lt;== Hash of the Bazel install manifest: installBase
        _embedded_binaries/               &lt;== Contains binaries and scripts unpacked from the data section of
                                              the bazel executable on first run (such as helper scripts and the
                                              main Java file BazelServer_deploy.jar)
    7ffd56a6e4cb724ea575aba15733d113/     &lt;== Hash of the client&#39;s workspace directory (such as
                                              /home/user/src/my-project): outputBase
      action_cache/                       &lt;== Action cache directory hierarchy
                                              This contains the persistent record of the file
                                              metadata (timestamps, and perhaps eventually also MD5
                                              sums) used by the FilesystemValueChecker.
      action_outs/                        &lt;== Action output directory. This contains a file with the
                                              stdout/stderr for every action from the most recent
                                              bazel run that produced output.
      command.log                         &lt;== A copy of the stdout/stderr output from the most
                                              recent bazel command.
      external/                           &lt;== The directory that remote repositories are
                                              downloaded/symlinked into.
      server/                             &lt;== The Bazel server puts all server-related files (such
                                              as socket file, logs, etc) here.
        jvm.out                           &lt;== The debugging output for the server.
      execroot/                           &lt;== The working directory for all actions. For special
                                              cases such as sandboxing and remote execution, the
                                              actions run in a directory that mimics execroot.
                                              Implementation details, such as where the directories
                                              are created, are intentionally hidden from the action.
                                              Every action can access its inputs and outputs relative
                                              to the execroot directory.
        &lt;workspace-name&gt;/                 &lt;== Working tree for the Bazel build &amp; root of symlink forest: execRoot
          _bin/                           &lt;== Helper tools are linked from or copied to here.

          bazel-out/                      &lt;== All actual output of the build is under here: outputPath
            local_linux-fastbuild/        &lt;== one subdirectory per unique target BuildConfiguration instance;
                                              this is currently encoded
              bin/                        &lt;== Bazel outputs binaries for target configuration here: $(BINDIR)
                foo/bar/_objs/baz/        &lt;== Object files for a cc_* rule named //foo/bar:baz
                  foo/bar/baz1.o          &lt;== Object files from source //foo/bar:baz1.cc
                  other_package/other.o   &lt;== Object files from source //other_package:other.cc
                foo/bar/baz               &lt;== foo/bar/baz might be the artifact generated by a cc_binary named
                                              //foo/bar:baz
                foo/bar/baz.runfiles/     &lt;== The runfiles symlink farm for the //foo/bar:baz executable.
                  MANIFEST
                  &lt;workspace-name&gt;/
                    ...
              genfiles/                   &lt;== Bazel puts generated source for the target configuration here:
                                              $(GENDIR)
                foo/bar.h                     such as foo/bar.h might be a headerfile generated by //foo:bargen
              testlogs/                   &lt;== Bazel internal test runner puts test log files here
                foo/bartest.log               such as foo/bar.log might be an output of the //foo:bartest test with
                foo/bartest.status            foo/bartest.status containing exit status of the test (such as
                                              PASSED or FAILED (Exit 1), etc)
              include/                    &lt;== a tree with include symlinks, generated as needed. The
                                              bazel-include symlinks point to here. This is used for
                                              linkstamp stuff, etc.
            host/                         &lt;== BuildConfiguration for build host (user&#39;s workstation), for
                                              building prerequisite tools, that will be used in later stages
                                              of the build (ex: Protocol Compiler)
        &lt;packages&gt;/                       &lt;== Packages referenced in the build appear as if under a regular workspace
</code></pre>

<h3 class="relative group">5 实践 GRPC的Bazel集成 
    <div id="5-%E5%AE%9E%E8%B7%B5-grpc%E7%9A%84bazel%E9%9B%86%E6%88%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5-%E5%AE%9E%E8%B7%B5-grpc%E7%9A%84bazel%E9%9B%86%E6%88%90" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>俗话说“知行合一”，没有了实践，仅有理论或者思维的前行是不能得到正确的结论的，下面开始实际的写一套代码，来理解bazel的实际运用。不过这部分都是我写的mock代码，可以跳过</p>


<h4 class="relative group">创建WORKSPACE文件 
    <div id="%E5%88%9B%E5%BB%BAworkspace%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%88%9B%E5%BB%BAworkspace%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>开始利用bazel体系构建一个继承C++,Golang,Rust,Python的monorepo，该仓库需要支持grpc,glog,absiel,boost,gtest等外部仓库，我将这个仓库命名为cyber_security。</p>
<p>新建一个folder，写入下面的内容到WORKSPACE文件，这里我们先引入llvm c++ &amp; grpc的支持，写一个grpc的同步模式服务器。下面的代码可以看到注释掉了protobuf的引入（因为有个bug还没解决），引入了grpc和llvm toolchain。</p>
<p>我之所以不使用llvm 16是因为在mac m1上会报错，所以使用的是15的llvm版本</p>
<pre tabindex="0"><code>workspace(name = &#34;cyber_security&#34;)

load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

# portable llvm toolchain

BAZEL_TOOLCHAIN_TAG = &#34;0.8.2&#34;
BAZEL_TOOLCHAIN_SHA = &#34;0fc3a2b0c9c929920f4bed8f2b446a8274cad41f5ee823fd3faa0d7641f20db0&#34;

http_archive(
    name = &#34;com_grail_bazel_toolchain&#34;,
    sha256 = BAZEL_TOOLCHAIN_SHA,
    strip_prefix = &#34;bazel-toolchain-{tag}&#34;.format(tag = BAZEL_TOOLCHAIN_TAG),
    canonical_id = BAZEL_TOOLCHAIN_TAG,
    url = &#34;https://github.com/grailbio/bazel-toolchain/archive/refs/tags/{tag}.tar.gz&#34;.format(tag = BAZEL_TOOLCHAIN_TAG),
)

load(&#34;@com_grail_bazel_toolchain//toolchain:deps.bzl&#34;, &#34;bazel_toolchain_dependencies&#34;)

bazel_toolchain_dependencies()

load(&#34;@com_grail_bazel_toolchain//toolchain:rules.bzl&#34;, &#34;llvm_toolchain&#34;)

llvm_toolchain(
    name = &#34;llvm_toolchain&#34;,
    llvm_version = &#34;15.0.0&#34;,
)

load(&#34;@llvm_toolchain//:toolchains.bzl&#34;, &#34;llvm_register_toolchains&#34;)

llvm_register_toolchains()

# protobuf and grpc section
# http_archive(
#     name = &#34;rules_proto&#34;,
#     sha256 = &#34;dc3fb206a2cb3441b485eb1e423165b231235a1ea9b031b4433cf7bc1fa460dd&#34;,
#     strip_prefix = &#34;rules_proto-5.3.0-21.7&#34;,
#     urls = [
#         &#34;https://github.com/bazelbuild/rules_proto/archive/refs/tags/5.3.0-21.7.tar.gz&#34;,
#     ],
# )
# load(&#34;@rules_proto//proto:repositories.bzl&#34;, &#34;rules_proto_dependencies&#34;, &#34;rules_proto_toolchains&#34;)
# rules_proto_dependencies()
# rules_proto_toolchains()

http_archive(
    name = &#34;com_github_grpc_grpc&#34;,
    strip_prefix = &#34;grpc-1.57.0&#34;,
    sha256 = &#34;8393767af531b2d0549a4c26cf8ba1f665b16c16fb6c9238a7755e45444881dd&#34;,
    urls = [&#34;https://github.com/grpc/grpc/archive/refs/tags/v1.57.0.tar.gz&#34;],
)
 
load(&#34;@com_github_grpc_grpc//bazel:grpc_deps.bzl&#34;, &#34;grpc_deps&#34;)
grpc_deps()
 
load(&#34;@com_github_grpc_grpc//bazel:grpc_extra_deps.bzl&#34;, &#34;grpc_extra_deps&#34;)
grpc_extra_deps()
</code></pre>

<h4 class="relative group">编写BUILD文件和代码 
    <div id="%E7%BC%96%E5%86%99build%E6%96%87%E4%BB%B6%E5%92%8C%E4%BB%A3%E7%A0%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BC%96%E5%86%99build%E6%96%87%E4%BB%B6%E5%92%8C%E4%BB%A3%E7%A0%81" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>环境初始化好了以后新建proto文件和BUILD文件</p>
<pre tabindex="0"><code># experimental/sync_grpc_server/protos/stream.proto
syntax=&#34;proto3&#34;;

package stream;

// The service definition.
service Parser {
  // Sends a request
  rpc SendRequest (Request) returns (Response) {}
}

message Request {
    bytes client_ip = 1;
}

message Response {
    bytes event_id = 1;
}

# experimental/sync_grpc_server/protos/BUILD
```starlark
package(default_visibility = [&#34;//visibility:public&#34;])

load(&#34;@rules_proto//proto:defs.bzl&#34;, &#34;proto_library&#34;)
load(&#34;@rules_cc//cc:defs.bzl&#34;, &#34;cc_proto_library&#34;)
load(&#34;@com_github_grpc_grpc//bazel:cc_grpc_library.bzl&#34;, &#34;cc_grpc_library&#34;)

# The following three rules demonstrate the usage of the cc_grpc_library rule in
# in a mode compatible with the native proto_library and cc_proto_library rules.
proto_library(
    name = &#34;stream_proto&#34;,
    srcs = [&#34;stream.proto&#34;],
)

cc_proto_library(
    name = &#34;stream_cc_proto&#34;,
    deps = [&#34;:stream_proto&#34;],
)

cc_grpc_library(
    name = &#34;stream_cc_grpc&#34;,
    srcs = [&#34;:stream_proto&#34;],
    grpc_only = True,
    deps = [&#34;:stream_cc_proto&#34;],
)

```
</code></pre><p>接着新建server和client的代码</p>
<pre tabindex="0"><code>#experimental/sync_grpc_server/src/sync_client.cc
```cpp
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

#include &#34;grpcpp/grpcpp.h&#34;

#ifdef BAZEL_BUILD
#include &#34;experimental/sync_grpc_server/protos/stream.grpc.pb.h&#34;
#else
#include &#34;stream.grpc.pb.h&#34;
#endif

using grpc::Channel;
using grpc::ClientContext;
using grpc::Status;
using stream::Parser;
using stream::Response;
using stream::Request;

class ParserClient {
 public:
  ParserClient(std::shared_ptr&lt;Channel&gt; channel)
      : stub_(Parser::NewStub(channel)) {}

  // Assembles the client&#39;s payload, sends it and presents the response back
  // from the server.
  std::string SendRequest() {
    // Data we are sending to the server.
    Request request;
    request.set_client_ip(&#34;127.0.0.1&#34;);

    // Container for the data we expect from the server.
    Response response;

    // Context for the client. It could be used to convey extra information to
    // the server and/or tweak certain RPC behaviors.
    ClientContext context;

    // The actual RPC.
    Status status = stub_-&gt;SendRequest(&amp;context, request, &amp;response);

    // Act upon its status.
    if (status.ok()) {
      return std::string(response.event_id());
    } else {
      std::cout &lt;&lt; status.error_code() &lt;&lt; &#34;: &#34; &lt;&lt; status.error_message() &lt;&lt; std::endl;
      return &#34;RPC failed&#34;;
    }
  }

 private:
  std::unique_ptr&lt;Parser::Stub&gt; stub_;
};

int main(int argc, char** argv) {
  std::string address = &#34;localhost&#34;;
  std::string port = &#34;50051&#34;;
  std::string server_address = address + &#34;:&#34; + port;
  std::cout &lt;&lt; &#34;Client querying server address: &#34; &lt;&lt; server_address &lt;&lt; std::endl;


  // Instantiate the client. It requires a channel, out of which the actual RPCs
  // are created. This channel models a connection to an endpoint (in this case,
  // localhost at port 50051). We indicate that the channel isn&#39;t authenticated
  // (use of InsecureChannelCredentials()).
  ParserClient Parser(grpc::CreateChannel(
      server_address, grpc::InsecureChannelCredentials()));

  std::string response = Parser.SendRequest();
  std::cout &lt;&lt; &#34;Parser received: &#34; &lt;&lt; response &lt;&lt; std::endl;

  return 0;
}
```
#experimental/sync_grpc_server/src/sync_server.cc
```cpp
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

#include &lt;grpcpp/grpcpp.h&gt;

#ifdef BAZEL_BUILD
#include &#34;experimental/sync_grpc_server/protos/stream.grpc.pb.h&#34;
#else
#include &#34;stream.grpc.pb.h&#34;
#endif

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using stream::Request;
using stream::Response;
using stream::Parser;

// Logic and data behind the server&#39;s behavior.
class ParserServiceImpl final : public Parser::Service {
  Status SendRequest(ServerContext* context, const Request* request,
                  Response* response) override {
    response-&gt;set_event_id(&#34;47F1F2FF-7679-4378-ACC7-051F72D5679A&#34;);
    return Status::OK;
  }
};

void RunServer() {
  std::string address = &#34;0.0.0.0&#34;;
  std::string port = &#34;50051&#34;;
  std::string server_address = address + &#34;:&#34; + port;
  ParserServiceImpl service;

  ServerBuilder builder;
  // Listen on the given address without any authentication mechanism.
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
  // Register &#34;service&#34; as the instance through which we&#39;ll communicate with
  // clients. In this case it corresponds to an *synchronous* service.
  builder.RegisterService(&amp;service);
  // Finally assemble the server.
  std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart());
  std::cout &lt;&lt; &#34;Server listening on &#34; &lt;&lt; server_address &lt;&lt; std::endl;

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  server-&gt;Wait();
}

int main(int argc, char** argv) {
  RunServer();

  return 0;
}
```
#experimental/sync_grpc_server/src/BUILD
```starlark
package(default_visibility = [&#34;//visibility:public&#34;])

load(&#34;@rules_cc//cc:defs.bzl&#34;, &#34;cc_binary&#34;)

cc_binary(
    name = &#34;sync_client&#34;,
    srcs = [&#34;sync_client.cc&#34;],
    defines = [&#34;BAZEL_BUILD&#34;],
    deps = [
        &#34;//experimental/sync_grpc_server/protos:stream_cc_grpc&#34;,
        &#34;@com_github_grpc_grpc//:grpc++&#34;,
    ],
)

cc_binary(
    name = &#34;sync_server&#34;,
    srcs = [&#34;sync_server.cc&#34;],
    defines = [&#34;BAZEL_BUILD&#34;],
    deps = [
        &#34;//experimental/sync_grpc_server/protos:stream_cc_grpc&#34;,
        &#34;@com_github_grpc_grpc//:grpc++&#34;,
    ],
)
```
</code></pre>

<h4 class="relative group">运行 
    <div id="%E8%BF%90%E8%A1%8C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%90%E8%A1%8C" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code># 窗口1 运行server
bazel run experimental/sync_grpc_server/src:sync_server

# 窗口2 运行client
bazel run experimental/sync_grpc_server/src:sync_client

#输出结果
➜  cyber_security git:(main) bazel run experimental/sync_grpc_server/src:sync_client
INFO: Analyzed target //experimental/sync_grpc_server/src:sync_client (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //experimental/sync_grpc_server/src:sync_client up-to-date:
  bazel-bin/experimental/sync_grpc_server/src/sync_client
INFO: Elapsed time: 0.168s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Running command line: bazel-bin/experimental/sync_grpc_server/src/sync_client
Client querying server address: localhost:50051
Parser received: 47F1F2FF-7679-4378-ACC7-051F72D5679A
</code></pre>

<h3 class="relative group">6 使用Bazel管理C++ 
    <div id="6-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86c" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#6-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86c" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>使用Bazel管理C++实际上并没有什么本质的不同，转变思想，从task based build system转移到artifacts build system，仅此而已。C++本身代码构建和Bazel的依赖呀，src啥的属性也非常匹配。我们先看看基础命令</p>


<h4 class="relative group">C++基础规则 
    <div id="c%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99" aria-label="锚点">#</a>
    </span>        
    
</h4>


<h5 class="relative group">CC_IMPORT 
    <div id="cc_import" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#cc_import" aria-label="锚点">#</a>
    </span>        
    
</h5>
<pre tabindex="0"><code>cc_import(
  name = &#34;mylib&#34;,
  hdrs = [&#34;mylib.h&#34;],
  static_library = &#34;libmylib.a&#34;,
  # If alwayslink is turned on,
  # libmylib.a will be forcely linked into any binary that depends on it.
  # alwayslink = 1,
)
</code></pre><p>cc_import是用来解决外部依赖的问题的，一般用来将C++头文件和静态库从外部包或存储库导入到项目里，这个可以提供给跨平台编译使用</p>


<h5 class="relative group">CC_LIBRARY 
    <div id="cc_library" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#cc_library" aria-label="锚点">#</a>
    </span>        
    
</h5>
<pre tabindex="0"><code>cc_library(
    name = &#34;my_library&#34;,
    srcs = [&#34;file1.cpp&#34;, &#34;file2.cpp&#34;],
    hdrs = [&#34;header1.h&#34;, &#34;header2.h&#34;],
    visibility = [&#34;//visibility:public&#34;],
    deps = [&#34;//path/to/dependency&#34;],
    defines = [&#34;DEBUG&#34;],
    copts = [&#34;-Wall&#34;, &#34;-O2&#34;],
)
</code></pre><p><code>cc_library</code> 是 Bazel 中专门用于构建 C++ 库的构建规则，有以下属性。</p>
<ul>
<li><code>name</code>：指定库目标的名称。</li>
<li><code>srcs</code>：列出库的 C++ 源文件（<code>.cpp</code> 文件）。</li>
<li><code>hdrs</code>：列出库的 C++ 头文件（<code>.h</code> 文件）。</li>
<li><code>visibility</code>：设置库目标的可见性，以控制其他目标是否可以依赖它。它使用标签模式，如 <code>&quot;//path/to/package:target&quot;</code>。</li>
<li><code>deps</code>：指定库的依赖项。这可以是其他 <code>cc_library</code> 目标或库所依赖的其他类型的目标。</li>
<li><code>defines</code>：定义预处理宏，用于编译过程中使用。</li>
<li><code>copts</code>：设置库的编译选项，如警告标志或优化级别。</li>
</ul>


<h5 class="relative group">CC_BINARY 
    <div id="cc_binary" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#cc_binary" aria-label="锚点">#</a>
    </span>        
    
</h5>
<pre tabindex="0"><code>cc_binary(
    name = &#34;my_binary&#34;,
    srcs = [&#34;main.cpp&#34;, &#34;util.cpp&#34;],
    hdrs = [&#34;util.h&#34;],
    visibility = [&#34;//visibility:public&#34;],
    deps = [&#34;//path/to/dependency&#34;],
    copts = [&#34;-Wall&#34;, &#34;-O2&#34;],
)
</code></pre><p>参数因为和cc_library过分类似就不写了，就多赘述一句，除了编译，可以使用 Bazel 的 <code>bazel run</code> 命令，执行对应的Binary，这个执行一般是在sandbox里</p>
<pre tabindex="0"><code>bazel run //path/to/package:my_binary
</code></pre>

<h5 class="relative group">CC_TEST 
    <div id="cc_test" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#cc_test" aria-label="锚点">#</a>
    </span>        
    
</h5>
<pre tabindex="0"><code>cc_test(
    name = &#34;my_test&#34;,
    srcs = [&#34;test.cpp&#34;, &#34;util.cpp&#34;],
    hdrs = [&#34;util.h&#34;],
    visibility = [&#34;//visibility:public&#34;],
    deps = [&#34;//path/to/dependency&#34;],
    size = &#34;small&#34;,
    copts = [&#34;-Wall&#34;, &#34;-O2&#34;],
)
</code></pre><p>重复的东西不写了，只看几个关键点</p>
<ul>
<li><code>size</code>属性用于指定测试的时间和内存使用约束。它用来限制测试运行的时间和内存，防止测试用例运行时间过长或占用过多的系统内存资源，下面的表格给出来了一些约定俗成的资源消耗规格。一般来说，如果cc_test是单元测试，那么size指定为small；如果是集成测试，size指定为medium，如果是接受性测试或者端到端测试，一般size指定为large或者enormous
<table>
  <thead>
      <tr>
          <th style="text-align: left">Size</th>
          <th style="text-align: left">RAM (in MB)</th>
          <th style="text-align: left">CPU (in CPU cores)</th>
          <th style="text-align: left">Default timeout</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">small</td>
          <td style="text-align: left">20</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">short (1 minute)</td>
      </tr>
      <tr>
          <td style="text-align: left">medium</td>
          <td style="text-align: left">100</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">moderate (5 minutes)</td>
      </tr>
      <tr>
          <td style="text-align: left">large</td>
          <td style="text-align: left">300</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">long (15 minutes)</td>
      </tr>
      <tr>
          <td style="text-align: left">enormous</td>
          <td style="text-align: left">800</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">eternal (60 minutes)</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
<p>一般调用的时候都是直接</p>
<pre tabindex="0"><code>bazel test //path/to/package:my_test
</code></pre>

<h5 class="relative group">例子 
    <div id="%E4%BE%8B%E5%AD%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BE%8B%E5%AD%90" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>这里只提供BUILD文件作为例子参考了，针对C++一般也是直接用Gtest，直接一套集成。。。</p>
<pre tabindex="0"><code>load(&#34;//bazel:cpplint.bzl&#34;, &#34;cpplint&#34;)
load(&#34;//bazel:rules_cc.bzl&#34;, &#34;cc_library&#34;, &#34;cc_test&#34;)

package(default_visibility = [&#34;//visibility:public&#34;])

cc_library(
    name = &#34;file_debug&#34;,
    srcs = [&#34;file_debug.cc&#34;],
    hdrs = [&#34;file_debug.h&#34;],
    deps = [
        &#34;@boost//:filesystem&#34;,
        &#34;@com_github_google_glog//:glog&#34;,
        &#34;@com_google_absl//absl/strings&#34;,
        &#34;@com_google_absl//absl/strings:str_format&#34;,
        &#34;@com_googlesource_code_re2//:re2&#34;,
    ],
)

filegroup(
    name = &#34;file_pointer_file&#34;,
    # only two mock file pointer file, will never add new, so use glob
    srcs = glob([
        &#34;*.txt&#34;,
    ]),
)

cc_test(
    name = &#34;file_debug_test&#34;,
    srcs = [
        &#34;file_debug_test.cc&#34;,
    ],
    data = [
        &#34;:file_pointer_file&#34;,
    ],
    deps = [
        &#34;:file_debug&#34;,
        &#34;@com_google_googletest//:gtest&#34;,
        &#34;@com_google_googletest//:gtest_main&#34;,
    ],
)

cpplint()
</code></pre>

<h5 class="relative group">常见问题 
    <div id="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>写几个常见的问题，我目前看到很多研发都问过</p>
<ol>
<li><code>cc_test</code>可以管理什么样子的test？理论上只要是C++的测试程序，有返回值来判断是否执行成功，就都可以写为<code>cc_test</code>，因此无论写单元测试，集成测试，acceptance-check都是可以的。使用什么层级的测试，做哪些事情属于CI系统或者程序员自己的层面</li>
<li>为什么<code>cc_test</code>超时了？参考cc_test那部分的size属性，如果size不合适可能会报错TIMEOUT。</li>
<li>为什么<code>cc_test</code>好像没测试，直接就输出了成功？我希望用户能理解，bazel本身是有缓存机制的，如果不希望使用已经缓存过的结果，建议在test的时候加上&ndash;nocache_test_results，来强行reruntest</li>
<li>为什么<code>cc_test</code>没输出日志？在test运行成功的情况下（或者说期望情况下），可以认为逻辑正确执行，输入测试用例都得到了正确的输出，那么我们不需要关心具体的细节，bazel就不会输出任何问题。只有test执行失败，才会输出对应的日志</li>
<li>为什么我写的<code>cc_test</code>找不到文件？检查写的BUILD文件里面的deps和data是不是都写全了，路径是不是写的相对路径，将依赖的数据路径加到BUILD里的时候，数据依赖应该是使用相对路径，而不是本地绝对路径。</li>
</ol>
<p>下面来看看一套从0开始的C++集成教程，这个实际上是官方教程，我直接抄的</p>


<h4 class="relative group">C++ 集成入门 
    <div id="c-%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c-%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8" aria-label="锚点">#</a>
    </span>        
    
</h4>


<h5 class="relative group">先决条件 
    <div id="%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>装好bazel和git以后，先把bazel官方给的代码库clone下来</p>
<pre tabindex="0"><code>git clone https://github.com/bazelbuild/examples
</code></pre><p>本教程的示例项目位于该<code>examples/cpp-tutorial</code>目录中。</p>
<p>下面看一下它的结构：</p>
<pre tabindex="0"><code>examples
└── cpp-tutorial
    ├──stage1
    │  ├── main
    │  │   ├── BUILD
    │  │   └── hello-world.cc
    │  └── WORKSPACE
    ├──stage2
    │  ├── main
    │  │   ├── BUILD
    │  │   ├── hello-world.cc
    │  │   ├── hello-greet.cc
    │  │   └── hello-greet.h
    │  └── WORKSPACE
    └──stage3
       ├── main
       │   ├── BUILD
       │   ├── hello-world.cc
       │   ├── hello-greet.cc
       │   └── hello-greet.h
       ├── lib
       │   ├── BUILD
       │   ├── hello-time.cc
       │   └── hello-time.h
       └── WORKSPACE
</code></pre><p>共有三组文件，每组代表本教程中的一个阶段。在第一阶段，构建驻留在单个<a href="https://bazel.build/reference/glossary#package" target="_blank">包中的单个</a><a href="https://bazel.build/reference/glossary#target" target="_blank">目标</a>。在第二阶段，您将从单个包构建二进制文件和库。在第三个也是最后一个阶段，您将构建一个包含多个包的项目并使用多个目标构建它。</p>


<h5 class="relative group">设置WorkSpace 
    <div id="%E8%AE%BE%E7%BD%AEworkspace" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%AE%BE%E7%BD%AEworkspace" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>在构建项目之前，需要设置WorkSpace。一般将工作区理解为一个保存源代码和 Bazel 构建输出的目录。它必须包含下面两种文件：</p>
<ul>
<li><a href="https://bazel.build/reference/glossary#workspace-file" target="_blank"><code>WORKSPACE file</code></a>文件，标识一个 Bazel 工作区，一般是位于代码根目录下。</li>
<li><a href="https://bazel.build/reference/glossary#build-file" target="_blank"><code>BUILD files</code></a>``，告诉 Bazel 如何构建项目的不同部分。工作区中包含文件的目录<code>BUILD</code>是package。（本教程稍后将详细介绍包。）</li>
</ul>
<p>在将来的项目中，要将目录指定为 Bazel 工作区，请创建一个<code>WORKSPACE</code>在该目录中命名的空文件。</p>
<p><strong>注意</strong>：当 Bazel 构建项目时，所有输入必须位于同一工作区中。驻留在不同工作区中的文件彼此独立，除非显式地链接到一起。<a href="https://bazel.build/reference/be/workspace" target="_blank">有关工作区规则的更多详细信息可以在本指南</a>中找到。</p>


<h5 class="relative group">了解 BUILD 文件 
    <div id="%E4%BA%86%E8%A7%A3-build-%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BA%86%E8%A7%A3-build-%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>一个<code>BUILD</code>文件包含多种不同类型的 Bazel 指令。每个 <code>BUILD</code>文件至少需要一个<a href="https://bazel.build/reference/glossary#rule" target="_blank">规则</a> 作为一组指令，告诉 Bazel 如何构建目标，这些目标包括，例如可执行二进制binary或库。<code>BUILD</code>文件中构建rule的每个实例（）称为<a href="https://bazel.build/reference/glossary#target" target="_blank">目标</a> ，并指向一组特定的源文件和<a href="https://bazel.build/reference/glossary#dependency" target="_blank">依赖项</a>。一个目标也可以指向其他目标。</p>
<p>查看目录<code>BUILD</code>下的文件<code>cpp-tutorial/stage1/main</code>：</p>
<pre tabindex="0"><code>cc_binary(
    name = &#34;hello-world&#34;,
    srcs = [&#34;hello-world.cc&#34;],
)
</code></pre><p>在我们的示例中，<code>hello-world</code>目标实例化 Bazel 的内置 <a href="https://bazel.build/reference/be/c-cpp#cc_binary" target="_blank"><code>cc_binary rule</code></a>. 该规则告诉 Bazel 从源文件构建一个独立的linux binary， <code>hello-world.cc</code>没有依赖项。</p>
<p>接下来构建单一目标，且不会出现多包以来的代码。</p>


<h5 class="relative group">第一阶段：单一目标、单一包 
    <div id="%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%8D%95%E4%B8%80%E7%9B%AE%E6%A0%87%E5%8D%95%E4%B8%80%E5%8C%85" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%8D%95%E4%B8%80%E7%9B%AE%E6%A0%87%E5%8D%95%E4%B8%80%E5%8C%85" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>现在是构建项目第一部分的时候了。这部分的代码结构为：</p>
<pre tabindex="0"><code>examples
└── cpp-tutorial
    └──stage1
       ├── main
       │   ├── BUILD
       │   └── hello-world.cc
       └── WORKSPACE
</code></pre><p>首先切换目录到<code>cpp-tutorial/stage1</code>目录：</p>
<pre tabindex="0"><code>cd cpp-tutorial/stage1
</code></pre><p>接下来，运行：</p>
<pre tabindex="0"><code>bazel build //main:hello-world
</code></pre><p>可以看到如下的输出内容，Bazel 生成的东西看起来像这样：</p>
<pre tabindex="0"><code>INFO: Found 1 target...
Target //main:hello-world up-to-date:
  bazel-bin/main/hello-world
INFO: Elapsed time: 2.267s, Critical Path: 0.25s
</code></pre><p>恭喜，使用bazel很简单。Bazel 将构建的目标target文件，放置在 <code>bazel-bin</code>工作区根目录中。</p>
<p>现在即可运行您新构建的二进制文件，即：</p>
<pre tabindex="0"><code>bazel-bin/main/hello-world
</code></pre><p>这会导致打印“ <code>Hello world</code>”消息。</p>
<p>这是第一阶段的依赖关系图：</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://lets-write-some-bazel-guide.gitbook.io/~gitbook/image?url=https%3A%2F%2Fbazel.build%2Fstatic%2Fdocs%2Fimages%2Fcpp-tutorial-stage1.png&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=1f2cce4b4778df90f619f769d36ce9e20c78af17264ccf7544fa1b7321b5c093" alt="img" />
    
  </figure>
</p>
<p>hello-world 的依赖关系图显示具有单个源文件的单个目标。</p>


<h5 class="relative group">第二阶段：多个构建目标 
    <div id="%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%A4%9A%E4%B8%AA%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%A4%9A%E4%B8%AA%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>虽然单个目标对于小型项目来说就足够了，但较大的项目，无论是从效率的角度，还是逻辑的角度，需要拆分为多个目标和包，。</p>
<p>第 2 阶段使用的目录：</p>
<pre tabindex="0"><code>    ├──stage2
    │  ├── main
    │  │   ├── BUILD
    │  │   ├── hello-world.cc
    │  │   ├── hello-greet.cc
    │  │   └── hello-greet.h
    │  └── WORKSPACE
</code></pre><p>下面看一下目录<code>BUILD</code>中的文件<code>cpp-tutorial/stage2/main</code>：</p>
<pre tabindex="0"><code>cc_library(
    name = &#34;hello-greet&#34;,
    srcs = [&#34;hello-greet.cc&#34;],
    hdrs = [&#34;hello-greet.h&#34;],
)

cc_binary(
    name = &#34;hello-world&#34;,
    srcs = [&#34;hello-world.cc&#34;],
    deps = [
        &#34;:hello-greet&#34;,
    ],
)
</code></pre><p>使用此<code>BUILD</code>文件，Bazel 首先构建<code>hello-greet</code>库（使用 Bazel 的内置<a href="https://bazel.build/reference/be/c-cpp#cc_library" target="_blank"><code>cc_library rule</code></a>），然后构建<code>hello-world</code>二进制文件。<code>deps</code>目标中的属性告诉<code>hello-world</code>Bazel<code>hello-greet</code> 构建二进制文件需要该库<code>hello-world</code>。</p>
<p>在构建该项目的新版本之前，您需要更改目录，<code>cpp-tutorial/stage2</code>通过运行以下命令切换到该目录：</p>
<pre tabindex="0"><code>cd ../stage2
</code></pre><p>现在您可以使用以下熟悉的命令构建新的二进制文件：</p>
<pre tabindex="0"><code>bazel build //main:hello-world
</code></pre><p>Bazel 再一次生成了如下所示的内容：</p>
<pre tabindex="0"><code>INFO: Found 1 target...
Target //main:hello-world up-to-date:
  bazel-bin/main/hello-world
INFO: Elapsed time: 2.399s, Critical Path: 0.30s
</code></pre><p>现在您可以测试新构建的二进制文件，它返回另一个“ <code>Hello world</code>”：</p>
<pre tabindex="0"><code>bazel-bin/main/hello-world
</code></pre><p>如果您现在修改<code>hello-greet.cc</code>并重建项目，Bazel 只会重新编译该文件。</p>
<p>查看依赖关系图，您可以看到它<code>hello-world</code>依赖于名为 的额外输入<code>hello-greet</code>：</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://lets-write-some-bazel-guide.gitbook.io/~gitbook/image?url=https%3A%2F%2Fbazel.build%2Fstatic%2Fdocs%2Fimages%2Fcpp-tutorial-stage2.png&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=0aabf0674a1ac2747190f4013413a030e852b5235ce76ab940f6beed505547c5" alt="img" />
    
  </figure>
</p>
<p>“hello-world”的依赖关系图显示文件修改后的依赖关系更改。</p>


<h4 class="relative group"> 
    <div id="" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#" aria-label="锚点">#</a>
    </span>        
    
</h4>


<h5 class="relative group">第三阶段：多包 
    <div id="%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%A4%9A%E5%8C%85" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%A4%9A%E5%8C%85" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>下一阶段又增加了一层复杂性，并构建了一个包含多个包的项目。下面看一下该 <code>cpp-tutorial/stage3</code>目录的结构和内容：</p>
<pre tabindex="0"><code>└──stage3
   ├── main
   │   ├── BUILD
   │   ├── hello-world.cc
   │   ├── hello-greet.cc
   │   └── hello-greet.h
   ├── lib
   │   ├── BUILD
   │   ├── hello-time.cc
   │   └── hello-time.h
   └── WORKSPACE
</code></pre><p>您可以看到现在有两个子目录，每个子目录都包含一个<code>BUILD</code> 文件。因此，对于 Bazel 来说，工作区现在包含两个包：<code>lib</code>和 <code>main</code>。</p>
<p>看一下<code>lib/BUILD</code>文件：</p>
<pre tabindex="0"><code>cc_library(
    name = &#34;hello-time&#34;,
    srcs = [&#34;hello-time.cc&#34;],
    hdrs = [&#34;hello-time.h&#34;],
    visibility = [&#34;//main:__pkg__&#34;],
)
</code></pre><p>看一下<code>main/BUILD</code>文件中：</p>
<pre tabindex="0"><code>cc_library(
    name = &#34;hello-greet&#34;,
    srcs = [&#34;hello-greet.cc&#34;],
    hdrs = [&#34;hello-greet.h&#34;],
)

cc_binary(
    name = &#34;hello-world&#34;,
    srcs = [&#34;hello-world.cc&#34;],
    deps = [
        &#34;:hello-greet&#34;,
        &#34;//lib:hello-time&#34;,
    ],
)
</code></pre><p>主包中的目标<code>hello-world依赖包hello-time</code>中的目标<code>lib</code>（因此是目标标签<code>//lib:hello-time</code>）——Bazel 通过<code>deps</code>属性知道这一点。依赖关系图中看到这一点：</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://lets-write-some-bazel-guide.gitbook.io/~gitbook/image?url=https%3A%2F%2Fbazel.build%2Fstatic%2Fdocs%2Fimages%2Fcpp-tutorial-stage3.png&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=7f1550a9a0ed0785b72c1e44550e417b7803daee81d4d47f6b357e578d60d140" alt="img" />
    
  </figure>
</p>
<p>“hello-world”的依赖关系图显示了主包中的目标如何依赖于“lib”包中的目标。</p>
<p>为了成功构建，需要使用 Visibility 属性使<code>//lib:hello-time</code>目标<code>lib/BUILD</code> 对目标显式可见。<code>main/BUILD</code>这是因为默认情况下目标仅对同一文件中的其他目标可见 <code>BUILD</code>。Bazel 使用目标可见性来防止诸如包含实现细节的库泄漏到公共 API 等问题。</p>
<p>现在构建该项目的最终版本。<code>cpp-tutorial/stage3</code> 通过运行以下命令切换到目录：</p>
<pre tabindex="0"><code>cd  ../stage3
</code></pre><p>再次运行以下命令：</p>
<pre tabindex="0"><code>bazel build //main:hello-world
</code></pre><p>Bazel 生成的东西看起来像这样：</p>
<pre tabindex="0"><code>INFO: Found 1 target...
Target //main:hello-world up-to-date:
  bazel-bin/main/hello-world
INFO: Elapsed time: 0.167s, Critical Path: 0.00s
</code></pre><p>好的，大功告成啦</p>


<h4 class="relative group">C++如何引用外部库 
    <div id="c%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E5%BA%93" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E5%BA%93" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>接下来提到的东西就是Bazel被人诟病已久的传播性，理论上用Bazel管理的外部依赖都需要用Bazel的方式构建，实际上这个很合理，因为一致的从源码构建，才能保证flag的正确性，我有时候用Cmake也很无奈，构建外部库对当前的系统造成了污染。。。。</p>
<p>言归正传，目前Bazel还是提供了使用不同的构建方式依赖外部库的方法。</p>


<h5 class="relative group">方法1 直接找到对应的实现 
    <div id="%E6%96%B9%E6%B3%951-%E7%9B%B4%E6%8E%A5%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B9%E6%B3%951-%E7%9B%B4%E6%8E%A5%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%9E%E7%8E%B0" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>很多著名的库实际上要么本身支持了bazel，要么有人已经写好了对应的bazel规则。这个最直接的例子就是boost了，参考链接为https://github.com/nelhage/rules_boost，直接在WORKSPACE文件里面写入下面的内容。PS 记得更新url和sha256来使用新一些的版本。</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

# Boost
# Famous C++ library that has given rise to many new additions to the C++ Standard Library
# Makes @boost available for use: For example, add `@boost//:algorithm` to your deps.
# For more, see https://github.com/nelhage/rules_boost and https://www.boost.org
http_archive(
    name = &#34;com_github_nelhage_rules_boost&#34;,

    # Replace the commit hash in both places (below) with the latest, rather than using the stale one here.
    # Even better, set up Renovate and let it do the work for you (see &#34;Suggestion: Updates&#34; in the README).
    url = &#34;https://github.com/nelhage/rules_boost/archive/96e9b631f104b43a53c21c87b01ac538ad6f3b48.tar.gz&#34;,
    strip_prefix = &#34;rules_boost-96e9b631f104b43a53c21c87b01ac538ad6f3b48&#34;,
    # When you first run this tool, it&#39;ll recommend a sha256 hash to put here with a message like: &#34;DEBUG: Rule &#39;com_github_nelhage_rules_boost&#39; indicated that a canonical reproducible form can be obtained by modifying arguments sha256 = ...&#34;
)
load(&#34;@com_github_nelhage_rules_boost//:boost/boost.bzl&#34;, &#34;boost_deps&#34;)
boost_deps()
</code></pre><p>写代码的时候如果想使用boost对应的库，就可以在对应的规则的deps里面加上对boost依赖即可@boost即可。举个简单例子，比方说我要在一个C++ library里面使用boost的算法库，就直接在在deps里面加上@boost//:algorithm</p>
<p>如果你是用的是std17的C++，那么可能一部分功能直接用标准库即可，不一定要引用boost。</p>
<p>另一个例子是rules_folly，这个是（前）同事，也是工程治理大佬写的，参考链接为https://github.com/storypku/rules_folly</p>
<p>按照github链接的方式，安装好必要的依赖，下面是ubuntu的例子</p>
<pre tabindex="0"><code>sudo apt-get update \
    &amp;&amp; sudo apt-get -y install --no-install-recommends \
    autoconf \
    automake \
    libtool \
    libssl-dev
</code></pre><p>接着在WORKSPACE文件里面添加好对应的依赖，使用</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

http_archive(
    name = &#34;com_github_storypku_rules_folly&#34;,
    sha256 = &#34;16441df2d454a6d7ef4da38d4e5fada9913d1f9a3b2015b9fe792081082d2a65&#34;,
    strip_prefix = &#34;rules_folly-0.2.0&#34;,
    urls = [
        &#34;https://github.com/storypku/rules_folly/archive/v0.2.0.tar.gz&#34;,
    ],
)

load(&#34;@com_github_storypku_rules_folly//bazel:folly_deps.bzl&#34;, &#34;folly_deps&#34;)
folly_deps()

load(&#34;@com_github_nelhage_rules_boost//:boost/boost.bzl&#34;, &#34;boost_deps&#34;)
boost_deps()
</code></pre><p>这个库有一个点可能需要注意，</p>


<h5 class="relative group">方法2 手动改写BUILD文件 
    <div id="%E6%96%B9%E6%B3%952-%E6%89%8B%E5%8A%A8%E6%94%B9%E5%86%99build%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B9%E6%B3%952-%E6%89%8B%E5%8A%A8%E6%94%B9%E5%86%99build%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>手动改写BUILD文件，需要用户自己能够看明白Cmake的构建稳健是怎么生效的，有的时候做编译还得去考虑native编译工具链的事情，总之是个比较麻烦的事情。但也不失为一种办法。这种方法只需要注意：</p>
<ul>
<li>首先需要用http_archive的方式，将第三方库下载下来</li>
<li>其次，用指定Build的方式，指定为自己编写的BUILD文件</li>
</ul>
<p>给一个简单的例子，将hiredis转换为bazel的库，这里面我就不写指定Build的部分了，只简单写写怎么写BUILD文件。</p>
<p>首先看hiredis的cmakelists.txt文件，重点就是找到对应的SRC和对应的头文件，确定哪些应该暴露，哪些不应该暴露。除此之外，还要关注一些编译选项的东西，构建应该是统一的一套，即依赖hiredis的库编译用的是release模式，那么hiredis也是release模式。</p>
<pre tabindex="0"><code># Hiredis requires C99
SET(CMAKE_C_STANDARD 99)    #C99标准，添加到copt里面即可
SET(CMAKE_POSITION_INDEPENDENT_CODE ON)    #fpic标记，编译静态库时需要加上，这样子才能生成的静态库被第三方引用
SET(CMAKE_DEBUG_POSTFIX d)

SET(hiredis_sources   #下面的.c文件对应于bazel src文件，我们可以看到目前的代码实际上是包含sync和async的，
    alloc.c
    async.c
    dict.c
    hiredis.c
    net.c
    read.c
    sds.c
    sockcompat.c)

SET(hiredis_sources ${hiredis_sources})

...

ADD_LIBRARY(hiredis SHARED ${hiredis_sources})     #要生成这两个库文件
ADD_LIBRARY(hiredis_static STATIC ${hiredis_sources})

SET_TARGET_PROPERTIES(hiredis
    PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE
    VERSION &#34;${HIREDIS_SONAME}&#34;)
SET_TARGET_PROPERTIES(hiredis_static
    PROPERTIES COMPILE_PDB_NAME hiredis_static)
SET_TARGET_PROPERTIES(hiredis_static
    PROPERTIES COMPILE_PDB_NAME_DEBUG hiredis_static${CMAKE_DEBUG_POSTFIX})


#INSTALL_INTERFACE用于给install的时候指定使用的引用文件，那么INSTALL_INTERFACE又是怎么指定的？看这个https://ravenxrz.ink/archives/e40194d1.html
TARGET_INCLUDE_DIRECTORIES(hiredis PUBLIC $&lt;INSTALL_INTERFACE:include&gt; $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;)
TARGET_INCLUDE_DIRECTORIES(hiredis_static PUBLIC $&lt;INSTALL_INTERFACE:include&gt; $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;)

#CONFIGURE_FILE替换原本的普通文件的内容，给pkg用的，不需要了，所以去掉
CONFIGURE_FILE(hiredis.pc.in hiredis.pc @ONLY)

...

#Cpack打包的内容，直接省略了，关系并不大
...

IF(ENABLE_SSL)
    IF (NOT OPENSSL_ROOT_DIR)  #这个是export的openssl根目录，用来判断找openssl
        IF (APPLE)
            SET(OPENSSL_ROOT_DIR &#34;/usr/local/opt/openssl&#34;)
        ENDIF()
    ENDIF()
    FIND_PACKAGE(OpenSSL REQUIRED)  #找到依赖的openssl库
    SET(hiredis_ssl_sources         #编译hiredis_ssl库的源文件
        ssl.c)
    ADD_LIBRARY(hiredis_ssl SHARED  
            ${hiredis_ssl_sources}) #设定生成的库文件
    ADD_LIBRARY(hiredis_ssl_static STATIC
            ${hiredis_ssl_sources})

	...

    SET_TARGET_PROPERTIES(hiredis_ssl_static
        PROPERTIES COMPILE_PDB_NAME hiredis_ssl_static)
    SET_TARGET_PROPERTIES(hiredis_ssl_static
        PROPERTIES COMPILE_PDB_NAME_DEBUG hiredis_ssl_static${CMAKE_DEBUG_POSTFIX})

    TARGET_INCLUDE_DIRECTORIES(hiredis_ssl PRIVATE &#34;${OPENSSL_INCLUDE_DIR}&#34;)  #引入openssl包裹的头文件，只给自己用。不会暴露给hiredis_ssl的使用者
    TARGET_INCLUDE_DIRECTORIES(hiredis_ssl_static PRIVATE &#34;${OPENSSL_INCLUDE_DIR}&#34;)

    TARGET_LINK_LIBRARIES(hiredis_ssl PRIVATE ${OPENSSL_LIBRARIES})
...

    INSTALL(TARGETS hiredis_ssl hiredis_ssl_static
        EXPORT hiredis_ssl-targets
        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}    #安装bin文件的位置
        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}    #安装动态库的位置
        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})   #安装静态库的位置

...

    INSTALL(FILES hiredis_ssl.h   
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/hiredis)        #可以看到安装头文件的位置，将hiredis_ssl.h搞到了安装头文件hiredis里面

    INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/hiredis_ssl.pc    #提供给pkg安装用的，不用关注
        DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)

    export(EXPORT hiredis_ssl-targets
           FILE &#34;${CMAKE_CURRENT_BINARY_DIR}/hiredis_ssl-targets.cmake&#34;
           NAMESPACE hiredis::)

    SET(CMAKE_CONF_INSTALL_DIR share/hiredis_ssl)
    ...
ENDIF()

...
</code></pre><p>按照上面的cmakelist里面写的注释的解析过程，最终得出BUILD文件如下。这个是非SSL的版本，SSL的版本也非常简单，就不写了。</p>
<p>Copy</p>
<pre tabindex="0"><code>cc_library(
    name = &#34;hiredis&#34;,
    srcs = [
        &#34;alloc.c&#34;,
        &#34;dict.c&#34;,
        &#34;async.c&#34;,
        &#34;hiredis.c&#34;,
        &#34;net.c&#34;,
        &#34;read.c&#34;,
        &#34;sds.c&#34;,
        &#34;sockcompat.c&#34;,
    ],
    hdrs = glob([&#34;*.h&#34;])+glob([&#34;adapters/*.h&#34;])+[&#34;dict.c&#34;,],  #dict.c的引入是因为被async.c引了，而adapters是编译async时候别的库要使用
    include_prefix = &#34;hiredis&#34;,
    visibility = [&#34;//visibility:public&#34;],
)
</code></pre>

<h5 class="relative group">方法3 rules_foreign_cc 
    <div id="%E6%96%B9%E6%B3%953-rules_foreign_cc" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B9%E6%B3%953-rules_foreign_cc" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>rules_foreign_cc好用吗？好用，但是没有充分测试，且不被bazel的官方认可在我看来问题就比较大了，所以我个人不是特别喜欢rules_foreign_cc这套，不过也是个用法。</p>
<p>我个人拿rules_foreign_cc做测试比较早，所以下面的内容我推荐用最新版，直接参考https://bazelbuild.github.io/rules_foreign_cc/main/index.htmlopenssl和libuv做例子</p>
<p>首先需要配置引入rules_foreign_cc，并且下载openssl和libuv的源代码</p>
<pre tabindex="0"><code>workspace(name = &#34;cmake2bazel&#34;)

load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

http_archive(
   name = &#34;rules_foreign_cc&#34;,
   strip_prefix = &#34;rules_foreign_cc-4010620160e0df4d894b61496d3d3b6fc8323212&#34;,
    sha256 = &#34;07e3414cc841b1f4d16e5231eb818e5c5e03e2045827f5306a55709e5045c7fd&#34;,
   url = &#34;https://github.com/bazelbuild/rules_foreign_cc/archive/4010620160e0df4d894b61496d3d3b6fc8323212.zip&#34;,
)

load(&#34;@rules_foreign_cc//foreign_cc:repositories.bzl&#34;, &#34;rules_foreign_cc_dependencies&#34;)
rules_foreign_cc_dependencies()

all_content = &#34;&#34;&#34;filegroup(name = &#34;all&#34;, srcs = glob([&#34;**&#34;]), visibility = [&#34;//visibility:public&#34;])&#34;&#34;&#34;

# openssl
http_archive(
    name = &#34;openssl&#34;,
    build_file_content = all_content,
    strip_prefix = &#34;openssl-OpenSSL_1_1_1d&#34;,
    urls = [&#34;https://github.com/openssl/openssl/archive/OpenSSL_1_1_1d.tar.gz&#34;]
)
all_content = &#34;&#34;&#34;filegroup(name = &#34;all&#34;, srcs = glob([&#34;**&#34;]), visibility = [&#34;//visibility:public&#34;])&#34;&#34;&#34;

# openssl
http_archive(
    name = &#34;openssl&#34;,
    build_file_content = all_content,
    strip_prefix = &#34;openssl-OpenSSL_1_1_1d&#34;,
    urls = [&#34;https://github.com/openssl/openssl/archive/OpenSSL_1_1_1d.tar.gz&#34;]
)
# uv
http_archive(
    name = &#34;libuv&#34;,
    build_file_content = all_content,
    strip_prefix = &#34;libuv-1.42.0&#34;,
    urls = [&#34;https://github.com/libuv/libuv/archive/refs/tags/v1.42.0.tar.gz&#34;]

)
</code></pre><p>新建一个文件，为thirdy_party/openssl/BUILD</p>
<pre tabindex="0"><code># See https://github.com/bazelbuild/rules_foreign_cc
load(&#34;@rules_foreign_cc//foreign_cc:defs.bzl&#34;, &#34;configure_make&#34;)

config_setting(
    name = &#34;darwin_build&#34;,
    values = {&#34;cpu&#34;: &#34;darwin&#34;},
)

# See https://wiki.openssl.org/index.php/Compilation_and_Installation
# See https://github.com/bazelbuild/rules_foreign_cc/issues/338
#可以通过指定out_lib_dir选项指定编译出来的lib放在哪里，aka The path to where the compiled library binaries will be written to following a successful build
#对于使用configure-make形式的代码编译的方式，
configure_make(
    name = &#34;openssl&#34;,
#实际上调用configure的命令，默认是调用configure，这里可以找到openssl里面调用的是config
    configure_command = &#34;config&#34;,
#Any options to be put on the &#39;configure&#39; command line.
    configure_options =
      select({
            &#34;:darwin_build&#34;: [
              &#34;shared&#34;,
              &#34;ARFLAGS=r&#34;,
              &#34;enable-ec_nistp_64_gcc_128&#34;,
              &#34;no-ssl2&#34;, &#34;no-ssl3&#34;, &#34;no-comp&#34;
            ],
            &#34;//conditions:default&#34;: [
            ]}),
    #defines = [&#34;NDEBUG&#34;], Don&#39;t know how to use -D; NDEBUG seems to be the default anyway
#指定OPENSSL编译lib的源代码文件，aka Where the library source code is for openssl
    lib_source = &#34;@openssl//:all&#34;,               
    visibility = [&#34;//visibility:public&#34;],
#Environment variables to be set for the &#39;configure&#39; invocation.
    configure_env_vars =
        select({
            &#34;:darwin_build&#34;: {
              &#34;OSX_DEPLOYMENT_TARGET&#34;: &#34;10.14&#34;,
              &#34;AR&#34;: &#34;&#34;,
            },
            &#34;//conditions:default&#34;: {}}),
#用来指定共享出来的动态库、动态文件是什么，可以使用static_libraries属性来共享动态库
    out_shared_libs =
        select({
            &#34;:darwin_build&#34;: [
                &#34;libssl.dylib&#34;,
                &#34;libcrypto.dylib&#34;,
            ],
            &#34;//conditions:default&#34;: [
                &#34;libssl.so&#34;,
                &#34;libcrypto.so&#34;,
            ],
        })
)
</code></pre><p>接着新建一个文件为third_party/libuv/BUILD文件</p>
<pre tabindex="0"><code># See https://github.com/bazelbuild/rules_foreign_cc
load(&#34;@rules_foreign_cc//foreign_cc:defs.bzl&#34;, &#34;cmake&#34;)

cmake(
    name = &#34;libuv&#34;,
    lib_source = &#34;@libuv//:all&#34;,
    #out_static_libs = [&#34;libuv.a&#34;],
    out_static_libs = [&#34;libuv_a.a&#34;],
    #out_shared_libs = [&#34;libuv.so.1.0.0&#34;],  libuv.so是个链接，直接编译会报错
)
</code></pre><p>最后可以编译一下试试</p>
<pre tabindex="0"><code>qcraft@BJ-vgdog:~/code_test/cmake2bazel$ bazelisk-linux-amd64 build //third_party/libuv:libuv
DEBUG: Rule &#39;libuv&#39; indicated that a canonical reproducible form can be obtained by modifying arguments sha256 = &#34;371e5419708f6aaeb8656671f89400b92a9bba6443369af1bb70bcd6e4b3c764&#34;
DEBUG: Repository libuv instantiated at:
  /home/qcraft/code_test/cmake2bazel/WORKSPACE:36:13: in &lt;toplevel&gt;
Repository rule http_archive defined at:
  /home/qcraft/.cache/bazel/_bazel_qcraft/66cfb4dff202f299686aa7bc701960fa/external/bazel_tools/tools/build_defs/repo/http.bzl:336:31: in &lt;toplevel&gt;
INFO: Analyzed target //third_party/libuv:libuv (1 packages loaded, 1 target configured).
INFO: Found 1 target...
Target //third_party/libuv:libuv up-to-date:
  bazel-bin/third_party/libuv/libuv/include
  bazel-bin/third_party/libuv/libuv/lib/libuv_a.a
  bazel-bin/third_party/libuv/copy_libuv/libuv
INFO: Elapsed time: 31.269s, Critical Path: 30.97s
INFO: 2 processes: 1 internal, 1 linux-sandbox.
INFO: Build completed successfully, 2 total actions
</code></pre>

<h3 class="relative group">7 使用Bazel管理Python 
    <div id="7-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86python" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#7-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86python" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>先来看看Bazel里面Python的基础规则</p>


<h4 class="relative group">Python基础规则 
    <div id="python%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#python%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99" aria-label="锚点">#</a>
    </span>        
    
</h4>


<h5 class="relative group">py_binary &amp; py_library &amp; py_test 
    <div id="py_binary--py_library--py_test" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#py_binary--py_library--py_test" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>我建议直接阅读，https://bazel.build/reference/be/python#py_binary，或者参考C++规则那一部分，过于基础，我这里打算只简单写一个py_library了</p>
<p><code>py_library</code>是Bazel中用于构建Python库的规则。用来将Python代码打包成一个库，供其他目标（如<code>py_binary</code>或其他<code>py_library</code>）使用。下面是关于<code>py_library</code>规则的一些重要信息：</p>
<pre tabindex="0"><code>py_library(
    name = &#34;my_library&#34;,
    srcs = [&#34;module1.py&#34;, &#34;module2.py&#34;],
    deps = [&#34;//path/to:another_library&#34;],
)
</code></pre>

<h5 class="relative group">python工具链的配置 
    <div id="python%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84%E9%85%8D%E7%BD%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#python%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84%E9%85%8D%E7%BD%AE" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>首先还是先引入对rules_python的支持，在WORKSPACE里面写入下面的内容</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

rules_python_version = &#34;740825b7f74930c62f44af95c9a4c1bd428d2c53&#34; # Latest @ 2021-06-23

http_archive(
    name = &#34;rules_python&#34;,
    # Bazel will print the proper value to add here during the first build.
    # sha256 = &#34;FIXME&#34;,
    strip_prefix = &#34;rules_python-{}&#34;.format(rules_python_version),
    url = &#34;https://github.com/bazelbuild/rules_python/archive/{}.zip&#34;.format(rules_python_version),
)
</code></pre><p>接着，使用rules_python的方式注册工具链，在WORKSPACE里面继续添加内容，如下。这里要注意python对象的执行，用的是这里注册的python环境和对应的python解释器，但是这些对象还是会使用默认的系统级别的python环境和解释器去“初始化”</p>
<pre tabindex="0"><code>load(&#34;@rules_python//python:repositories.bzl&#34;, &#34;python_register_toolchains&#34;)

python_register_toolchains(
    name = &#34;python3_9&#34;,
    # Available versions are listed in @rules_python//python:versions.bzl.
    # We recommend using the same version your team is already standardized on.
    python_version = &#34;3.9&#34;,
)

load(&#34;@python3_9//:defs.bzl&#34;, &#34;interpreter&#34;)

load(&#34;@rules_python//python:pip.bzl&#34;, &#34;pip_parse&#34;)

pip_parse(
    ...
    python_interpreter_target = interpreter,
    ...
)
</code></pre>

<h5 class="relative group">如何引入和使用外部依赖 
    <div id="%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E5%92%8C%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E5%92%8C%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>上一节实际上已经写过了如何引入外部库，这次再重复写一次，不过初始化规则，就是WORKSPACE那部分不多赘述了。注意，这里的对第三方包的管理是一种集中式的管理，我个人比较推崇这种集中化的管理方式。</p>


<h6 class="relative group">集中化管理并引入外部包 
    <div id="%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E5%B9%B6%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%8C%85" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E5%B9%B6%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%8C%85" aria-label="锚点">#</a>
    </span>        
    
</h6>
<p>在WORKSPACE里面写入如下的内容</p>
<pre tabindex="0"><code>load(&#34;@rules_python//python:pip.bzl&#34;, &#34;pip_parse&#34;)

# Create a central repo that knows about the dependencies needed from
# requirements_lock.txt.
pip_parse(
   name = &#34;my_deps&#34;,
   requirements_lock = &#34;//path/to:requirements_lock.txt&#34;,
)
# Load the starlark macro which will define your dependencies.
load(&#34;@my_deps//:requirements.bzl&#34;, &#34;install_deps&#34;)
# Call it to define repos for your requirements.
install_deps()
</code></pre><p>requirements_lock.txt内部只需要写入依赖的python包即可，这里我们写入jira作为对应第三方包就行了</p>
<pre tabindex="0"><code># requirements.txt for Python3 packages
jira
</code></pre>

<h5 class="relative group">使用外部包 
    <div id="%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8C%85" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8C%85" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>参考下面的代码，简单来说就是直接引入requirement并找到对应的依赖即可。外部包就可以直接使用了</p>
<pre tabindex="0"><code>load(&#34;@my_deps//:requirements.bzl&#34;, &#34;requirement&#34;)

py_library(
    name = &#34;mylib&#34;,
    srcs = [&#34;mylib.py&#34;],
    deps = [
        &#34;:myotherlib&#34;,
        requirement(&#34;some_pip_dep&#34;),
        requirement(&#34;another_pip_dep&#34;),
    ]
)
</code></pre>

<h5 class="relative group">实践：使用Bazel管理Python 
    <div id="%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86python" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86python" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>下面的内容，解决了两个问题</p>
<ul>
<li>如何编写python binary对象？</li>
<li>如何引入python的外部依赖库</li>
</ul>


<h6 class="relative group">前提 
    <div id="%E5%89%8D%E6%8F%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%89%8D%E6%8F%90" aria-label="锚点">#</a>
    </span>        
    
</h6>
<p>前提就是引入对rules_python的使用，用bzlmod或者WORKSPACE的方式加载rules_python，简单来说就是写入下面的内容</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

rules_python_version = &#34;740825b7f74930c62f44af95c9a4c1bd428d2c53&#34; # Latest @ 2021-06-23

http_archive(
    name = &#34;rules_python&#34;,
    # Bazel will print the proper value to add here during the first build.
    # sha256 = &#34;FIXME&#34;,
    strip_prefix = &#34;rules_python-{}&#34;.format(rules_python_version),
    url = &#34;https://github.com/bazelbuild/rules_python/archive/{}.zip&#34;.format(rules_python_version),
)
</code></pre>

<h6 class="relative group">如何编写python binary对象 
    <div id="%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99python-binary%E5%AF%B9%E8%B1%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99python-binary%E5%AF%B9%E8%B1%A1" aria-label="锚点">#</a>
    </span>        
    
</h6>
<p>使用rules_python相关规则，即可方便的编写对应的binary和library</p>
<p>首先我们看一下对应的BUILD文件和py文件</p>
<pre tabindex="0"><code>load(&#34;@my_deps//:requirements.bzl&#34;, &#34;requirement&#34;)
load(&#34;@rules_python//python:defs.bzl&#34;, &#34;py_binary&#34;)

py_binary(
    name = &#34;validate_jira_issue&#34;,
    srcs = [&#34;validate_jira_issue.py&#34;],
    deps = [
        requirement(&#34;jira&#34;),
    ],
)
</code></pre><p>validate_jira_issue.py如下，我省略了部分的代码，可以看到这就是一个jira issue的校验代码，除了调用系统提供的基础库之外，还引用了jira的python库。那么问题就来了，怎么安装jira的库呢？使用requirement即可，它会在WORKSPACE初始化阶段自动引入外部依赖（注意，这可能不是最佳实践）</p>
<pre tabindex="0"><code>#!/usr/bin/python3

import argparse
import logging
import os
import re
import sys
import traceback

import requests
from jira import JIRA, JIRAError

...

_JIRA_SERVER_ADDR = &#34;https://daddy.jira.issues.net&#34;
_JIRA_USER = &#34;i am your daddy&#34;


def jira_issue_link_check(jira_issue_text):

    try:
        jira_pass = &#34;who is your daddy?&#34;

        jira_server = JIRA(server=_JIRA_SERVER_ADDR, basic_auth=(_JIRA_USER, jira_pass))
    except Exception as e:
        logging.error(
            &#34;Exception occurred when trying to connect to jira server, check connection?&#34;
        )
        logging.error(traceback.format_exc())
        return False
    else:
        logging.info(&#34;Connection to jira &amp; kms server success,  Congratulations&#34;)

    for issue in issues:
        logging.info(f&#34;Get one jira issue: {issue}&#34;)
        try:
            jira_issue = jira_server.issue(issue.upper())
        except JIRAError as e:
            logging.error(
                f&#34;Does the {issue} really exists? Exception {e.status_code}:{e.text} met &#34;
            )
            return False
        else:
            logging.info(f&#34;Find JIRA issue &#39;{issue}&#39;&#34;)

    return True
...
</code></pre>

<h6 class="relative group">如何引入python的外部依赖库 
    <div id="%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5python%E7%9A%84%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%BA%93" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5python%E7%9A%84%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%BA%93" aria-label="锚点">#</a>
    </span>        
    
</h6>
<p>接下来看下requirement部分怎么实现，在WORKSPACE里面写入如下的内容</p>
<pre tabindex="0"><code>load(&#34;@rules_python//python:pip.bzl&#34;, &#34;pip_parse&#34;)

# Create a central repo that knows about the dependencies needed from
# requirements_lock.txt.
pip_parse(
   name = &#34;my_deps&#34;,
   requirements_lock = &#34;//path/to:requirements_lock.txt&#34;,
)
# Load the starlark macro which will define your dependencies.
load(&#34;@my_deps//:requirements.bzl&#34;, &#34;install_deps&#34;)
# Call it to define repos for your requirements.
install_deps()
</code></pre><p>requirements_lock.txt内部只需要写入依赖的python包即可，这里我们写入jira就行了</p>
<pre tabindex="0"><code># requirements.txt for Python3 packages
jira
</code></pre><p>最后直接bazel build对应的target即可了</p>


<h3 class="relative group">8 使用Bazel管理Go 
    <div id="8-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86go" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#8-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86go" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">Golang规则简介 
    <div id="golang%E8%A7%84%E5%88%99%E7%AE%80%E4%BB%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#golang%E8%A7%84%E5%88%99%E7%AE%80%E4%BB%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>GO的工具链有三个层面， <a href="https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#the-sdk" target="_blank">the SDK</a>, <a href="https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#the-toolchain" target="_blank">the toolchain</a>, 和 <a href="https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#the-context" target="_blank">the context</a>.，一般来说，用户只需要关注SDK层面的事情，比方说外部依赖什么的参考下面的部分</p>


<h5 class="relative group">GO SDK 
    <div id="go-sdk" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#go-sdk" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>SDK说白了就是GO的标准库，工具链的源代码还有一些预编译的库之类的东西。这部分一般是用<a href="https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#go-download-sdk" target="_blank">go_download_sdk</a>来显示地选择一个版本，有一些通用的命令</p>
<ul>
<li><a href="https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#go-download-sdk" target="_blank">go_download_sdk</a>：为特定操作系统和架构下载特定版本 Go 的工具链。</li>
<li><a href="https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#go-host-sdk" target="_blank">go_host_sdk</a>：使用运行 Bazel 的系统上安装的工具链。工具链的位置通过<code>GOROOT</code>或 运行来 指定<code>go env GOROOT</code>。</li>
</ul>
<p>如果想引用1.15.5的GO版本，那么可以在WORKSPACE里面添加下面内容</p>
<pre tabindex="0"><code># WORKSPACE

load(&#34;@io_bazel_rules_go//go:deps.bzl&#34;, &#34;go_rules_dependencies&#34;, &#34;go_register_toolchains&#34;)

go_rules_dependencies()

go_register_toolchains(version = &#34;1.15.5&#34;)
</code></pre><p>如果想用机器安装的GO版本，那么改下为如下的内容</p>
<pre tabindex="0"><code># WORKSPACE

load(&#34;@io_bazel_rules_go//go:deps.bzl&#34;, &#34;go_rules_dependencies&#34;, &#34;go_register_toolchains&#34;)

go_rules_dependencies()

go_register_toolchains(version = &#34;host&#34;)
</code></pre>

<h5 class="relative group">Toolchain 
    <div id="toolchain-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#toolchain-1" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>SDK 特定于主机平台（例如<code>linux_amd64</code>）和 Go 版本，而Tollchain就是解决这个问题，一般来说，运行Bazel构建时，Bazel会根据指定的执行平台和目标平台（分别用&ndash;host_platform和&ndash;platforms选项指定）自动选择已注册的工具链。这样，就无需手动配置工具链，Bazel会自动根据平台的特性和需求选择合适的工具链，以确保构建的正确性和可靠性。</p>
<p>举个例子，很多时候我编译都是直接调用</p>
<pre tabindex="0"><code>bazel build -c opt --platforms=@io_bazel_rules_go//go/toolchain:linux_amd64 //save_money:money
</code></pre>

<h5 class="relative group">Context 
    <div id="context" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#context" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>就是指引用具体的规则，不过这个用户一般不关心，如果要自定义规则才需要使用相关的东西，参考https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#go-context</p>


<h5 class="relative group">引入外部依赖 
    <div id="%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>说起来很简单，首先在WORKSPACE里面添加对gazelle的使用，接着直接使用go_repository即可，</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

# Download the Go rules.
http_archive(
    name = &#34;io_bazel_rules_go&#34;,
    sha256 = &#34;51dc53293afe317d2696d4d6433a4c33feedb7748a9e352072e2ec3c0dafd2c6&#34;,
    urls = [
        &#34;https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.40.1/rules_go-v0.40.1.zip&#34;,
        &#34;https://github.com/bazelbuild/rules_go/releases/download/v0.40.1/rules_go-v0.40.1.zip&#34;,
    ],
)

# Download Gazelle.
http_archive(
    name = &#34;bazel_gazelle&#34;,
    sha256 = &#34;727f3e4edd96ea20c29e8c2ca9e8d2af724d8c7778e7923a854b2c80952bc405&#34;,
    urls = [
        &#34;https://mirror.bazel.build/github.com/bazelbuild/bazel-gazelle/releases/download/v0.30.0/bazel-gazelle-v0.30.0.tar.gz&#34;,
        &#34;https://github.com/bazelbuild/bazel-gazelle/releases/download/v0.30.0/bazel-gazelle-v0.30.0.tar.gz&#34;,
    ],
)

# Load macros and repository rules.
load(&#34;@io_bazel_rules_go//go:deps.bzl&#34;, &#34;go_register_toolchains&#34;, &#34;go_rules_dependencies&#34;)
load(&#34;@bazel_gazelle//:deps.bzl&#34;, &#34;gazelle_dependencies&#34;, &#34;go_repository&#34;)

# Declare Go direct dependencies.
go_repository(
    name = &#34;org_golang_x_net&#34;,
    importpath = &#34;golang.org/x/net&#34;,
    sum = &#34;h1:zK/HqS5bZxDptfPJNq8v7vJfXtkU7r9TLIoSr1bXaP4=&#34;,
    version = &#34;v0.0.0-20200813134508-3edf25e44fcc&#34;,
)

# Declare indirect dependencies and register toolchains.
go_rules_dependencies()

go_register_toolchains(version = &#34;1.20.5&#34;)

gazelle_dependencies()
</code></pre><p>如果希望从原始的go.mod里面导入依赖，用下面的语句就可以直接添加到依赖了</p>
<pre tabindex="0"><code>bazel run //:gazelle update-repos repo-uri
</code></pre><p>如果只想添加Kafka 的 segmentio 的 go client 包，只需要在项目根目录下执行命令：</p>
<pre tabindex="0"><code>bazel run //:gazelle update-repos github.com/segmentio/kafka-g
</code></pre><p>Gazelle 便会自动增加一条依赖到 WORKSPACE 文件：</p>
<pre tabindex="0"><code>go_repository(
    name = &#34;com_github_segmentio_kafka_go&#34;,
    importpath = &#34;github.com/segmentio/kafka-go&#34;,
    sum = &#34;h1:Mv9AcnCgU14/cU6Vd0wuRdG1FBO0HzXQLnjBduDLy70=&#34;,
    version = &#34;v0.3.4&#34;,
)
</code></pre><p>对于Infra同学而言，都写到WORKSPACE中可能会导致WORKSPACE贼大，那么统一组织这些依赖就比较方便：</p>
<p>先创建一个文件，比方说叫做bazel/go_deps.bzl，这个实际上定义了一个go_dependencies的规则，同时定义了大量的第三方依赖包</p>
<pre tabindex="0"><code>load(&#34;@bazel_gazelle//:deps.bzl&#34;, &#34;go_repository&#34;)

def grouped_go_dependencies():
    go_repository(
        name = &#34;com_github_golang_glog&#34;,
        build_file_proto_mode = &#34;disable_global&#34;,
        importpath = &#34;github.com/golang/glog&#34;,
        sum = &#34;h1:nfP3RFugxnNRyKgeWd4oI1nYvXpxrx8ck8ZrcizshdQ=&#34;,
        version = &#34;v1.0.0&#34;,
    )
</code></pre><p>在WORKSPACE里面写入下面的内容，实际上就是展开了grouped_go_dependencies规则，也就是把各种go_repository写在了Workspace里面，当然本质还是没变</p>
<pre tabindex="0"><code>load(&#34;@bazel_gazelle//:deps.bzl&#34;, &#34;gazelle_dependencies&#34;)
load(&#34;//bazel:go_deps.bzl&#34;, &#34;grouped_go_dependencies&#34;)

grouped_go_dependencies()
</code></pre>

<h4 class="relative group">实践：Bazel管理Golang 
    <div id="%E5%AE%9E%E8%B7%B5bazel%E7%AE%A1%E7%90%86golang" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E8%B7%B5bazel%E7%AE%A1%E7%90%86golang" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>两个部分，第一个部分适用于从头开始写基于Bazel的Go代码，第二个适用于从GO原生的go build切换到Bazel的情况。</p>


<h5 class="relative group">使用原生的方式编写GO Target 
    <div id="%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99go-target" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99go-target" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>首先要引入对rules_go的支持，在WORKSPACE文件当中写入下面的内容，使用 <a href="https://docs.bazel.build/versions/master/repo/git.html" target="_blank">git_repository</a> 替代 <a href="https://docs.bazel.build/versions/master/repo/http.html#http_archive" target="_blank">http_archive</a> 也可以，不过http_archive提供了sha256，方便缓存</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

http_archive(
    name = &#34;io_bazel_rules_go&#34;,
    sha256 = &#34;51dc53293afe317d2696d4d6433a4c33feedb7748a9e352072e2ec3c0dafd2c6&#34;,
    urls = [
        &#34;https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.40.1/rules_go-v0.40.1.zip&#34;,
        &#34;https://github.com/bazelbuild/rules_go/releases/download/v0.40.1/rules_go-v0.40.1.zip&#34;,
    ],
)

load(&#34;@io_bazel_rules_go//go:deps.bzl&#34;, &#34;go_register_toolchains&#34;, &#34;go_rules_dependencies&#34;)

go_rules_dependencies()

go_register_toolchains(version = &#34;1.20.5&#34;)
</code></pre><p>接下来，新建一个BUILD文件，并开发对应的go代码，最后bazel build 即可</p>
<pre tabindex="0"><code>load(&#34;@io_bazel_rules_go//go:def.bzl&#34;, &#34;go_binary&#34;)

go_binary(
    name = &#34;hello&#34;,
    srcs = [&#34;hello.go&#34;],
)
</code></pre>

<h5 class="relative group">迁移原始GO代码到Bazel 
    <div id="%E8%BF%81%E7%A7%BB%E5%8E%9F%E5%A7%8Bgo%E4%BB%A3%E7%A0%81%E5%88%B0bazel" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%81%E7%A7%BB%E5%8E%9F%E5%A7%8Bgo%E4%BB%A3%E7%A0%81%E5%88%B0bazel" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>从GO迁移到Bazel自然可以直接手写对应的BUILD文件，比较麻烦，推荐使用gazelle来解决这个问题</p>
<p>在WORKSPACE里面添加gazelle</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

http_archive(
    name = &#34;io_bazel_rules_go&#34;,
    sha256 = &#34;51dc53293afe317d2696d4d6433a4c33feedb7748a9e352072e2ec3c0dafd2c6&#34;,
    urls = [
        &#34;https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.40.1/rules_go-v0.40.1.zip&#34;,
        &#34;https://github.com/bazelbuild/rules_go/releases/download/v0.40.1/rules_go-v0.40.1.zip&#34;,
    ],
)

http_archive(
    name = &#34;bazel_gazelle&#34;,
    sha256 = &#34;727f3e4edd96ea20c29e8c2ca9e8d2af724d8c7778e7923a854b2c80952bc405&#34;,
    urls = [
        &#34;https://mirror.bazel.build/github.com/bazelbuild/bazel-gazelle/releases/download/v0.30.0/bazel-gazelle-v0.30.0.tar.gz&#34;,
        &#34;https://github.com/bazelbuild/bazel-gazelle/releases/download/v0.30.0/bazel-gazelle-v0.30.0.tar.gz&#34;,
    ],
)

load(&#34;@io_bazel_rules_go//go:deps.bzl&#34;, &#34;go_register_toolchains&#34;, &#34;go_rules_dependencies&#34;)
load(&#34;@bazel_gazelle//:deps.bzl&#34;, &#34;gazelle_dependencies&#34;)

go_rules_dependencies()

go_register_toolchains(version = &#34;1.20.5&#34;)

gazelle_dependencies()
</code></pre><p>接着，在代码的根目录添加一个BUILD.bazel，把prefix后面的那个字符串，就是那个什么github.comxxx啥的东西，替换为原始项目的import path，也就是 <code>go.mod</code> 里面的部分</p>
<pre tabindex="0"><code>load(&#34;@bazel_gazelle//:def.bzl&#34;, &#34;gazelle&#34;)

# gazelle:prefix github.com/example/project
gazelle(name = &#34;gazelle&#34;)
</code></pre><p>接着执行，就会生成具体的BUILD文件。</p>
<pre tabindex="0"><code>bazel run //:gazelle
</code></pre>

<h3 class="relative group">9 使用Bazel管理Shell 
    <div id="9-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86shell" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#9-%E4%BD%BF%E7%94%A8bazel%E7%AE%A1%E7%90%86shell" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>作为胶水语言，有的时候还确实需要bazel去缓存一些执行的结果，比方说我希望bazel执行一些操作，然后输出结果，那肯定得拿shell粘起来。</p>
<p>下面的内容是一个sh_test对象，bazel还支持sh_binary，同样的道理。</p>
<p>直接看BUILD文件怎么写的，声明了一个run_compare对象，核心是run_sompare.sh脚本，依赖了shflags功能，shflags（https://github.com/kward/shflags）实际上是个类似gflags的shell版本实现</p>
<pre tabindex="0"><code>package(default_visibility = [&#34;//visibility:public&#34;])

sh_library(
    name = &#34;sh_flags&#34;,
    data = [&#34;shflags&#34;],
)

sh_test(
    name = &#34;run_compare&#34;,
    size = &#34;medium&#34;,
    srcs = [&#34;run_compare.sh&#34;],
    data = [
        &#34;//save_money/compare:jandan&#34;,
    ],
    tags = [&#34;manual&#34;],
    # Notes: deps should only be sh_library,
    # other depends such as cc_binary and data should include in data field
    deps = [
        &#34;:sh_flags&#34;,
    ],
)
</code></pre><p>这里可能需要注意下data属性，data属性提供了shell内部要直接调用的bazel target，这个和脚本是强关联的，脚本里面调用了什么对象，都需要加到这里，可以看到下面的脚本就是直接调用了save_money/compare/jandan。</p>
<p>而shflags是所谓shell source的对象，放到了deps里面，这个是用户写shell需要注意的情况</p>
<pre tabindex="0"><code>TOP_DIR=&#34;$(cd &#34;$(dirname &#34;${BASH_SOURCE[0]}&#34;)/..&#34; &amp;&amp; pwd -P)&#34;
source &#34;${TOP_DIR}/shflags&#34;

DEFINE_boolean &#39;chinese&#39; &#34;${FLAGS_FALSE}&#34; &#39;If true, use save chinese yuan.&#39;
DEFINE_boolean &#39;US&#39; &#34;${FLAGS_TRUE}&#34; &#39;If true, save us dollar.&#39;

# Parse the command-line.
FLAGS &#34;$@&#34; || exit 1
eval set -- &#34;${FLAGS_ARGV}&#34;

set -e

echo &#34;Envoking save money mode&#34;
save_money/compare/jandan ${FLAGS_chinese} ${FLAGS_US}
</code></pre><p>最后直接调用bazel run就可以执行具体的shell target了。</p>


<h3 class="relative group">10 引入第三方库 
    <div id="10-%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#10-%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>首先依然推荐阅读官方文档https://bazel.build/external/overview，伴随着Bazel 6.0的发布，目前有两种方法来引入第三方库，一种是传统的写到Workspace的方法，另一种是Bzlmod的方法。注意，永远都是推荐新的方式即Bzlmod的方式来import第三方库。</p>


<h4 class="relative group">传统方法 
    <div id="%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>传统方法讲究化劲，接，化，发！。。。不好意思，走错片场了。。。。</p>


<h5 class="relative group">实现方法 
    <div id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>理解传统方式需要首先明白以下几个概念</p>
<ul>
<li>代码库：包含<code>WORKSPACE</code>带有或文件的目录<code>WORKSPACE.bazel</code>，包含 Bazel 构建中使用的源文件的一些列文件的组织，称为代码库。代码库不是只针对下面的主仓库，第三方库也是代码库。</li>
<li>主仓库： 这个不用多说了，真正的执行Bazel 命令的代码库。</li>
<li>WorkSpace:工作区间，也是所有 Bazel 命令共享的环境。</li>
<li>代码库规则：（第三方）代码库库定义的模式，告诉 Bazel 如何获取代码库。例如，它可以是“从某个 URL 下载 zip 存档并解压它”，或者“获取某个 Maven 工件并使其可用作目标 <code>java_import</code>”，或者只是“符号链接本地目录”。每个存储库都是 通过使用适当数量的参数调用存储库规则来**定义的。**到目前为止，最常见的存储库规则是 <a href="https://bazel.build/rules/lib/repo/http#http_archive" target="_blank"><code>http_archive</code></a>，它从 URL 下载存档并提取它，以及 <a href="https://bazel.build/reference/be/workspace#local_repository" target="_blank"><code>local_repository</code></a>，它符号链接已经是 Bazel 存储库的本地目录。</li>
</ul>
<p>简单来讲，传统方式可以认为就是http_archive，官方给的例子如下，引入foo作为外部依赖。</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)
http_archive(
    name = &#34;foo&#34;,
    urls = [&#34;https://example.com/foo.zip&#34;],
    sha256 = &#34;c9526390a7cd420fdcec2988b4f3626fe9c5b51e2959f685e8f4d170d1a9bd96&#34;,
)
</code></pre><p>举个简单例子，在WORKSPACE文件内写入下面的内容，之后在对应依赖grpc的BUILD文件里面写入相应的依赖项即可使用该grpc外部依赖，比方说glog的引入也是同样的道理。其中strip_prefix用来去除解压的文件夹前缀。</p>
<pre tabindex="0"><code>version = &#34;1.xx.x&#34;
http_archive(
    name = &#34;com_github_grpc_grpc&#34;,
    strip_prefix = &#34;grpc-{}&#34;.format(version),
    sha256 = &#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#34;,
    urls = [
        &#34;https://xxxxxxxxxxxxxxxxx/grpc-{}.tar.gz&#34;.format(version),
        &#34;https://xxxxxxxxxxxxxxxxxxx{}.tar.gz&#34;.format(version),
    ],
    patch_args = [&#34;-p1&#34;],
    patches = [
        clean_dep(&#34;//third_party/grpc:p01xxxxxxxxxxxxx.patch&#34;),
        clean_dep(&#34;//third_party/grpc:p02xxxxxxxxxxxxx.patch&#34;),
        clean_dep(&#34;//third_party/grpc:p03xxxxxxxxxxxxx.patch&#34;),
    ],
)
</code></pre><p>真正使用依赖的时候如下图所示</p>
<pre tabindex="0"><code>cc_binary(
    name = &#34;grpc_test_main&#34;,
    testonly = True,
    srcs = [
        &#34;grpc_test_main.cc&#34;,
    ],
    deps = [
        &#34;//xxxxx/proto:grpc_test_main&#34;,
        &#34;@com_github_google_glog//:glog&#34;,
        &#34;@com_github_grpc_grpc//:grpc++&#34;,
    ],
)
</code></pre>

<h5 class="relative group">缺陷 
    <div id="%E7%BC%BA%E9%99%B7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BC%BA%E9%99%B7" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>传统方式有几种不足</p>
<ul>
<li>Bazel的WORKSPACE级别的外部依赖只能是一个依赖链，不存在灵活的选择。</li>
<li>为了绕开这一点，bazel要求用户自己实现宏来选择外部依赖，宏不能灵活load .bzl文件，因此需要用户多次宣式指定依赖，而显示依赖实际上是缺乏版本信息的，简单来说，http_archive是没有（显式）版本信息的。</li>
</ul>


<h4 class="relative group">bzlmod方法 
    <div id="bzlmod%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bzlmod%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>WORKSPACE文件这么写</p>
<pre tabindex="0"><code>load(&#34;@bazel_tools//tools/build_defs/repo:http.bzl&#34;, &#34;http_archive&#34;)

http_archive(
    name = &#34;com_github_google_glog&#34;,
    sha256 = &#34;eede71f28371bf39aa69b45de23b329d37214016e2055269b3b5e7cfd40b59f5&#34;,
    strip_prefix = &#34;glog-0.5.0&#34;,
    urls = [&#34;https://github.com/google/glog/archive/refs/tags/v0.5.0.tar.gz&#34;],
)

# We have to define gflags as well because it&#39;s a dependency of glog.
http_archive(
    name = &#34;com_github_gflags_gflags&#34;,
    sha256 = &#34;34af2f15cf7367513b352bdcd2493ab14ce43692d2dcd9dfc499492966c64dcf&#34;,
    strip_prefix = &#34;gflags-2.2.2&#34;,
    urls = [&#34;https://github.com/gflags/gflags/archive/refs/tags/v2.2.2.tar.gz&#34;],
)
</code></pre><p>在附加一个<a href="https://github.com/bazelbuild/examples/blob/main/bzlmod/01-depend_on_bazel_module/MODULE.bazel" target="_blank">MODULE.bazel</a>文件</p>
<pre tabindex="0"><code># 1. The metadata of glog is fetched from the BCR, including its dependencies (gflags).
# 2. The `repo_name` attribute allows users to reference this dependency via the `com_github_google_glog` repo name.
bazel_dep(name = &#34;glog&#34;, version = &#34;0.5.0&#34;, repo_name = &#34;com_github_google_glog&#34;)
</code></pre><p>编译的时候，添加属性&ndash;enable_bzelmod即可，并在对应的BUILD文件添加依赖</p>
<pre tabindex="0"><code>build --enable_bzlmod
</code></pre>

<h3 class="relative group">原理分析 
    <div id="%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>Bazel的bzlmod使用类似GO的<a href="https://research.swtch.com/vgo-mvs" target="_blank">Minimal Version Selection</a> (MVS) 算法，即MVS 假设所有依赖满足前向兼容性，因此挑选第一个满足所有兼容性要求的版本。对这个图里面的例子，会选择1.1的D版本。如果有1.2的D版本，也会用1.1的版本。</p>
<pre tabindex="0"><code>       A 1.0
      /     \
   B 1.0    C 1.1
     |        |
   D 1.0    D 1.1
</code></pre>

<h3 class="relative group">11 Bazel代码管理最佳实践 
    <div id="11-bazel%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#11-bazel%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>好了，下面给一下曾经用bazel管理代码库的时候的最佳实践</p>
<p>下面的内容是一些提供给Infra或者普通用户的建议，这些规则可以使得CI或者研发的平时工作轻松很多。</p>


<h4 class="relative group">开放用户自定配置 
    <div id="%E5%BC%80%E6%94%BE%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E9%85%8D%E7%BD%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BC%80%E6%94%BE%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E9%85%8D%E7%BD%AE" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>有的时候Infra会提供一套通用的配置给研发使用，但是不同研发的本地环境不同，需要一些个性化且不被track到代码库的配置，可以在.bazelrc里面加上</p>
<pre tabindex="0"><code>try-import %workspace%/user.bazelrc
</code></pre><p>从而方便用户可以自己制定user.bazelrc里面的内容，最常见的使用情况就是并发的action数量控制，我们遇到过的是并发数量太高，用户电脑卡死了。。。</p>


<h4 class="relative group">尽量使用源码编译 
    <div id="%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>对于C或C++软件，一个经常遇到的问题就是引用了不该用的库，或者是版本错误，或者是符号重名。这种情况下，推荐尽量用源码来管理第三方库，从而避免使用预定义的库可能带来的编译flag不一致的问题。这几天就遇到一个问题，有一个库内部打包了一个外部libcurl，(srcs=&ldquo;libcurl.so&rdquo;)然后打出来的包同时包含了系统的libcurl和这个libcurl，然后程序只要一启动就crash。</p>
<p>一部分人，那我不得所有依赖都得自己用源码管理吗？的确如此，毕竟只要用prebuild库，就始终有兼容性风险。</p>


<h4 class="relative group">整个源码库可构建 
    <div id="%E6%95%B4%E4%B8%AA%E6%BA%90%E7%A0%81%E5%BA%93%E5%8F%AF%E6%9E%84%E5%BB%BA" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B4%E4%B8%AA%E6%BA%90%E7%A0%81%E5%BA%93%E5%8F%AF%E6%9E%84%E5%BB%BA" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一般情况下整个源代码仓库可以直接调用<code>bazel build //...</code> 和 <code>bazel test //...，</code>对于CI的同学这种方式会简化管理难度。</p>


<h4 class="relative group">尽量明确依赖而不是混杂依赖 
    <div id="%E5%B0%BD%E9%87%8F%E6%98%8E%E7%A1%AE%E4%BE%9D%E8%B5%96%E8%80%8C%E4%B8%8D%E6%98%AF%E6%B7%B7%E6%9D%82%E4%BE%9D%E8%B5%96" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B0%BD%E9%87%8F%E6%98%8E%E7%A1%AE%E4%BE%9D%E8%B5%96%E8%80%8C%E4%B8%8D%E6%98%AF%E6%B7%B7%E6%9D%82%E4%BE%9D%E8%B5%96" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>我们实践中遇到一个大坑是，一些用户会把不该汇总到一起的东西放到一起，它会用glob写出来一个如下语句，并最终把这个大包裹汇聚给外面。</p>
<pre tabindex="0"><code>glob([&#34;**/**&#34;])
</code></pre><p>这个BUILD文件所在目录包含模型，音频，xml文件，有很多的TEST只用音频，反而还打包一堆模型，从而导致多了很多不必要的依赖和拷贝操作。</p>


<h4 class="relative group">BUILD文件不要跨级 
    <div id="build%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A6%81%E8%B7%A8%E7%BA%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#build%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A6%81%E8%B7%A8%E7%BA%A7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一般情况下BUILD文件应该只管理当前目录的文件，不应该管理下级目录，如果真的需要管理下级目录，需要考虑文件的位置分布是否合理，是不是可以去掉没用的文件层级</p>


<h4 class="relative group">常用选项 
    <div id="%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ul>
<li>控制action并发数量build &ndash;jobs=xx</li>
<li>控制是否强行重跑某个test时，指定&ndash;nocache_test_results，即不利用缓存。排查flaky的问题很有用。cache_test_results本来是用来判断是否缓存test结果的</li>
<li>只做远端编译，不下载文件&ndash;<a href="https://bazel.build/reference/command-line-reference#flag--remote_download_minimal" target="_blank">remote_download_minimal</a></li>
<li>有时候做bazel test，希望看到test的完整输出，<a href="https://bazel.build/reference/command-line-reference#flag--test_output" target="_blank">&ndash;test_output</a>=&lt;summary, errors, all or streamed&gt;指定为streamed即可。不过这个会强制rerun test</li>
<li>有时候做query或者build，希望遇到错误不停止，加上<a href="https://bazel.build/reference/command-line-reference#flag--keep_going" target="_blank"><code>--[no\]keep_going</code></a> [<code>-k</code>] default: &ldquo;false&rdquo;</li>
<li>在CI的环境，很多时候可以反向依赖查找出来改动影响到哪些target，之后针对这些target做编译。可是有个问题，这些target在明确指定的情况下，可能是不兼容的目标平台target。可以加上&ndash;skip_incompatible_explicit_targets来显示忽略，从而降低CI的工作量</li>
</ul>


<h2 class="relative group">中级 
    <div id="%E4%B8%AD%E7%BA%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%AD%E7%BA%A7" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>好了，下面我们来到了中级篇，看一些bazel除了构建代码之后，集成一些复杂的代码检查应该怎么做。</p>


<h3 class="relative group">12 Bazel Platform与可配置项 
    <div id="12-bazel-platform%E4%B8%8E%E5%8F%AF%E9%85%8D%E7%BD%AE%E9%A1%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#12-bazel-platform%E4%B8%8E%E5%8F%AF%E9%85%8D%E7%BD%AE%E9%A1%B9" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">可配置选项与select 
    <div id="%E5%8F%AF%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E4%B8%8Eselect" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8F%AF%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E4%B8%8Eselect" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p><em><strong>可配置属性</strong></em>（通常称为<a href="https://bazel.build/reference/be/functions#select" target="_blank"><code>select()</code></a>）是 Bazel 的一项功能，允许用户在命令行切换构建规则属性的值。</p>
<pre tabindex="0"><code># myapp/BUILD

cc_binary(
    name = &#34;mybinary&#34;,
    srcs = [&#34;main.cc&#34;],
    deps = select({
        &#34;:arm_build&#34;: [&#34;:arm_lib&#34;],
        &#34;:x86_debug_build&#34;: [&#34;:x86_dev_lib&#34;],
        &#34;//conditions:default&#34;: [&#34;:generic_lib&#34;],
    }),
)

config_setting(
    name = &#34;arm_build&#34;,
    values = {&#34;cpu&#34;: &#34;arm&#34;},
)

config_setting(
    name = &#34;x86_debug_build&#34;,
    values = {
        &#34;cpu&#34;: &#34;x86&#34;,
        &#34;compilation_mode&#34;: &#34;dbg&#34;,
    },
)
</code></pre><p>接下来可以看下，对应的配置选项会怎么触发怎样编译依赖的选择。</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>依赖最终选择</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>bazel build //myapp:mybinary --cpu=arm</code></td>
          <td><code>[&quot;:arm_lib&quot;]</code></td>
      </tr>
      <tr>
          <td><code>bazel build //myapp:mybinary -c dbg --cpu=x86</code></td>
          <td><code>[&quot;:x86_dev_lib&quot;]</code></td>
      </tr>
      <tr>
          <td><code>bazel build //myapp:mybinary --cpu=ppc</code></td>
          <td><code>[&quot;:generic_lib&quot;]</code></td>
      </tr>
      <tr>
          <td><code>bazel build //myapp:mybinary -c dbg --cpu=ppc</code></td>
          <td><code>[&quot;:generic_lib&quot;]</code></td>
      </tr>
  </tbody>
</table>
<p><code>select()</code><em>用用来根据情况选择不同的配置，简单来说就是选择</em> <a href="https://bazel.build/reference/be/general#config_setting" target="_blank"><code>config_setting</code></a> 中的细节。注意select是具有传递性的，如果top level启用了某种配置，这个配置会传递到下层的依赖当中。</p>
<p><code>select</code>可以组合，但是不能递归</p>
<pre tabindex="0"><code>sh_binary(
    name = &#34;my_target&#34;,
    srcs = [&#34;always_include.sh&#34;] +
           select({
               &#34;:armeabi_mode&#34;: [&#34;armeabi_src.sh&#34;],
               &#34;:x86_mode&#34;: [&#34;x86_src.sh&#34;],
           }) +
           select({
               &#34;:opt_mode&#34;: [&#34;opt_extras.sh&#34;],
               &#34;:dbg_mode&#34;: [&#34;dbg_extras.sh&#34;],
           }),
)
</code></pre>

<h4 class="relative group">select的细节语法 
    <div id="select%E7%9A%84%E7%BB%86%E8%8A%82%E8%AF%AD%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#select%E7%9A%84%E7%BB%86%E8%8A%82%E8%AF%AD%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>select支持多种写法</p>
<ul>
<li>
<p>selects.with_or语法，一种多种情况使用相同配置的简单写法</p>
<pre tabindex="0"><code>sh_binary(
    name = &#34;my_target&#34;,
    srcs = [&#34;always_include.sh&#34;],
    deps = selects.with_or({
        (&#34;:config1&#34;, &#34;:config2&#34;, &#34;:config3&#34;): [&#34;:standard_lib&#34;],
        &#34;:config4&#34;: [&#34;:special_lib&#34;],
    }),
)
</code></pre></li>
<li>
<p>selects.config_setting_group，同样是多种匹配任何一种的情况</p>
<pre tabindex="0"><code>config_setting(
    name = &#34;config1&#34;,
    values = {&#34;cpu&#34;: &#34;arm&#34;},
)
config_setting(
    name = &#34;config2&#34;,
    values = {&#34;compilation_mode&#34;: &#34;dbg&#34;},
)
selects.config_setting_group(
    name = &#34;config1_or_2&#34;,
    match_any = [&#34;:config1&#34;, &#34;:config2&#34;],
)
sh_binary(
    name = &#34;my_target&#34;,
    srcs = [&#34;always_include.sh&#34;],
    deps = select({
        &#34;:config1_or_2&#34;: [&#34;:standard_lib&#34;],
        &#34;//conditions:default&#34;: [&#34;:other_lib&#34;],
    }),
)
</code></pre></li>
<li>
<p>AND chaining，用来同时匹配多种的情况</p>
<pre tabindex="0"><code>config_setting(
    name = &#34;config1&#34;,
    values = {&#34;cpu&#34;: &#34;arm&#34;},
)
config_setting(
    name = &#34;config2&#34;,
    values = {&#34;compilation_mode&#34;: &#34;dbg&#34;},
)
selects.config_setting_group(
    name = &#34;config1_and_2&#34;,
    match_all = [&#34;:config1&#34;, &#34;:config2&#34;],
)
sh_binary(
    name = &#34;my_target&#34;,
    srcs = [&#34;always_include.sh&#34;],
    deps = select({
        &#34;:config1_and_2&#34;: [&#34;:standard_lib&#34;],
        &#34;//conditions:default&#34;: [&#34;:other_lib&#34;],
    }),
)
</code></pre></li>
</ul>


<h3 class="relative group"> 
    <div id="" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">Platforms 
    <div id="platforms" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#platforms" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>platform是用来方便地组合和索引多配置的方法，简单来说可以认为多种属性构成了平台（反过来，多平台构成了属性）。简单来说可以认为platform是下面的组合</p>
<p><code>config_setting</code> 用来提供可选择的配置。</p>
<p><code>constraint_setting</code> 用来表示一种配置属性，可以认为这个就是枚举类型</p>
<p><code>constraint_value</code> 用来支持<a href="https://bazel.build/configure/attributes#platforms" target="_blank">multi-platform behavior</a>，这个可以认为是一种枚举类型的值</p>
<pre tabindex="0"><code># myapp/BUILD

sh_binary(
    name = &#34;my_rocks&#34;,
    srcs = select({
        &#34;:basalt&#34;: [&#34;pyroxene.sh&#34;],
        &#34;:marble&#34;: [&#34;calcite.sh&#34;],
        &#34;//conditions:default&#34;: [&#34;feldspar.sh&#34;],
    }),
)

config_setting(
    name = &#34;basalt&#34;,
    constraint_values = [
        &#34;:black&#34;,
        &#34;:igneous&#34;,
    ],
)

config_setting(
    name = &#34;marble&#34;,
    constraint_values = [
        &#34;:white&#34;,
        &#34;:metamorphic&#34;,
    ],
)

# constraint_setting acts as an enum type, and constraint_value as an enum value.
constraint_setting(name = &#34;color&#34;)
constraint_value(name = &#34;black&#34;, constraint_setting = &#34;color&#34;)
constraint_value(name = &#34;white&#34;, constraint_setting = &#34;color&#34;)
constraint_setting(name = &#34;texture&#34;)
constraint_value(name = &#34;smooth&#34;, constraint_setting = &#34;texture&#34;)
constraint_setting(name = &#34;type&#34;)
constraint_value(name = &#34;igneous&#34;, constraint_setting = &#34;type&#34;)
constraint_value(name = &#34;metamorphic&#34;, constraint_setting = &#34;type&#34;)

platform(
    name = &#34;basalt_platform&#34;,
    constraint_values = [
        &#34;:black&#34;,
        &#34;:igneous&#34;,
    ],
)

platform(
    name = &#34;marble_platform&#34;,
    constraint_values = [
        &#34;:white&#34;,
        &#34;:smooth&#34;,
        &#34;:metamorphic&#34;,
    ],
)
</code></pre><p>下面的命令，即编译“大理石”平台</p>
<pre tabindex="0"><code>bazel build //my_app:my_rocks --platforms=//myapp:marble_platform
</code></pre><p>就等同于下面的配置</p>
<pre tabindex="0"><code>bazel build //my_app:my_rocks --define color=white --define texture=smooth --define type=metamorphic
</code></pre>

<h4 class="relative group">Bazel的Platforms 
    <div id="bazel%E7%9A%84platforms" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bazel%E7%9A%84platforms" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>上面介绍了基本的语法，现在看看这东西组合出来做什么，下面的概念在Toolchain部分才有用，如果不想理解也可以先不看。</p>
<p>Bazel可以在各种不同的硬件、操作系统和系统配置上构建和测试代码，使用多种不同版本的链接器和编译器等构建工具。为了管理这种复杂性，Bazel引入了<code>constraint</code>（约束）和平台的概念。约束是是指构建或者生产环境可能不同的地方，例如CPU架构（Darwin，XXX）、是否存在GPU或系统安装的编译器版本。平台是这些约束的集合，表示某个环境中可用的特定资源。</p>
<p>Bazel将平台区分为三种：</p>
<ol>
<li><strong>Host（<strong>主机</strong>）</strong> - 运行Bazel的平台，比方说我现在做编译，我在本地起了一个bazel，bazel cli启动了一个java进程，这个启动java进程的机器或者说当前的系统，就是Host</li>
<li><strong>Execution（<strong>执行</strong>）</strong> - 构建工具在其中执行构建操作以生成中间和最终输出的平台，书接上文，java进程分析好了DAG（有向无环图），拆解为多个Action，如果后台启用了Buildfarm远程执行服务，这些Action就会被分配到这些Buildfarm真正的机器上执行，这些真正执行构建的机器，就是Execution</li>
<li>**Target(**目标) - 最终输出所在的平台，并在其中执行。继续举例，我比方说在X86编译出来了一个软件，这个软件在ARM平台执行，那么最终执行的平台就是Target平台</li>
</ol>
<p>关于平台，Bazel支持以下构建场景：</p>
<ol>
<li>单平台构建（默认）- 主机、执行和目标平台相同。例如，在运行在Intel x64 CPU上的Ubuntu上构建Linux可执行文件。</li>
<li>交叉编译构建 - 主机和执行平台相同，但目标平台不同。例如，在运行在MacBook Pro上的macOS上构建iOS应用程序。</li>
<li>多平台构建 - 主机、执行和目标平台都不同。</li>
</ol>
<p>对于一部分monorepo而言，内部混杂了诸如X86（X86内部可能还按照CPU架构拆分的更细），ARM64的平台，这些代码库构建的时候都是指定了某种具体的平台，然后对某种pattern的内部package做构建。如果命令行里匹配的模式命中了某个被认为不兼容的目标，目标会自动将被跳过。例如，以下两个调用会跳过目标模式扩展中发现的任何不兼容目标。</p>
<pre tabindex="0"><code>$ bazel build --platforms=//:myplatform //...
</code></pre><pre tabindex="0"><code>$ bazel build --platforms=//:myplatform //:all
</code></pre><p><a href="https://bazel.build/reference/be/general#test_suite" target="_blank"><code>test_suite</code></a>如果<code>test_suite</code>在命令行上用 指定 ， 则类似地会跳过a 中不兼容的测试<a href="https://bazel.build/reference/command-line-reference#flag--expand_test_suites" target="_blank"><code>--expand_test_suites</code></a>。换句话说，<code>test_suite</code>命令行上的目标的行为类似于<code>:all</code>和 <code>...</code>。使用<code>--noexpand_test_suites</code>会阻止扩展并导致 <code>test_suite</code>具有不兼容测试的目标也不兼容。</p>
<p>在命令行上显式指定不兼容的目标会导致错误消息和构建失败。</p>
<pre tabindex="0"><code>$ bazel build --platforms=//:myplatform //:target_incompatible_with_myplatform
...
ERROR: Target //:target_incompatible_with_myplatform is incompatible and cannot be built, but was explicitly requested.
...
FAILED: Build did NOT complete successfully
</code></pre><p>如果启用<code>--skip_incompatible_explicit_targets</code>，不兼容的显式目标将被静默跳过 ，这就给提供了一种对CI很方便的bazel构建用法，我可以先bazel query反向依赖查出来修改的东西涉及到的文件，然后再全部编译，并且加上<code>--skip_incompatible_explicit_targets</code> flag，这样子，编译错误就不会被平台不兼容的错误所掩盖。</p>
<p>不过这个是bazel 7.0.0才支持。</p>
<p>如果想指定配置来检查改动设计哪些目标，可以用bazel cquery</p>


<h3 class="relative group">13 Bazel Query和Aquery 
    <div id="13-bazel-query%E5%92%8Caquery" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#13-bazel-query%E5%92%8Caquery" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">14 Bazel集成Clang-Tidy 
    <div id="14-bazel%E9%9B%86%E6%88%90clang-tidy" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#14-bazel%E9%9B%86%E6%88%90clang-tidy" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>Clang-Tidy是基于Clang的C++ Lint工具，用于检查C++代码中的常见编码错误，执行代码静态分析等，和Bazel的继承使用了bazel的aspect机制实现，建议直接阅读https://github.com/erenon/bazel_clang_tidy</p>
<p>为啥需要clang-tidy呢？原因很简单，针对语言层面的安全检查是SAST实践的核心。因此怎么在Bazel上集成clang-tidy就变成一种通用的手段，本质是使用Bazel提供的Aspect。</p>
<p>这种方式的好处有三个</p>
<ul>
<li>可以针对任意的C++对象执行clang-tidy</li>
<li>因为用的是bazel的aspect，所以实际上并没有做真正的构建。直接调用clang-tidy对per文件做分析</li>
<li>Bazel会缓存clang-tidy 的结果，如果文件没变化，那么clang-tidy不会重新运行。</li>
</ul>


<h4 class="relative group">使用方法 
    <div id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在WORKSPACE里面添加代码</p>
<pre tabindex="0"><code># //:WORKSPACE
load(
    &#34;@bazel_tools//tools/build_defs/repo:git.bzl&#34;,
    &#34;git_repository&#34;,
)

git_repository(
       name = &#34;bazel_clang_tidy&#34;,
       commit = &#34;69aa13e6d7cf102df70921c66be15d4592251e56&#34;,
       remote = &#34;https://github.com/erenon/bazel_clang_tidy.git&#34;,
)
</code></pre><p>具体调用可以直接显式使用aspect调用，或者修改.bazelrc，贴到了最下面</p>
<pre tabindex="0"><code>bazel build //... \
  --aspects @bazel_clang_tidy//clang_tidy:clang_tidy.bzl%clang_tidy_aspect \
  --output_groups=report
</code></pre><p>修改bazelrc如下，然后直接调用tidy配置即可</p>
<pre tabindex="0"><code>```ini
build:tidy --aspects //bazel/clang_tidy:clang_tidy.bzl%clang_tidy_aspect
build:tidy --build_tag_filters=-no-tidy
build:tidy --output_groups=report

```
</code></pre><pre tabindex="0"><code>bazel build --config=tidy //...
</code></pre><p>接下来就会针对build的对象启动clang-tidy的检查。</p>
<p>我们都非常清楚，clang-tidy是一个复杂检查，其中有很多种的checker可以开启，如果需要配置clang-tidy的config，可以添加一个新的配置文件，调用的时候使用第二条命令。</p>
<pre tabindex="0"><code># //:BUILD
filegroup(
       name = &#34;clang_tidy_config&#34;,
       srcs = [&#34;.clang-tidy&#34;],
       visibility = [&#34;//visibility:public&#34;],
)
</code></pre><pre tabindex="0"><code>bazel build //... \
  --aspects @bazel_clang_tidy//clang_tidy:clang_tidy.bzl%clang_tidy_aspect \
  --output_groups=report \
  --@bazel_clang_tidy//:clang_tidy_config=//:clang_tidy_config
</code></pre>

<h3 class="relative group">15 Bazel集成Lint 
    <div id="15-bazel%E9%9B%86%E6%88%90lint" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#15-bazel%E9%9B%86%E6%88%90lint" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">16 Bazel生成Compile Database 
    <div id="16-bazel%E7%94%9F%E6%88%90compile-database" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#16-bazel%E7%94%9F%E6%88%90compile-database" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>很多第三方SAST检查工具，比方说CODECHECKER，都需要生成compile database来获取具体的编译行为，从而从语义的角度检查代码上下文是否符合一些通用的安全开发准则。因此了解如何在bazel体系生成compile database就很有必要性。</p>


<h3 class="relative group"> 
    <div id="" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>以https://github.com/grailbio/bazel-compilation-database为例</p>
<p>添加如下内容在WORKSPACE里面</p>
<pre tabindex="0"><code>http_archive(
    name = &#34;com_grail_bazel_compdb&#34;,
    strip_prefix = &#34;bazel-compilation-database-0.5.2&#34;,
    urls = [&#34;https://github.com/grailbio/bazel-compilation-database/archive/0.5.2.tar.gz&#34;],
)

load(&#34;@com_grail_bazel_compdb//:deps.bzl&#34;, &#34;bazel_compdb_deps&#34;)
bazel_compdb_deps()
</code></pre><p>针对想生成compile database的target，写入下面的代码，target可以直接写到targets里面</p>
<pre tabindex="0"><code>## Replace workspace_name and dir_path as per your setup.
load(&#34;@com_grail_bazel_compdb//:defs.bzl&#34;, &#34;compilation_database&#34;)
load(&#34;@com_grail_bazel_output_base_util//:defs.bzl&#34;, &#34;OUTPUT_BASE&#34;)

compilation_database(
    name = &#34;example_compdb&#34;,
    targets = [
        &#34;//a_cc_binary_label&#34;,
        &#34;//a_cc_library_label&#34;,
    ],
    # OUTPUT_BASE is a dynamic value that will vary for each user workspace.
    # If you would like your build outputs to be the same across users, then
    # skip supplying this value, and substitute the default constant value
    # &#34;__OUTPUT_BASE__&#34; through an external tool like `sed` or `jq` (see
    # below shell commands for usage).
    output_base = OUTPUT_BASE,
)
</code></pre><p>在命令行运行下面的命令，就可以拿到对应target的compile database了</p>
<pre tabindex="0"><code># Command to generate the compilation database file.
bazel build //path/to/pkg/dir:example_compdb

# Location of the compilation database file.
outfile=&#34;$(bazel info bazel-bin)/path/to/pkg/dir/compile_commands.json&#34;

# [Optional] Command to replace the marker for output_base in the file if you
# did not use the dynamic value in the example above.
output_base=$(bazel info output_base)
sed -i.bak &#34;s@__OUTPUT_BASE__@${output_base}@&#34; &#34;${outfile}&#34;

# The compilation database is now ready to use at this location.
echo &#34;Compilation Database: ${outfile}&#34;
</code></pre><p>这里的方法是固定针对的target，我个人更推荐这种用法，因为我觉得对文件夹做分析会疏于管理。如果针对文件夹级别，看下面的脚本</p>
<pre tabindex="0"><code>INSTALL_DIR=&#34;/usr/local/bin&#34;
VERSION=&#34;0.5.2&#34;

# Download and symlink.
(
  cd &#34;${INSTALL_DIR}&#34; \
  &amp;&amp; curl -L &#34;https://github.com/grailbio/bazel-compilation-database/archive/${VERSION}.tar.gz&#34; | tar -xz \
  &amp;&amp; ln -f -s &#34;${INSTALL_DIR}/bazel-compilation-database-${VERSION}/generate.py&#34; bazel-compdb
)

bazel-compdb # This will generate compile_commands.json in your workspace root.

# To pass additional flags to bazel, pass the flags as arguments after --
bazel-compdb -- [additional flags for bazel]

# You can tweak some behavior with flags:
# 1. To use the source dir instead of bazel-execroot for directory in which clang commands are run.
bazel-compdb -s
bazel-compdb -s -- [additional flags for bazel]
# 2. To consider only targets given by a specific query pattern, say `//cc/...`. Also see below section for another way.
bazel-compdb -q //cc/...
bazel-compdb -q //cc/... -- [additional flags for bazel]
</code></pre>

<h3 class="relative group">17 Bazel管理Docker 
    <div id="17-bazel%E7%AE%A1%E7%90%86docker" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#17-bazel%E7%AE%A1%E7%90%86docker" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>使用Docker编译镜像方便快捷，但是使用Docker打包出来的定向并不是确定的，换言之两个内部打包的binary一样的Docker镜像，其sha256是不同的，因此使用Bazel管理Docker镜像能带来的好处就是镜像确定化，即用来检查某些文件是不是发生了变化。</p>


<h4 class="relative group">container_import 
    <div id="container_import" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#container_import" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>为什么第一个写container_import? 在集成Bazel管理Docker机制到CI体系中的时候，发现Bazel直接用内置的Docker下载机制将镜像下载过程当中时，会非常慢（原因就不多分析拉），因此采用了Docker镜像直接导入，之后将之Import到Bazel内部的方法。</p>
<p>步骤很简单，</p>
<ol>
<li>在Node机器上下载外部Base镜像，一般情况下，CI机器内部都已经缓存了镜像</li>
<li>使用docker save命令，将Base镜像存储到本地，打开压缩包里面的config.json文件</li>
<li>参考下面的代码，首先将config.json文件配置为filegroup</li>
<li>使用container_import命令，标记image_digest和config.json文件导入即可，其中tag加上no-cache和no-remote用来标记不需要缓存到远端，避免占用过多空间和内存。base镜像直接缓存到本地</li>
</ol>
<p>如下所示，Bazel就可以读取到导入的镜像了</p>
<pre tabindex="0"><code>```python

load(&#34;@io_bazel_rules_docker//cc:image.bzl&#34;, &#34;cc_image&#34;)
load(&#34;@io_bazel_rules_docker//container:container.bzl&#34;, &#34;container_bundle&#34;, &#34;container_import&#34;)

package(default_visibility = [&#34;//visibility:public&#34;])

filegroup(
    name = &#34;base_image_config_json&#34;,
    srcs = [
        &#34;base_image_config.json&#34;,
    ],
    visibility = [&#34;//visibility:public&#34;],
)

container_import(
    name = &#34;base_image&#34;,
    base_image_digest = &#34;sha256:xxxxxxxxxxxxxxxxxxxxxx2e457cd116a429257d8f3615e51a55c56b3705539568d58c&#34;,
    base_image_registry = &#34;registry.xxxxxx.com&#34;,
    base_image_repository = &#34;global/xxxxxx&#34;,
    config = &#34;:base_image_config_json&#34;,
    layers = [],
    tags = [
        &#34;no-cache&#34;,
        &#34;no-remote&#34;,
    ],
)
```
</code></pre><p>接下来，只需要运行docker pull，这个镜像只要在本地就可以直接load进bazel了。</p>


<h4 class="relative group">编译deterministic的镜像 
    <div id="%E7%BC%96%E8%AF%91deterministic%E7%9A%84%E9%95%9C%E5%83%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BC%96%E8%AF%91deterministic%E7%9A%84%E9%95%9C%E5%83%8F" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>编译确定性的镜像就比较简单了，这里我以cc_image为例子，编译镜像并自定义命名Docker镜像</p>
<p>代码如下，这里面复用了上一节的base_image的target.如下面的代码和流程</p>
<ol>
<li>cc_image的base指定为Docker Base Image，这里就是上一节导入的base_image。binary指定为要编译出来的C++ Target</li>
<li>container_bundle用来解决镜像命名的问题，这里的REAL_IMAGE就是真正的命名对象。两个规则都加no-remote来避免cache</li>
</ol>
<pre tabindex="0"><code>```python

load(&#34;@io_bazel_rules_docker//cc:image.bzl&#34;, &#34;cc_image&#34;)
load(&#34;@io_bazel_rules_docker//container:container.bzl&#34;, &#34;container_bundle&#34;, &#34;container_import&#34;)

package(default_visibility = [&#34;//visibility:public&#34;])


cc_image(
    name = &#34;image&#34;,
    base = &#34;:base_image&#34;,
    binary = &#34;//offboard/xxx:abc_target&#34;,
    tags = [
        &#34;no-remote&#34;,
    ],
)

container_bundle(
    name = &#34;taged_image&#34;,
    images = {
        &#34;$(REAL_IMAGE)&#34;: &#34;:image&#34;,
    },
    tags = [
        &#34;no-remote&#34;,
    ],
)
```
</code></pre><p>那么如何将镜像编译出来呢？运行如下命令即可编译出来名字为hxndg:image的镜像</p>
<pre tabindex="0"><code>```shellscript
bazel run --define REAL_IMAGE=hxndg:image xxxx/xxx/xxx:taged_image -- --norun

```
</code></pre>

<h2 class="relative group">高级篇 
    <div id="%E9%AB%98%E7%BA%A7%E7%AF%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%AB%98%E7%BA%A7%E7%AF%87" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">18 原理解释 
    <div id="18-%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#18-%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">概念解释 
    <div id="%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>针对Bazel，Action和CAS是平时常见的两个概念。这次重新解释下对应的概念。</p>


<h5 class="relative group">Action 
    <div id="action-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#action-1" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>在Build，Test时运行的命令，包含很多方面：比方说，对编译器的调用，执行某个test。注意Action内部包括命令行参数、环境变量和依赖的输入/输出文件产物或者其它的Action等元数据。举一个简单的例子，给出下面的一个Bazel aquery（action query）的结果。可以看到其包含了编译出来的产物，中间文件，环境变量，命令等多方面信息。Bazel的远程执行分发的可以理解为就是Action的简单包装。</p>
<p>Action的多种信息，比方说Command，Inputs，Outputs都会被Hash。但是只有Command，Inputs会被当做Hashed Key存储到Action Cache里，Outputs会被当成Cache Key。这里注意，有一个非常Tricky的点，及Action Cache并没有真正的Cache Action，它Cache的是Action的FingerPrint，利用FingerPrint能够方便快捷地找到对应Action和产物</p>
<p>在这种情况下，我们就可以引出Action graph的概念了，存储于内存中的包含Action调用关系和产物的有向图，在<a href="https://bazel.build/reference/glossary#analysis-phase" target="_blank">analysis phase</a> 产生，在真正的执行阶段使用，即<a href="https://bazel.build/reference/glossary#execution-phase" target="_blank">execution phase</a>使用。而Action graph实际上就是个Merkle-Tree，相关概念用户可以自己搜索下</p>
<p>Copy</p>
<pre tabindex="0"><code>[example@example-dev-example:/example(master) ] $ bazel aquery //expxxx/xxx/xxxxx_
INFO: Invocation ID: ea675cf9-4014-42b4-ac53-dc134710a7ea
INFO: Analyzed target //experimental/xxx/xxx/xxxxx_ (1 packages loaded, 2 targets configured).
INFO: Found 1 target...
BazelCppSemantics_build_arch_k8-fastbuild for //experimental/xxxxxxs/xxx/xxxx:xxxxx
  Mnemonic: Middleman
  Target: //experimental/xxxxxxs/xxx/xxx/xxxxx_
  Configuration: k8-fastbuild
  Execution platform: @local_config_platform//:host
  ActionKey: 709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c
  Inputs: [bazel-out/k8-fastbuild/internal/_middlemen/@com_Ugoogle_Ugoogletest_S_S_Cgtest-BazelCppSemantics_build_arch_k8-fastbuild, bazel-out/k8-fastbuild/internal/_middlemen/@com_Ugoogle_Ugoogletest_S_S_Cgtest_Umain-BazelCppSemantics_build_arch_k8-fastbuild]
  Outputs: [bazel-out/k8-fastbuild/internal/_middlemen/_S_Sexperimental_Sxxxx_Sxxxx_Ssimd_Cxxxx_Uxxxx-BazelCppSemantics_build_arch_k8-fastbuild]

action &#39;Compiling experimental/xxxxxxs/xxx/xxx/xxxxx.cc&#39;
  Mnemonic: CppCompile
  Target: //experimental/xxxxxxs//xxx/xxx/xxxxx_test
  Configuration: k8-fastbuild
  Execution platform: @local_config_platform//:host
  ActionKey: bc54c74489c4827e0560d03bea1096265f8c92eb0d9ac316eacc55031d0cd65f
  Inputs: [bazel-out/k8-fastbuild/internal/_middlemen/_S_Sexperimental_Sxxxx_Sxxxx_Ssimd_Cxxxx_Uxxxx-BazelCppSemantics_build_arch_k8-fastbuild, xxxxx/xxx/xxxx/xxxx/fma_test.cc, external/bazel_tools/tools/cpp/grep-includes.sh, external/llvm_repo/llvm/bin/clang, external/llvm_repo/llvm/bin/clang++, external/llvm_repo/llvm/bin/clang-cpp, external/llvm_repo/llvm/include/c++/v1/__algorithm/adjacent_find.h, external/llvm_repo/llvm/include/c++/v1/__algorithm/all_of.h, 
  ...
external/local_cuda/cuda/nvvm/libnvvm-samples/simple/simple-gpu64.ll, external/local_cuda/cuda/nvvm/libnvvm-samples/simple/simple.c]
  Outputs: [bazel-out/k8-fastbuild/bin/xxxxx/xxx/xxxx/xxxx/_objs/fma_test/fma_test.pic.d, bazel-out/k8-fastbuild/bin/xxxxx/xxx/xxxx/xxxx/_objs/fma_test/fma_test.pic.o]
  Environment: [DOCKER_REPO_CACHE=/example_cache/docker, GOCACHE=/example_cache/go/cache, GOMODCACHE=/example_cache/go/module, GO_REPOSITORY_USE_HOST_CACHE=1, OMP_NUM_THREADS=1, PATH=/bin:/usr/bin:/usr/local/bin]
  Command Line: (exec external/llvm_toolchain/bin/cc_wrapper.sh \
    &#39;--target=x86_64-unknown-linux-gnu&#39; \
    -U_FORTIFY_SOURCE \
    -fstack-protector \
    -fno-omit-frame-pointer \
    -fcolor-diagnostics \
    -Wall \
    -Wthread-safety \
    -Wself-assign \
    -mavx2 \
    -mfma \
    &#39;-std=c++17&#39; \
    &#39;-stdlib=libstdc++&#39; \
    -MD \
    -MF \
    bazel-out/k8-fastbuild/bin/xxxxx/xxx/xxxx/xxxx/_objs/fma_test/fma_test.pic.d \
    &#39;-frandom-seed=bazel-out/k8-fastbuild/bin/xxxxx/xxx/xxxx/xxxx/_objs/fma_test/fma_test.pic.o&#39; \
    -fPIC \
    -iquote. \
    -iquotebazel-out/k8-fastbuild/bin \
    -iquoteexternal/com_google_googletest \
    -iquotebazel-out/k8-fastbuild/bin/external/com_google_googletest \
    -iquoteexternal/bazel_tools \
    -iquotebazel-out/k8-fastbuild/bin/external/bazel_tools \
    -isystem \
    external/com_google_googletest/googlemock \
    -isystem \
    bazel-out/k8-fastbuild/bin/external/com_google_googletest/googlemock \
    -isystem \
    external/com_google_googletest/googlemock/include \
    -isystem \
    bazel-out/k8-fastbuild/bin/external/com_google_googletest/googlemock/include \
    -isystem \
    external/com_google_googletest/googletest \
    -isystem \
    bazel-out/k8-fastbuild/bin/external/com_google_googletest/googletest \
    -isystem \
    external/com_google_googletest/googletest/include \
    -isystem \
    bazel-out/k8-fastbuild/bin/external/com_google_googletest/googletest/include \
    -UQ_CPU_ONLY \
    -DS2_USE_GFLAGS \
    -DS2_USE_GLOG \
    -DDCHECK_ALWAYS_ON \
    &#39;-std=c++17&#39; \
    -Wdeprecated-declarations \
    &#39;-Werror=reorder&#39; \
    -Wno-unknown-warning-option \
    -Wno-unused-local-typedef \
    -Wdelete-non-abstract-non-virtual-dtor \
    -Wenum-compare \
    -Wextra-tokens \
    -Wignored-qualifiers \
    -Winconsistent-missing-override \
    -Wlogical-op-parentheses \
    -Wmacro-redefined \
    -Wpessimizing-move \
    -Wrange-loop-construct \
    -Wreturn-stack-address \
    -Wreturn-type \
    -Wself-assign-overloaded \
    -Wswitch \
    -Wthread-safety-analysis \
    -Wunused-but-set-variable \
    -Wunused-function \
    -Wunused-lambda-capture \
    -Wunused-parameter \
    -Wunused-private-field \
    -Wunused-result \
    -Wunused-variable \
    &#39;-ffp-contract=off&#39; \
    -Wno-deprecated-builtins \
    -Wno-deprecated-declarations \
    -Wextra \
    -Wno-sign-compare \
    -Werror \
    &#39;-Wno-error=unused-parameter&#39; \
    &#39;-Wno-error=unused-but-set-variable&#39; \
    -fno-access-control \
    -no-canonical-prefixes \
    -Wno-builtin-macro-redefined \
    &#39;-D__DATE__=&#34;redacted&#34;&#39; \
    &#39;-D__TIMESTAMP__=&#34;redacted&#34;&#39; \
    &#39;-D__TIME__=&#34;redacted&#34;&#39; \
    &#39;-fdebug-prefix-map=external/llvm_repo/llvm/=__bazel_toolchain_llvm_repo__/&#39; \
    -c \
    xxxxx/xxx/xxxx/xxxx/fma_test.cc \
    -o \
    bazel-out/k8-fastbuild/bin/xxxxx/xxx/xxxx/xxxx/_objs/fma_test/fma_test.pic.o)
# Configuration: 8b90087b699d1ce6fd2f950930f3d839cf137c3e40ca61e38ebd7a75ed2a64eb
# Execution platform: @local_config_platform//:host
</code></pre>

<h3 class="relative group"> 
    <div id="" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">19 Bazel自定义规则 
    <div id="19-bazel%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#19-bazel%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">20 Bazel工具链配置和使用 
    <div id="20-bazel%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#20-bazel%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">21 性能诊断 
    <div id="21-%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#21-%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">默认profile文件 
    <div id="%E9%BB%98%E8%AE%A4profile%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%BB%98%E8%AE%A4profile%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>对于一个黑盒的增量编译系统，做性能诊断是比较困难的，不过Bazel内置了Profile功能，每执行完一次编译行为，就会在输出根目录生成一个command.profile.gz文件，即路径为下面的文件</p>
<pre tabindex="0"><code>$(bazel info output_base)/command.profile.gz
</code></pre><p>这个文件的分析，建议打开chrome://tracing/，然后load对应的profile文件进行分析。</p>


<h3 class="relative group"> 
    <div id="" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">如何阅读profile文件 
    <div id="%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBprofile%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBprofile%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>要看剖析结果，请在Chrome浏览器标签中打开chrome://tracing，点击“Load”并选择对应的profile文件</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://lets-write-some-bazel-guide.gitbook.io/~gitbook/image?url=https%3A%2F%2Fbazel.build%2Fstatic%2Fdocs%2Fimages%2Fjson-trace-profile.png&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=42308104c9913661ed24127240eb597db05ee59489c4dd124ace315264405faf" alt="img" />
    
  </figure>
</p>
<ul>
<li>按1进入“选择”模式。单击特定的方框以查看事件的详细信息，说白了就是看具体的时间消耗，比方说wall time，cpu time啥的</li>
<li>按2进入“平移”模式。然后拖动鼠标来移动视图</li>
<li>按3进入“缩放”模式。然后拖动鼠标进行缩放。用w/s键进行放大和缩小</li>
<li>按4进入“定时”模式，可以测量两个事件之间的时间间隔</li>
</ul>


<h4 class="relative group">阅读Profile文件的关键指标 
    <div id="%E9%98%85%E8%AF%BBprofile%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%98%85%E8%AF%BBprofile%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>bazel analyze-profile是bazel提供的子命令，不过这个我个人感觉不如自己写jq分析json的profile文件或者直接看时间消耗更方便。。。</p>


<h4 class="relative group">怎么看profile文件 
    <div id="%E6%80%8E%E4%B9%88%E7%9C%8Bprofile%E6%96%87%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%80%8E%E4%B9%88%E7%9C%8Bprofile%E6%96%87%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一般阅读profile文件都是追求时间的效率，针对具体的bazel一个action，有意思的点击该action之后会显示相应的信息。有以下集中类型的时间消耗</p>
<ul>
<li><strong>Wall time</strong> 是实际经过的现实世界时间.
<ul>
<li>一般推荐使用<a href="https://bazel.build/advanced/performance/json-trace-profile" target="_blank">JSON trace profile</a> 来分析性能消耗</li>
</ul>
</li>
<li><strong>CPU time</strong>是CPU执行用户代码所花费的时间
<ul>
<li>很多时候具体问题处在了用户代码还是bazel本身的问题很难说，这种情况下一般加上</li>
</ul>
</li>
<li>System time是CPU在内核中花费的时间.
<ul>
<li>主要与Bazel从文件系统读取文件时的I/O相关，这个实际上也一般不出问题</li>
</ul>
</li>
</ul>
<p>如果怀疑时间可能和系统负载相关，可以加上 <a href="https://github.com/bazelbuild/bazel/blob/6.0.0/src/main/java/com/google/devtools/build/lib/runtime/CommonCommandOptions.java#L306-L312" target="_blank"><code>--experimental_collect_load_average_in_profiler</code></a> flag，这个flag是bazel 6.0引入，对应的profile文件里面会有对应系统负载的信息，如下图</p>


<h4 class="relative group">显示网络的使用情况 
    <div id="%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>启用远端执行的情况下，网络带宽会影响编译的效率（因为需要上传下载文件和输入）</p>
<p>添加 <code>--experimental_collect_system_network_usage</code> 可以在profile文件里面看到网络使用情况。</p>
<p>启用BEP（构建事件协议）中的NetworkMetrics.SystemNetworkStats proto可以收集网络使用情况（需要启用&ndash;experimental_collect_system_network_usage参数）进行监控，不过我还没实践过监控EBP的情况</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://lets-write-some-bazel-guide.gitbook.io/~gitbook/image?url=https%3A%2F%2Fbazel.build%2Fstatic%2Fdocs%2Fimages%2Fjson-trace-profile-network-usage.png&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=0325c59b86af10c4d2fb67bc037e64760c01797e530cbe82dbe47c6560172d16" alt="img" />
    
  </figure>
</p>


<h3 class="relative group">常见的profile问题点 
    <div id="%E5%B8%B8%E8%A7%81%E7%9A%84profile%E9%97%AE%E9%A2%98%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B8%B8%E8%A7%81%E7%9A%84profile%E9%97%AE%E9%A2%98%E7%82%B9" aria-label="锚点">#</a>
    </span>        
    
</h3>
<ul>
<li>分析阶段（runAnalysisPhase）比预期慢，尤其是增量构建的情况。这可能是规则实现不佳的迹象，例如将depsets展开的规则实现。包加载可能变慢是因为存在过多的目标、复杂的宏或递归的全局匹配。也有可能是文件下载过慢（比方说不用url，走bazel本身的下载），nas性能不够啥的，下一节写了这个情况</li>
<li>个别的慢速动作，特别是那些位于关键路径上的动作。可以尝试将大型动作拆分为多个较小的动作，或减少（传递）依赖项的数量以加快速度。比方说写了一个规则，单线程的跑test，这种常见于自己写的sh_test</li>
<li>瓶颈问题，这个一般是分配任务不均匀导致。优化这个问题可能需要修改规则实现或Bazel本身，我倒是基本没遇到过。</li>
</ul>


<h3 class="relative group">阅读profile做文件诊断的例子 
    <div id="%E9%98%85%E8%AF%BBprofile%E5%81%9A%E6%96%87%E4%BB%B6%E8%AF%8A%E6%96%AD%E7%9A%84%E4%BE%8B%E5%AD%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%98%85%E8%AF%BBprofile%E5%81%9A%E6%96%87%E4%BB%B6%E8%AF%8A%E6%96%AD%E7%9A%84%E4%BE%8B%E5%AD%90" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>看下面一个曾经遇到的例子，发现Bazel编译耗时很长，然后编译行为并不多，也就编译了几十个action就花了50mins，排查是analysis stage外部依赖花了很多时间下载，然而这些外部依赖都缓存在了对应的nas里面，并配置到编译CI环境的distdir，针对性排查网络和nas性能，发现是nas性能打满了，导致analysis stage过慢，最终更换高性能nas，并独占解决该问题</p>
<p>
    <figure>
      <img
        class="my-0 rounded-md"
        loading="lazy"
        srcset="
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/analysis_too_slow_hu_486a8098d2f8687b.png 330w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/analysis_too_slow_hu_bd127412c0526874.png 660w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/analysis_too_slow_hu_c9d492df8931aa9f.png 1024w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/analysis_too_slow_hu_9df85d12f343b6b5.png 2x"
        data-zoom-src="/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/analysis_too_slow_hu_9df85d12f343b6b5.png"
        src="/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/analysis_too_slow_hu_bd127412c0526874.png"
        alt=""
      />
      
    </figure>
</p>
<p>
    <figure>
      <img
        class="my-0 rounded-md"
        loading="lazy"
        srcset="
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/nas_perf_issue_hu_39353c4d1a1426c0.png 330w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/nas_perf_issue_hu_719bd2b43146db8c.png 660w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/nas_perf_issue_hu_e6550f289e00d399.png 1024w,
        /posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/nas_perf_issue_hu_c61ac06c20a7613c.png 2x"
        data-zoom-src="/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/nas_perf_issue_hu_c61ac06c20a7613c.png"
        src="/posts/2024-06-02-bazel%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%AD%E7%BA%A7/imgs/nas_perf_issue_hu_719bd2b43146db8c.png"
        alt="nas_perf_issue"
      />
      
    </figure>
</p>


<h3 class="relative group"> 
    <div id="" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h3 class="relative group">22 性能优化 
    <div id="22-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#22-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>Bazel的性能优化一般集中在以下几个方面：</p>
<ul>
<li>远程执行或远程缓存：共享action cache或文件，提供命中率
<ul>
<li>远程执行，默认情况下，编译和测试都在本地机器执行. 远程执行运行用户将编译和测试分布到不同的多台机器上执行.</li>
<li>远程缓存，remote cache：一般是相同Project的开发者，或者一个CI体系的研发系统用来共享编译产物，只要产物是确定性且可复用的，那么就能提高效率。参考https://github.com/buchgr/bazel-remote/</li>
</ul>
</li>
<li>减少外部依赖下载所使用的时间
<ul>
<li>简单来说就是distdir和第三方repo的cache</li>
</ul>
</li>
<li>减少java对内存的消耗</li>
</ul>
<p>我们一点一点说</p>


<h4 class="relative group">Remote Execution 
    <div id="remote-execution" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#remote-execution" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>远程执行，说白了就是把应该在本地做的事情放到了云端做，换言之“分布式编译（构建）”，随着bazel7.0的到来，构建支持异步式构建，因此远程执行会带来巨大的性能提升。</p>
<p>bazel的远程执行有一套remote execution api，只要兼容就可以，因此有多种远程执行的服务可以选择。</p>
<ul>
<li>非商业化服务
<ul>
<li><a href="https://github.com/buildbarn" target="_blank">Buildbarn</a></li>
<li><a href="https://github.com/bazelbuild/bazel-buildfarm" target="_blank">Buildfarm</a></li>
<li><a href="https://gitlab.com/BuildGrid/buildgrid" target="_blank">BuildGrid</a></li>
<li><a href="https://github.com/twitter/scoot" target="_blank">Scoot</a></li>
</ul>
</li>
<li>商业化服务
<ul>
<li><a href="https://www.engflow.com/" target="_blank">EngFlow Remote Execution</a> - Remote execution and remote caching service. Can be self-hosted or hosted.</li>
<li><a href="https://www.buildbuddy.io/" target="_blank">BuildBuddy</a> - Remote build execution, caching, and results UI.</li>
<li><a href="https://www.flare.build/" target="_blank">Flare</a> - Providing a cache + CDN for Bazel artifacts and Apple-focused remote builds in addition to build &amp; test analytics.</li>
</ul>
</li>
</ul>
<p>这其中<a href="https://github.com/bazelbuild/bazel-buildfarm" target="_blank">bazel-buildfarm </a>是bazel官方出的RBE方案官方文档，目前实际上已经处于可用状态，而且有一个很关键的一点，buildfarm支持worker节点扩缩容，因此我重点介绍这个软件。</p>
<p>关于其架构可以参考下面的链接，来获取一些基本的了解： <a href="https://github.com/bazelbuild/bazel-buildfarm/issues/351" target="_blank">https://github.com/bazelbuild/bazel-buildfarm/issues/351</a></p>


<h4 class="relative group">Buildfarm配置 
    <div id="buildfarm%E9%85%8D%E7%BD%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#buildfarm%E9%85%8D%E7%BD%AE" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>直接介绍下当前可用的BuildFarm配置是怎么做的，采用了10台BuildFarm Server维护集群的可用，24台固定的CPU Buildfarm Worker节点参与编译工作，6台GPU Buildfarm Worker参与GPU Test。除上述机器之外，还有自动扩缩容的机器参与到CPU Buildfarm Worker的工作当中。针对Buildfarm 2.3.1的版本，采用配置如下即可。</p>


<h5 class="relative group">Server配置 
    <div id="server%E9%85%8D%E7%BD%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#server%E9%85%8D%E7%BD%AE" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>backplane用来指定通信的媒介，拆分为两个不同的queues，用来方便任务的分发，比方说CPU任务包括编译和TEST，GPU任务则只包含TEST任务，可以看到GPU队列必须要满足相关的properties才会被正确的depatched。</p>
<p>CPU队列允许不匹配的规则，其中min-cores和max-cores都为*，就能保证没命中GPU类型任务都会命中到CPU队列当中</p>
<p>Server的类型为shard，这个是目前唯一支持的类型了</p>
<pre tabindex="0"><code>backplane:
  redisUri: &#34;redis://xxxxxxxxxxxxxxxxxxxxxxxx:6379&#34;
  queues:
    - name: &#34;gpu&#34;
      allowUnmatched: false
      properties:
        - name: &#34;gpu&#34;
          value: &#34;1&#34;
    - name: &#34;cpu&#34;
      allowUnmatched: true
      properties:
        - name: &#34;min-cores&#34;
          value: &#34;*&#34;
        - name: &#34;max-cores&#34;
          value: &#34;*&#34;
digestFunction: SHA256
maxEntrySizeBytes: 123456
server:
  name: &#34;shard&#34;
  recordBesEvents: true
</code></pre>

<h5 class="relative group">CPU Worker 
    <div id="cpu-worker" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#cpu-worker" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>CPU Worker的配置和Server端非常类似，其中executeStageWidth标记可同时并发的任务数量，inputFetchStageWidth则标记可以并发获取Input的数量。我们使用FILESYSTEM来标记该CPU节点既执行缓存操作，又有执行能力。realInputDirectories用来标记external，如果不写这个配置可能造成外部文件hard link过多的问题，</p>
<pre tabindex="0"><code>backplane:
  redisUri: &#34;redis://xxxxxxxxxxxxxxxxxxxxxxxx:6379&#34;
  queues:
    - name: &#34;cpu&#34;
      allowUnmatched: true
      properties:
        - name: &#34;min-cores&#34;
          value: &#34;*&#34;
        - name: &#34;max-cores&#34;
          value: &#34;*&#34;
digestFunction: SHA256
maxEntrySizeBytes: 123456     
worker:
  port: 8982
  publicName: &#34;localhost:8982&#34;
  executeStageWidth: 80
  inputFetchStageWidth: 8
  realInputDirectories:
    - &#34;external&#34;
  storages:
    - type: FILESYSTEM
      maxSizeBytes: 123124124124123123
</code></pre>

<h5 class="relative group">GPU Worker 
    <div id="gpu-worker" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#gpu-worker" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>可以看到GPU Worker的配置和CPU Worker类似，但是属性那一部分并不一致，借此来保证任务的正常调度。</p>
<pre tabindex="0"><code>backplane:
  redisUri: &#34;redis://xxxxxxxxxxxxxxxxxxxxxxxx:6379&#34;
  queues:
    - name: &#34;gpu&#34;
      allowUnmatched: false
      properties:
        - name: &#34;gpu&#34;
          value: &#34;1&#34;
digestFunction: SHA256
maxEntrySizeBytes: 12345678      
worker:
  port: 8982
  publicName: &#34;localhost:8982&#34;
  executeStageWidth: 8
  inputFetchStageWidth: 8
  realInputDirectories:
    - &#34;external&#34;
  storages:
    - type: FILESYSTEM
      maxSizeBytes: 123123123123123
  dequeueMatchSettings:
    acceptEverything: true
    allowUnmatched: false
    properties:
      - name: &#34;gpu&#34;
        value: &#34;1&#34;
</code></pre>

<h5 class="relative group">终端用户集成 
    <div id="%E7%BB%88%E7%AB%AF%E7%94%A8%E6%88%B7%E9%9B%86%E6%88%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%88%E7%AB%AF%E7%94%A8%E6%88%B7%E9%9B%86%E6%88%90" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>将export的端口暴露为相应的grpc服务，然后直接在用户的BAZEL配置文件里面写下如下地址即可，其中GPU TEST的Build文件里面需要添加对应poperties类型，来保证这个test被正确地调度到对应的Worker</p>
<pre tabindex="0"><code>```python
    exec_properties = {&#34;gpu&#34;: &#34;1&#34;},
```
</code></pre><pre tabindex="0"><code>```shellscript
build --remote_executor=服务地址
build --remote_cache=
build --remote_timeout=5m&#34;
build --jobs=30 #控制并发数量
```
</code></pre>

<h4 class="relative group">Buildfarm生产用排雷 
    <div id="buildfarm%E7%94%9F%E4%BA%A7%E7%94%A8%E6%8E%92%E9%9B%B7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#buildfarm%E7%94%9F%E4%BA%A7%E7%94%A8%E6%8E%92%E9%9B%B7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>Buildfarm的使用实际上是有部分问题的，如果想把Buildfarm投入生产，建议注意下面几点</p>


<h5 class="relative group">grpc的负载均衡 
    <div id="grpc%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#grpc%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>和nginx的负载均衡不一样，grpc破坏了标准的连接级负载均衡，Kubernetes 提供的负载均衡本身是基于连接级别的负载均衡。这是因为 gRPC 构建于 HTTP/2 之上，而 HTTP/2 被设计为具有单个长期 TCP 连接，所有请求都在该连接上进行多路复用，这意味着多个请求可以在任何时间点在同一连接上处于活动<em>状态</em>。因此如果希望对buildfarm的服务做负载均衡，最好启用kubernetes的ingress机制</p>


<h5 class="relative group">Buildfarm的Liveness检查 
    <div id="buildfarm%E7%9A%84liveness%E6%A3%80%E6%9F%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#buildfarm%E7%9A%84liveness%E6%A3%80%E6%9F%A5" aria-label="锚点">#</a>
    </span>        
    
</h5>
<p>Buildfarm从1.15到2.3.1目前已经很稳定了，但是在机器压力过大或者inode不够用的情况下还是会出现问题，这些问题的统一表现是buildfarm的worker，java创建大量线程，因此可以根据该特征写一个livenessprobe检查</p>
<p>Copy</p>
<pre tabindex="0"><code>```yaml
        livenessProbe:
          exec:
            command:
            - /bin/bash
            - -c
            - |-
              java_thread_count=$(ps huH p $(ps -C java -o pid=) | grep java | wc -l);
              if [ &#34;$java_thread_count&#34; -gt &#34;1000&#34; ]; then
                exit 1
              fi
          failureThreshold: 12
          initialDelaySeconds: 300
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 3
```
</code></pre>

<h4 class="relative group">Remote Cache 
    <div id="remote-cache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#remote-cache" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>Remote Cache的使用，相比Buildfarm就简单很多了，推荐直接参考https://github.com/buchgr/bazel-remote/。</p>
<p>说白了，在本地就是运行</p>
<pre tabindex="0"><code># Dockerhub example:
$ docker pull buchgr/bazel-remote-cache
$ docker run -u 1000:1000 -v /path/to/cache/dir:/data \
	-p 9090:8080 -p 9092:9092 buchgr/bazel-remote-cache \
	--max_size 5
</code></pre><p>在本地启动了对应的remote cache之后，在bazelrc文件当中写入下面的内容即可使用</p>
<pre tabindex="0"><code>common --remote_cache=xxx地址
</code></pre>

<h4 class="relative group">优化内存 
    <div id="%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>一般优化都是对时间效率的优化，不过另外一些时候希望优化对内存的使用。常见的方式就是指定启动flag &ndash;host_jvm_args设置最大堆大小，例如&ndash;host_jvm_args=-Xmx2g。</p>
<p>如果BUILD消耗内存，bazel可能抛出OutOfMemoryError（OOM）异常，不过我目前基本没遇到这个问题，针对一个7w个action的编译库，我配置的启动选项如下，，没啥问题。</p>
<pre tabindex="0"><code>bazel --host_jvm_args=-Xmx4g build -c opt
</code></pre><p>有一些选项可以用来控制内存中的graph是否保存，副作用是这次编译完了，下回没办法复用这次的编译结果。</p>
<ul>
<li>&ndash;discard_analysis_cache将减少执行过程（而非分析过程）中使用的内存。下次构建将不需要重新加载依赖和包，但需要重新进行分析和执行（尽管磁盘上的操作缓存已经存在）</li>
<li>&ndash;notrack_incremental_state将不会存储任何Bazel的内部依赖图中的边，简单来说，依赖关系没啦！因此增量构建无法使用了</li>
<li>&ndash;nokeep_state_after_build将在构建完成后丢弃所有数据，以便增量构建必须从头开始构建（除了磁盘上的操作缓存）</li>
</ul>
<p>我目前用的是</p>
<pre tabindex="0"><code>bazel --host_jvm_args=-Xmx4g build -c opt xxxxxx --notrack_incremental_state --nokeep_state_after_build --discard_analysis_cache
</code></pre><p>这里可能有一点要注意，不一定是bazel造成的内存消耗过多，对于kubernetes环境，buffer/cache也是一个可能造成内存消耗过多的点，这部分在POD当中也会被当做是内存消耗，尽管不是JAVA导致的（毕竟编译要访问大量文件）。</p>


<h3 class="relative group">23 Bazel集成Code Coverage 
    <div id="23-bazel%E9%9B%86%E6%88%90code-coverage" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#23-bazel%E9%9B%86%E6%88%90code-coverage" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h2 class="relative group">结尾 
    <div id="%E7%BB%93%E5%B0%BE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%93%E5%B0%BE" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>唉，尴尬</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://i.loli.net/2020/08/27/BFHNyfpx3EsIDUG.jpg" alt="狗头的赞赏码.jpg" />
    
  </figure>
</p>

          
          
          
        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_posts\/2024-06-02-bazel从入门到中级\/index.md"
        var oid_likes = "likes_posts\/2024-06-02-bazel从入门到中级\/index.md"
      </script>
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
      
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/posts/2023-08-21-%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E5%85%BB/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >2023-08-21-工程师修养</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2023-08-21T00:00:00&#43;00:00">2023 年 8 月 21 日</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/posts/2024-05-10-suricata/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >2024-05-10-suricata</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2024-05-10T00:00:00&#43;00:00">2024 年 5 月 10 日</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="返回顶部" title="返回顶部">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      © 2025 - 2025 菜狗 All Rights Reserved.
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a> 强力驱动
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="https://hxndg.github.io/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="搜索"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="关闭 (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
